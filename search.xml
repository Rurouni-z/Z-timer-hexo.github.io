<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/04/28/hello-world/"/>
      <url>/2023/04/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>三维重建之路上</title>
      <link href="/2023/03/26/%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E4%B9%8B%E8%B7%AF%E4%B8%8A-three-d-reconstruction-1/"/>
      <url>/2023/03/26/%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E4%B9%8B%E8%B7%AF%E4%B8%8A-three-d-reconstruction-1/</url>
      
        <content type="html"><![CDATA[<p>instant-ngp –scene data&#x2F;nerf&#x2F;fox<br>视频：<a href="https://www.bilibili.com/video/BV1mT4y1o7Q2">计算机视觉之三维重建</a><br>找到一个同样是这个视频的<a href="https://blog.csdn.net/xijuezhu8128/category_11916420.html">笔记网址</a><br><a name="PVvJl"></a></p><h2 id="摄像机几何"><a href="#摄像机几何" class="headerlink" title="摄像机几何"></a>摄像机几何</h2><p><a name="yUygC"></a></p><h3 id="针孔模型-amp-透镜"><a href="#针孔模型-amp-透镜" class="headerlink" title="针孔模型 &amp; 透镜"></a>针孔模型 &amp; 透镜</h3><p><a name="kEeEO"></a></p><h4 id="针孔摄像机"><a href="#针孔摄像机" class="headerlink" title="针孔摄像机"></a>针孔摄像机</h4><p>物体直接映射到胶片上，会导致多个点映射到同一个点上，因此采用针孔成像。如下图，其中x,y,z是世界点Pw在摄像机坐标系上的坐标，已知；f是焦距，已知；由此可求得P’在像平面坐标。<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="DVeeA"></a></p><h4 id="加透镜"><a href="#加透镜" class="headerlink" title="加透镜"></a>加透镜</h4><p>可以让上述摄像机保持焦距越小，图像越清晰的情况下，<strong>增加亮度</strong>。<br>透镜将所有平行于光轴的光线汇聚到焦点，焦点到透镜中心的距离称为焦距（非上述焦距）。穿过透镜中心的光线的<strong>方向不会改变</strong>。<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-1.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>产生的问题：</p><ul><li>失焦，物体“聚焦”有特定距离，一些地方清晰，一些地方模糊</li><li>径向畸变<br><a name="QKFdG"></a></li></ul><h3 id="摄像机几何-1"><a href="#摄像机几何-1" class="headerlink" title="摄像机几何"></a>摄像机几何</h3><p>为了将像平面图像（连续）转到数字图像（离散），使其可被建模。进行一些修正：<br>前三步是摄像机坐标系下<br><a name="zyC7R"></a></p><h4 id="1-偏置-单位变换"><a href="#1-偏置-单位变换" class="headerlink" title="1. 偏置 单位变换"></a>1. 偏置 单位变换</h4><p>（下图f&#x3D;f+z0,简化符号）</p><ul><li><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-2.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></li></ul><hr><p><a name="bcZVp"></a></p><h4 id="2-转化为齐次坐标系"><a href="#2-转化为齐次坐标系" class="headerlink" title="2. 转化为齐次坐标系"></a>2. 转化为齐次坐标系</h4><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-3.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>其中M是相机内参，不变矩阵，P是3D点，变化向量，建立了P’到P的线性关系<br><a name="S7JfO"></a></p><h5 id="插曲：将坐标转为线性关系"><a href="#插曲：将坐标转为线性关系" class="headerlink" title="插曲：将坐标转为线性关系"></a>插曲：将坐标转为线性关系</h5><ul><li>齐次坐标：EtoH：多加一维，值为1；HtoE：前n-1维除以第n维（E欧氏空间、H齐次空间）</li><li><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-4.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png">（α&#x3D;fk。β&#x3D;fl）</li><li>约定后续Ph写做P，除非特别指明是欧式空间下的P</li><li><img src="https://cdn.nlark.com/yuque/0/2023/png/12600461/1679105948768-f4b176af-ef6a-4e1c-9bfb-e2bd5cbc20c3.png#averageHue=%23fbf9f9&clientId=u304ec050-67df-4&from=paste&height=225&id=u10073beb&name=image.png&originHeight=429&originWidth=796&originalType=binary&ratio=1.2699999809265137&rotation=0&showTitle=false&size=74795&status=done&style=none&taskId=u1bf1fadc-ef79-4920-9d90-13d609f21c6&title=&width=417.75933837890625" alt="image.png"></li></ul><hr><p><a name="thwSn"></a></p><h4 id="3-摄像机偏移"><a href="#3-摄像机偏移" class="headerlink" title="3. 摄像机偏移"></a>3. 摄像机偏移</h4><p>工艺问题，不能垂直，所以需要加偏移系数<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-5.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>自由度：α，β，θ，Cx，Cy<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-6.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></p><hr><p><a name="dUwn6"></a></p><h4 id="4-世界坐标系转换到摄像机坐标系"><a href="#4-世界坐标系转换到摄像机坐标系" class="headerlink" title="4. 世界坐标系转换到摄像机坐标系"></a>4. 世界坐标系转换到摄像机坐标系</h4><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-7.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="SDFNM"></a></p><h4 id="5-摄像机模型P’-x3D-K-R-T-Pw"><a href="#5-摄像机模型P’-x3D-K-R-T-Pw" class="headerlink" title="5. 摄像机模型P’&#x3D;K[R T]Pw"></a>5. 摄像机模型P’&#x3D;K[R T]Pw</h4><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-8.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>RT矩阵具体内容不知道是什么，如有链接欢迎评论，后面的<strong>摄像机标定的</strong><a href="#HFfse"><strong>补充知识</strong></a><strong>有讲</strong></p><hr><p><a name="Vb4P5"></a></p><h5 id="物理意义、自由度、欧式空间"><a href="#物理意义、自由度、欧式空间" class="headerlink" title="物理意义、自由度、欧式空间"></a>物理意义、自由度、欧式空间</h5><ol><li><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-9.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></li><li>自由度：五个内参+6个外参（3个旋转3个平移）&#x3D; 11个自由度（图中应该是1×4）</li><li>齐次空间转换为欧式空间：<img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-10.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="nXOMW"></a></li></ol><h4 id="Fauferas定理"><a href="#Fauferas定理" class="headerlink" title="Fauferas定理"></a>Fauferas定理</h4><p>零倾斜就是没有θ<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-11.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="Bm2Md"></a></p><h4 id="投影变换的性质"><a href="#投影变换的性质" class="headerlink" title="投影变换的性质"></a>投影变换的性质</h4><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-12.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="bRqXq"></a></p><h3 id="其他摄像机模型"><a href="#其他摄像机模型" class="headerlink" title="其他摄像机模型"></a>其他摄像机模型</h3><p><a name="bo1qJ"></a></p><h4 id="规范化摄像机"><a href="#规范化摄像机" class="headerlink" title="规范化摄像机"></a>规范化摄像机</h4><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-13.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="k4TrS"></a></p><h4 id="弱透视投影摄像机"><a href="#弱透视投影摄像机" class="headerlink" title="弱透视投影摄像机"></a>弱透视投影摄像机</h4><p>当相对景深小于其与相机的距离时，可以对其进行一些简化，就简单地认为这些点就在一个深度上，直接投影到平面上，适合拍摄中远距离图像<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-14.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></p><ul><li>其中f’为焦距，z0是物体到光圈O的距离，xy物体真实位置，x’y’像素面位置。这样子将z0固定为常数，使其为线性变换，而不是<a href="#kEeEO">非线性变换</a>。</li></ul><p>v应该是 1×3 矩阵，Abv是K[R T]之后的结果<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-15.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-16.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="UQgMG"></a></p><h4 id="正交投影摄像机"><a href="#正交投影摄像机" class="headerlink" title="正交投影摄像机"></a>正交投影摄像机</h4><p>当摄像机中心到像平面距离无限远时，直接映射。<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-17.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="WR68Q"></a></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>正交投影，更多地应用在建筑设计AUTOCAD，或者工业设计行业</li><li>弱透视投影在数学方面更简单，当物体较小且较远时准确，常用于图像识别任务</li><li>透视投影对于3D到2D映射的建模更为准确，用于运动恢复结构或SLAM</li><li>参考博客<ul><li><a href="https://zhuanlan.zhihu.com/p/154808198">机器视觉学习（七）摄像机模型</a></li><li><a href="https://blog.csdn.net/qq_28087491/article/details/107965151">常用相机投影及畸变模型（针孔|广角|鱼眼）</a></li><li><a href="https://www.cnblogs.com/silence-cho/p/15023822.html">针孔相机成像模型</a></li><li><a href="https://www.jianshu.com/p/510f43de2164">二维坐标转换与坐标系转换</a></li><li><a href="https://blog.csdn.net/swety_gxy/article/details/73087848">三维空间中的几何变换-平移旋转缩放</a></li><li><a href="https://pengfeixc.com/blogs/computer-graphics">计算机图形学</a><br><a name="etdZi"></a></li></ul></li></ul><h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><p><a name="IMPSW"></a></p><h4 id="线性方程组的最小二乘解"><a href="#线性方程组的最小二乘解" class="headerlink" title="线性方程组的最小二乘解"></a>线性方程组的最小二乘解</h4><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-18.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="SU3hp"></a></p><h4 id="齐次线性方程组的最小二乘解"><a href="#齐次线性方程组的最小二乘解" class="headerlink" title="齐次线性方程组的最小二乘解"></a>齐次线性方程组的最小二乘解</h4><p>只需记住齐次线性用奇异值分解即可，后面经常用<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-19.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="qCzTi"></a></p><h4 id="非线性方程组的最小二乘解"><a href="#非线性方程组的最小二乘解" class="headerlink" title="非线性方程组的最小二乘解"></a>非线性方程组的最小二乘解</h4><p>只需记住齐次非线性用牛顿、L-M方法即可，后面经常用<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-20.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="VWsOw"></a></p><h2 id="摄像机标定"><a href="#摄像机标定" class="headerlink" title="摄像机标定"></a>摄像机标定</h2><p>摄像机标定，即<strong>已知点坐标求解摄像机内、外参数矩阵</strong>，使得二维转三维可行。<br>更换符号：p&#x3D;P’（像平面P’变为p）     P&#x3D;Pw（世界坐标Pw变为P）。<br><a name="UKmUo"></a></p><h3 id="1-标定问题基本思路"><a href="#1-标定问题基本思路" class="headerlink" title="1. 标定问题基本思路"></a>1. 标定问题基本思路</h3><p> <img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-21.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="nhXJc"></a></p><h3 id="2-超定齐次方程的原因"><a href="#2-超定齐次方程的原因" class="headerlink" title="2. 超定齐次方程的原因"></a>2. 超定齐次方程的原因</h3><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-22.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="LDwvq"></a></p><h3 id="3-转换成矩阵形式"><a href="#3-转换成矩阵形式" class="headerlink" title="3. 转换成矩阵形式"></a>3. 转换成矩阵形式</h3><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-23.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="NVpqQ"></a></p><h3 id="4-利用奇异值分解求超定齐次方程"><a href="#4-利用奇异值分解求超定齐次方程" class="headerlink" title="4. 利用奇异值分解求超定齐次方程"></a>4. 利用奇异值分解求超定齐次方程</h3><p>其中M求解的值是真实世界的值差一个<strong>放大系数</strong><br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-24.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="b0ZeZ"></a></p><h3 id="5-提取摄像机系数"><a href="#5-提取摄像机系数" class="headerlink" title="5. 提取摄像机系数"></a>5. 提取摄像机系数</h3><p>详细过程参见：<a href="https://niecongchong.blog.csdn.net/article/details/127209507#t5">提取摄像机内参数</a><br>课堂知识：互相垂直点乘·为0（r1r2r3互相垂直）；r1×r2&#x3D;r3 （另外图中矩阵大小可能有误）<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-25.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="i3JVJ"></a></p><h4 id="5-1-求u0、v0，放大系数ρ"><a href="#5-1-求u0、v0，放大系数ρ" class="headerlink" title="5.1 求u0、v0，放大系数ρ"></a>5.1 求u0、v0，放大系数ρ</h4><p>不知道为什么a有时候转置有时候不转置<br>u0、v0就是<a href="#zyC7R">偏置Cx、Cy</a><br>r1·r3 &#x3D; 0；r2·r3&#x3D;0；r3·r3&#x3D;1，且都互不相关，正交矩阵<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-26.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>（图中是点乘不是叉乘）<br><a name="PatrE"></a></p><h4 id="5-2-求θ"><a href="#5-2-求θ" class="headerlink" title="5.2 求θ"></a>5.2 求θ</h4><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-27.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>然后左式子点乘 比上 右式子点乘即可出现下图 （具体看视频，虽然讲的也不怎么清楚，参考弹幕或前面的<a href="https://niecongchong.blog.csdn.net/article/details/127209507#t5">链接</a>）<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-28.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>ps. 如果θ&#x3D;90° 则符合faugeras定理<br><a name="qT9nR"></a></p><h4 id="5-3-求α和β"><a href="#5-3-求α和β" class="headerlink" title="5.3 求α和β"></a>5.3 求α和β</h4><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-29.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>如果α&#x3D;β，则符合faugeras定理<br><a name="inEAt"></a></p><h4 id="5-4-求外参r1，r2，r3"><a href="#5-4-求外参r1，r2，r3" class="headerlink" title="5.4 求外参r1，r2，r3"></a>5.4 求外参r1，r2，r3</h4><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-30.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="oFdwP"></a></p><h4 id="5-5-求外参T"><a href="#5-5-求外参T" class="headerlink" title="5.5 求外参T"></a>5.5 求外参T</h4><p>K满秩所必可逆<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-31.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="jJbl2"></a></p><h4 id="5-6-总结"><a href="#5-6-总结" class="headerlink" title="5.6 总结"></a>5.6 总结</h4><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-32.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>取点不能都位于同一平面，否则三点确定一个平面，多余的点都是没用的<br><a name="acfQ6"></a></p><h3 id="径向畸变的摄像机标定"><a href="#径向畸变的摄像机标定" class="headerlink" title="径向畸变的摄像机标定"></a>径向畸变的摄像机标定</h3><p><a name="Q1aWO"></a></p><h4 id="1-畸变模型"><a href="#1-畸变模型" class="headerlink" title="1. 畸变模型"></a>1. 畸变模型</h4><p>Sλ就是畸变矩阵<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-33.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="uZX1S"></a></p><h4 id="2-非线性求解"><a href="#2-非线性求解" class="headerlink" title="2. 非线性求解"></a>2. 非线性求解</h4><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-34.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>m1m2m3是<a href="#b0ZeZ">提取摄像机系数</a>里的投影矩阵的三行<br><a name="CQYTA"></a></p><h4 id="3-求解线性部分加快迭代"><a href="#3-求解线性部分加快迭代" class="headerlink" title="3. 求解线性部分加快迭代"></a>3. 求解线性部分加快迭代</h4><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-35.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>ui÷vi即在原世界坐标下的等比例缩放直线，就那个d2<br><a name="HFfse"></a></p><h3 id="补充知识-1"><a href="#补充知识-1" class="headerlink" title="补充知识"></a>补充知识</h3><p><a name="AFtVr"></a></p><h4 id="2D平面上的变换"><a href="#2D平面上的变换" class="headerlink" title="2D平面上的变换"></a>2D平面上的变换</h4><p><a name="JcnrV"></a></p><h5 id="欧式变换"><a href="#欧式变换" class="headerlink" title="欧式变换"></a>欧式变换</h5><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-36.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="WH0r5"></a></p><h5 id="相似变换"><a href="#相似变换" class="headerlink" title="相似变换"></a>相似变换</h5><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-37.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="mgqTd"></a></p><h5 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h5><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-38.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="qkdFZ"></a></p><h5 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h5><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-39.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="CWnR3"></a></p><h4 id="3D变换"><a href="#3D变换" class="headerlink" title="3D变换"></a>3D变换</h4><p><a name="YMczI"></a></p><h5 id="欧式-相似变换"><a href="#欧式-相似变换" class="headerlink" title="欧式+相似变换"></a>欧式+相似变换</h5><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-40.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="Nmej8"></a></p><h5 id="仿射变换-1"><a href="#仿射变换-1" class="headerlink" title="仿射变换"></a>仿射变换</h5><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-41.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="Aa7tF"></a></p><h5 id="透视变换-1"><a href="#透视变换-1" class="headerlink" title="透视变换"></a>透视变换</h5><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-42.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="i8fr7"></a></p><h2 id="单视图几何"><a href="#单视图几何" class="headerlink" title="单视图几何"></a>单视图几何</h2><p>用单张图构建三维模型<br><a name="VYNZX"></a></p><h3 id="单视测量"><a href="#单视测量" class="headerlink" title="单视测量"></a>单视测量</h3><p>00:17:46 影消点<br><a name="VaZCW"></a></p><h4 id="无穷远点、无穷远线、无穷远面"><a href="#无穷远点、无穷远线、无穷远面" class="headerlink" title="无穷远点、无穷远线、无穷远面"></a>无穷远点、无穷远线、无穷远面</h4><p><a name="EVjLI"></a></p><h5 id="2D空间"><a href="#2D空间" class="headerlink" title="2D空间"></a>2D空间</h5><p><strong>用l表示一条直线</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/12600461/1678154285531-0bfa14f4-d345-4ae1-b317-ef2e02729257.png#averageHue=%23ebebf2&clientId=u68e9a600-0c37-4&from=paste&height=317&id=u83842eee&name=image.png&originHeight=684&originWidth=1256&originalType=binary&ratio=1.2699999809265137&rotation=0&showTitle=false&size=55246&status=done&style=none&taskId=u88b7be70-3edb-4ab6-acfc-5e588cfc20e&title=&width=583.00146484375" alt="image.png"><br><strong>x是两条直线的交点，x是l和l’的叉乘</strong><br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-43.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><strong>2D空间中的无穷远点即当前直线方向的前两行加0即可。[a,b,0]</strong><br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-44.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><strong>2D空间中的无穷远直线</strong><br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-45.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="IGTw5"></a></p><h5 id="3D空间"><a href="#3D空间" class="headerlink" title="3D空间"></a>3D空间</h5><ul><li>3D空间的面</li></ul><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-46.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></p><ul><li>3D空间中的直线</li></ul><p>为了方便，将其直线定义为直线方向，或者两平面的交线<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-47.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></p><ul><li>3D空间中的无穷远点</li></ul><p>根据2D中的无穷远点，即在直线方向上（a,b,c）最后一行多加0即可<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-48.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></p><ul><li>3D空间中的无穷远平面</li></ul><p>无穷远直线即为同个平面上的平行线上的无穷远点集汇聚成无穷远直线；或者是两个平行平面在无穷远处交与一条直线。视频位置33:30.<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-49.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="iDZeo"></a></p><h3 id="影消点和影消面"><a href="#影消点和影消面" class="headerlink" title="影消点和影消面"></a>影消点和影消面</h3><p><a name="isQzT"></a></p><h4 id="2D平面"><a href="#2D平面" class="headerlink" title="2D平面"></a>2D平面</h4><ul><li><strong>无穷远点的变换</strong></li></ul><p>只要第三行为0就是无穷远点，透视除非v为0否则就不是。<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-50.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></p><ul><li><strong>无穷远线的变换</strong></li></ul><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-51.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>透视一般不是无穷远线，仿射一般是无穷远线。<br>因为仿射变换保持平行线不变，而透视变换可能会有在近处有交点而不会在无穷远处相交。<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-52.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="r58RU"></a></p><h4 id="影消点"><a href="#影消点" class="headerlink" title="影消点"></a>影消点</h4><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-53.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><strong>影消点与直线方向</strong><br>也可这样理解：K是做仿射变换，所以v&#x3D;Kd（为什么这里证明的时候不考虑外参矩阵，摄像机坐标系？）<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-54.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="eePSg"></a></p><h4 id="影消线"><a href="#影消线" class="headerlink" title="影消线"></a>影消线</h4><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-55.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></p><ul><li>橙色即影消线</li></ul><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-56.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="ulA20"></a></p><h4 id="影消线与平面法向量"><a href="#影消线与平面法向量" class="headerlink" title="影消线与平面法向量"></a>影消线与平面法向量</h4><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-57.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="FRZVb"></a></p><h4 id="总结（单视图重构关键）"><a href="#总结（单视图重构关键）" class="headerlink" title="总结（单视图重构关键）"></a>总结（单视图重构关键）</h4><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-58.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="bTJ9Z"></a></p><h3 id="单视图重构"><a href="#单视图重构" class="headerlink" title="单视图重构"></a>单视图重构</h3><p> <img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-59.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br> <img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-60.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>在假设下，θ已知，α&#x3D;β，则还剩下Cx，Cy未知，一共三个变量未知？，并且v1v2v3互相在三维中是垂直关系，然后三个方程求解。<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-61.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-62.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="epDTg"></a></p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>根据前面的求出摄像机内参矩阵后，就可以根据摄像机几何来获取像素点和三维点的关系，然后根据场景平面方向n来重建三维场景。<br>缺点是：场景的实际比例无法恢复，需要手动选择影消点与影消线，还需要场景先验信息（点对应关系，线、面几何信息等）<br><a name="Z6Nsa"></a></p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>01:16:00.知道法向量和影消线的关系，影消点和直线的方向后，然后通过取三垂直的面来计算摄像机的内参矩阵，在两个假设下成立。然后通过法向量和影消线的关系，已知影消线就可求平面法向量，然后通过p&#x3D;MP，获得三维点就可以三维重构了吗？期待评论单视图重构详细过程<br>推荐阅读博客：<a href="https://blog.csdn.net/Nismilesucc/article/details/121056910">单视图测量</a><br><a name="VwLVo"></a></p><h2 id="Harris角点"><a href="#Harris角点" class="headerlink" title="Harris角点"></a>Harris角点</h2><p><a href="https://www.bilibili.com/video/BV1nz4y197Qv">视频地址</a><br><a name="Rx6wg"></a></p><h3 id="1-uv与Euv的关系"><a href="#1-uv与Euv的关系" class="headerlink" title="1. uv与Euv的关系"></a>1. uv与Euv的关系</h3><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-63.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>通过观察uv的变化进而观察E(u, v)的变化，从而发现是不是角点，但是此处不方便，都需要经过I来计算，下面通过泰勒二阶展开，简化运算<br><a name="NpI6o"></a></p><h3 id="2-泰勒展开"><a href="#2-泰勒展开" class="headerlink" title="2. 泰勒展开"></a>2. 泰勒展开</h3><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-64.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>得到M与Euv的关系，进而只需要分析M矩阵<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-65.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="dKqDb"></a></p><h3 id="M矩阵对变化程度的关系"><a href="#M矩阵对变化程度的关系" class="headerlink" title="M矩阵对变化程度的关系"></a>M矩阵对变化程度的关系</h3><p>R是旋转矩阵使其变为水平椭圆， λ是方向变化剧烈程度，其值越大（λ1，λ2）则变化越快<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-66.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-67.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="NR12n"></a></p><h3 id="3-更进一步转化"><a href="#3-更进一步转化" class="headerlink" title="3. 更进一步转化"></a>3. 更进一步转化</h3><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-68.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="BkiH2"></a></p><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-69.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></p><ul><li>Partially invariant to affine intensity change  </li><li>Corner location is covariant w.r.t. translation  </li><li>Corner location is covariant w.r.t. rotation  </li><li>Corner location is not covariant to scaling!<br><a name="AVnWo"></a></li></ul><h2 id="SIFT特征"><a href="#SIFT特征" class="headerlink" title="SIFT特征"></a>SIFT特征</h2><p><a name="pRCYJ"></a></p><h3 id="Scale-selection"><a href="#Scale-selection" class="headerlink" title="Scale selection"></a>Scale selection</h3><p>Spatial selection: the magnitude of the Laplacian response will achieve <strong>a maximum at the center of the blob</strong>, provided the scale of the Laplacian is “<strong>matched</strong>” to the scale of the blob<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-70.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>The response of a derivative of Gaussian filter to a perfect step **edge decreases as σ increases **<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-71.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>To keep response the same (scale-invariant), must <strong>multiply Gaussian derivative by σ，</strong>固定为1&#x2F;√2Π<br>Laplacian is the second Gaussian derivative, so it **must be multiplied by σ2 **<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-72.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="hDlGR"></a></p><h4 id="Blob-detection-in-2D"><a href="#Blob-detection-in-2D" class="headerlink" title="Blob detection in 2D"></a>Blob detection in 2D</h4><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-73.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>前面听完一遍没听懂，可以去26:30min<br><a name="lm8Lh"></a></p><h4 id="Characteristic-scale-尺度特性"><a href="#Characteristic-scale-尺度特性" class="headerlink" title="Characteristic scale 尺度特性"></a>Characteristic scale 尺度特性</h4><p>找到对应核后，就可以在图中画出对应圆圈，r&#x3D;√2Πσ<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-74.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="l5g8s"></a></p><h4 id="Scale-space-blob-detector"><a href="#Scale-space-blob-detector" class="headerlink" title="Scale-space blob detector"></a>Scale-space blob detector</h4><p>三个尺度为一组进行判断，只有尺度变化σ最大的那个点并且在3<em>3</em>3-1个点内是尺度变化σ最大的，才输出圆<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-75.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="vovnz"></a></p><h3 id="SIFT，更高效的做法"><a href="#SIFT，更高效的做法" class="headerlink" title="SIFT，更高效的做法"></a>SIFT，更高效的做法</h3><p>原先用拉普拉斯太耗时，图片越大计算量越大<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-76.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-77.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>下图听不懂的话继续往后听，在老师问大家的时候 回复3后面的时间讲的很清晰 1:09:20<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-78.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></p><ol><li>首先DoG近似于拉普拉斯算子，它利用差分来逼近，所以通过构造DoG减少运算量</li><li>为了输出一个尺度空间，需要三个DoG结果，因此图中只能输出两个尺度空间k、k2（有可能会因为nms而减少，暂不考虑）<ol><li><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-79.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></li><li>同理：  <img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-80.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><ol><li>这里因为下采样了，为了获得原图的圆半径大小，所以乘以2 [1:12:10]</li></ol></li></ol></li><li>为了使其输出的尺度空间可以连续，即映射到坐标轴上是一条直线，从而根据σ推出半径r，进而比较最大值出现在那个尺度空间内，为了完成上述的<a href="#UlNnH">Characteristic scale 尺度特性</a>。<ol><li>怎么连续呢，既让$k&#x3D;2^{1&#x2F;s}$(s是输出的尺度空间个数)，当s&#x3D;2时，$k\sigma , k^2\sigma ,2k\sigma ,2k^2\sigma &#x3D; \sqrt{ 2} \sigma,2\sigma,2\sqrt{ 2} \sigma,4 \sigma$,以√2倍的速率稳定增加，形成等比序列</li></ol></li><li>根据s可得DoG需要S+2层，高斯响应需要S+3层，然后计算各个k,k2,k3即可</li><li>下采样的层是通过前一个采样层的倒数第三层得到，因为第三层（第3条.a小点）是$k^2\sigma &#x3D; 2\sigma$，而下采样第一层是$\sigma$,相差两倍。</li><li>有了下采样层就可以减少计算量了，因为像素点变少了<br><a name="g2xuV"></a></li></ol><h3 id="真实应用的改进"><a href="#真实应用的改进" class="headerlink" title="真实应用的改进"></a>真实应用的改进</h3><p><a name="Tlrbn"></a></p><h4 id="解决-affine-covariance"><a href="#解决-affine-covariance" class="headerlink" title="解决 affine covariance"></a>解决 affine covariance</h4><p>利用M矩阵调整梯度大小，让小λ等于大λ ，使其$\lambda1\lambda2$一致，每次调整两个值的时候，同时修改检测圆的大小，<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-81.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="OK6lw"></a></p><h4 id="解决角度问题"><a href="#解决角度问题" class="headerlink" title="解决角度问题"></a>解决角度问题</h4><p>计算梯度方向直方图后，将其整体方向转到同一个方向，即可比较<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-82.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-83.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="S2peS"></a></p><h4 id="解决光照问题"><a href="#解决光照问题" class="headerlink" title="解决光照问题"></a>解决光照问题</h4><p><strong>将归一化后的图片计算各个局部格子的梯度方向直方图</strong>，为什么不用全局直方图是因为更细致一点，防止全局下虽然方向一致，但是局部其实不太一样。用4×4是因为精细程度适中，实验结果得出。<br><a name="uLp2j"></a></p><h4 id="匹配问题"><a href="#匹配问题" class="headerlink" title="匹配问题"></a>匹配问题</h4><p>近邻匹配<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-84.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="oQ5oK"></a></p><h2 id="识别-amp-词袋模型"><a href="#识别-amp-词袋模型" class="headerlink" title="识别&amp;词袋模型"></a>识别&amp;词袋模型</h2><p><a name="BJ9o3"></a></p><h3 id="视觉任务"><a href="#视觉任务" class="headerlink" title="视觉任务"></a>视觉任务</h3><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-85.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="MGz4J"></a></p><h4 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h4><ul><li>类别多</li><li>视觉变换大</li><li>光照</li><li>尺度</li><li>形变</li><li>遮挡</li><li>物体和环境相似  background clutter  </li><li>同个类别不同形状  intra-class variation<br><a name="aqDvU"></a></li></ul><h4 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h4><p><a name="fZSdt"></a></p><h5 id="Representation"><a href="#Representation" class="headerlink" title="Representation"></a>Representation</h5><ul><li>用局部特征来表示一个物体</li><li>特征直接放到词袋内或者存储特征的相似关系 <ul><li><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-86.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></li></ul></li><li>解决方法<ul><li>处理intra-class 变化，使用概率模型</li><li>常用方法：产生式、判别式、混合式<ul><li>产生式是利用同个物体的特征相似度</li><li>判别式是利用不同物体的特征差异性</li></ul></li></ul></li></ul><p><a name="ItqzP"></a></p><h5 id="Learning"><a href="#Learning" class="headerlink" title="Learning"></a>Learning</h5><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-87.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="ZIUgZ"></a></p><h5 id="Recognition"><a href="#Recognition" class="headerlink" title="Recognition"></a>Recognition</h5><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-88.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="Nz4FC"></a></p><h4 id="How-to-represent-an-object-category"><a href="#How-to-represent-an-object-category" class="headerlink" title="How to represent an object category;"></a>How to represent an object category;</h4><p>将图片表示成一个向量<br><a name="p1SF5"></a></p><h5 id="Bag-of-features-models"><a href="#Bag-of-features-models" class="headerlink" title="Bag-of-features models"></a>Bag-of-features models</h5><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090143-89.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"> </p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三维重建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习</title>
      <link href="/2023/03/26/C++%E5%AD%A6%E4%B9%A0-cplusplus-learn/"/>
      <url>/2023/03/26/C++%E5%AD%A6%E4%B9%A0-cplusplus-learn/</url>
      
        <content type="html"><![CDATA[<p>source insight</p><h2 id="C-概括"><a href="#C-概括" class="headerlink" title="C++ 概括"></a>C++ 概括</h2><p>C++优点</p><ul><li>强大的封装能力：既有开发工程能力，又保留高性能</li><li>高性能：运行快，快并且占用资源少是C++的追求</li><li>低功耗：适合嵌入式</li></ul><p>C++缺点：</p><ul><li>语法复杂，细节多</li><li>需要好的规范和范式</li></ul><h2 id="C-基础语法"><a href="#C-基础语法" class="headerlink" title="C++ 基础语法"></a>C++ 基础语法</h2><h3 id="编程语言层次"><a href="#编程语言层次" class="headerlink" title="编程语言层次"></a>编程语言层次</h3><ol><li>机器语言，汇编语言</li><li>编译型语言 C++，C<ol><li><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090137.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></li></ol></li><li>解释型语言 Basic Python Java</li><li>脚本语言 bash csh</li></ol><ul><li>逐级运行效率低，更易理解</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090137-1.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>疑问，为什么64位三个字节对齐</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>定义常量的方法：</p><ul><li>#define： #define PI 3.14159<ul><li>#define MA(x) x*(x-1) </li><li>MA(1 + (a + b)) &#x3D; 1+(a+b)*(1+(a+b)-1)</li></ul></li><li>const：const double PI &#x3D; 3.14159 （推荐）</li></ul><p>整数常量前缀：0x 十六进制、0 八进制、0b<br>整数常量后缀：u(unsigned)、l(long)、可组合使用，大小写任意<br>字符常量：单引号括起来，用L（必须大写）表示宽字符常量</p><h2 id="运算符与表达式"><a href="#运算符与表达式" class="headerlink" title="运算符与表达式"></a>运算符与表达式</h2><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>A &#x3D;&#x3D; B 其值为bool类型 而直接判断为1为int类型，注意空间大小</p><h3 id="杂项运算符"><a href="#杂项运算符" class="headerlink" title="杂项运算符"></a>杂项运算符</h3><p>，：顺序执行一系列运算后，取最后一个表达式的值（int o &#x3D; a,b,c）</p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>正数原补反码一致<br>负数</p><ul><li>反码是原码除符号位取反，补码&#x3D;反码+1，反码&#x3D;补码-1</li><li>二进制to补码：$B 2 T_{w}(\vec{x}) \stackrel{.}{&#x3D;} x_{w-1} 2^{w-1}+\sum_{i&#x3D;0}^{w-2} x_{i} 2^{i}$</li></ul><p><a href="https://bbs.huaweicloud.com/blogs/280855">一文搞清二进制补码</a></p><h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>一个字在内存中如何以byte存放</p><ul><li>大端法：大多数IBM机器、网络传输，正序存放 8f ff ff ff</li><li>小端法：Intel兼容机，逆序存放，但字节内正序 ff ff ff 8f</li></ul><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h2 id="C陷阱和C-改进"><a href="#C陷阱和C-改进" class="headerlink" title="C陷阱和C++改进"></a>C陷阱和C++改进</h2><h3 id="char语法陷阱"><a href="#char语法陷阱" class="headerlink" title="char语法陷阱"></a>char语法陷阱</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c1 = <span class="string">&#x27;yes&#x27;</span>; <span class="comment">// 截断：1.保留第一个字符 2.保留第二个字符</span></span><br><span class="line">    std::cout &lt;&lt; c1 &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// char* 32bi机器占4位，64占8位，为了搜索整个地址空间</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* s1 = <span class="string">&quot;/&quot;</span>; <span class="comment">// ==&gt; &#x27;/&#x27;&#x27;\0&#x27;</span></span><br><span class="line">    <span class="comment">// const char* s2 = &#x27;/&#x27;; 字符常量-&gt;char* 类型不匹配</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* s2 = &amp;c1;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// C++ 改进， string 在namespace std中</span></span><br><span class="line"><span class="function">std::string <span class="title">s1</span><span class="params">(<span class="number">3</span>, <span class="string">&#x27;yes&#x27;</span>)</span></span>;  <span class="comment">// s</span></span><br><span class="line"><span class="function">std::string <span class="title">s2</span><span class="params">(<span class="string">&quot;yes&quot;</span>)</span></span>;   <span class="comment">// yes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组退化陷阱"><a href="#数组退化陷阱" class="headerlink" title="数组退化陷阱"></a>数组退化陷阱</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// double average1(int arr[10], int len) &#123;</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">average1</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span> </span>&#123;  <span class="comment">// C：数组退化成指针</span></span><br><span class="line"><span class="comment">// 传递char数组可以通过计算到&#x27;\0&#x27;的长度来不借助len</span></span><br><span class="line"><span class="type">double</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 形参arr[10]变为int指针,arr[0]为int类型 =&gt; len = 4/4 = 1</span></span><br><span class="line"><span class="comment">// int len = sizeof(arr) / sizeof(arr[0]); </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">result += arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result / len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C++ 改进</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">average3</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> result = <span class="number">0</span>;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// auto it = v.begin();</span></span><br><span class="line"><span class="keyword">for</span> (; it != v.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">result += *it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result / v.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">average2DV</span><span class="params">(std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;&amp; vv)</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> result = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; vv.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">0</span>; j &lt; vv[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">result += vv[i][j];</span><br><span class="line">size += <span class="number">1</span>;</span><br><span class="line">std::cout &lt;&lt; (vv[i][j])+<span class="string">&quot; &quot;</span>;  <span class="comment">// +&#x27; &#x27;自动变为int</span></span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result / size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>,<span class="number">50</span> &#125;;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; average1(arr, len) &lt;&lt; std::endl;</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vt&#123; <span class="number">12</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span> &#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">average3</span>(vt) &lt;&lt; std::endl;</span><br><span class="line">std::vector&lt; std::vector&lt;<span class="type">int</span>&gt;&gt; vv&#123;<span class="number">8</span>,std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">12</span>, <span class="number">3</span>) &#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">average2DV</span>(vv);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移位问题"><a href="#移位问题" class="headerlink" title="移位问题"></a>移位问题</h3><p>问题：<br>逻辑右移还是算数右移  -&gt; 右移只对无符号数<br>移位操作位数的限制 -&gt; 移位数大于0， 小于位数</p><ul><li>C中需要考虑整数移位上下文情况（有无符号数，类型占字节数）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> a1 = <span class="number">0x63</span>;  <span class="comment">// 0110 0011</span></span><br><span class="line">a1 = (a1 &gt;&gt; <span class="number">4</span>);  <span class="comment">// 0000 0110  逻辑右移</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%x\n&quot;</span>, a1);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a2 = <span class="number">0x95</span>;  <span class="comment">// 1001 0101</span></span><br><span class="line">a2 = (a2 &gt;&gt; <span class="number">4</span>);  <span class="comment">// 1111 1001  算法右移</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%x\n&quot;</span>, a2);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a3 = <span class="number">0x95</span>;  <span class="comment">// 1001 0101  C建议先转无符号再右移</span></span><br><span class="line">a3 = (a3 &gt;&gt; <span class="number">4</span>);  <span class="comment">// 0000 1001  逻辑右移</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%x\n&quot;</span>, a3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//const unsigned char priv = 0xff;</span></span><br><span class="line"><span class="comment">//const unsigned char P_BACKUP = (1 &lt;&lt; 7);</span></span><br><span class="line"><span class="comment">//const unsigned char P_ADMIN = (1 &lt;&lt; 8);  // 超过char位数-&gt; =0</span></span><br><span class="line"><span class="comment">//// 判断用户权限的技巧</span></span><br><span class="line"><span class="comment">//if (priv &amp; P_BACKUP) cout &lt;&lt; &quot;BACKUP&quot; &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ 改进</span></span><br><span class="line">bitset&lt;10&gt; priv = <span class="number">0xff</span>;</span><br><span class="line">bitset&lt;10&gt;  P_BACKUP = (<span class="number">1</span> &lt;&lt; <span class="number">6</span>);</span><br><span class="line">bitset&lt;10&gt;  P_ADMIN = (<span class="number">1</span> &lt;&lt; <span class="number">7</span>);  <span class="comment">// 超过char位数-&gt; =0</span></span><br><span class="line"><span class="comment">// 判断用户权限的技巧</span></span><br><span class="line"><span class="keyword">if</span> ((priv &amp; P_BACKUP) == P_BACKUP) cout &lt;&lt; <span class="string">&quot;BACKUP&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="类型转换问题"><a href="#类型转换问题" class="headerlink" title="类型转换问题"></a>类型转换问题</h3><p>C缺陷：隐式转换问题（sizeof(unsigned long long) 跟int比较，int转换为unsigned int）、double除法问题<br>C++改进：static_cast、const_cast、dynamic_cast、reinterpret_cast，建议尽量少使用转换，多长啊</p><h3 id="溢出问题"><a href="#溢出问题" class="headerlink" title="溢出问题"></a>溢出问题</h3><p>C整数固定为int所占字节，溢出会有问题<br>C++：使用boost库的cpp_int</p><h3 id="字符串问题"><a href="#字符串问题" class="headerlink" title="字符串问题"></a>字符串问题</h3><p>C 以’\0’结尾，遇到即停止，忽视其后面的值，运行效率低，只能以’\0’表示字符串结束<br>C++：string库（仍保留’\0’）、redis库（用多个结构体优化存储空间，并用len防止’\0’问题）<br>字符串比较 &gt;&lt; 比较的是首地址大小</p><h3 id="头文件顺序"><a href="#头文件顺序" class="headerlink" title="头文件顺序"></a>头文件顺序</h3><ul><li>系统的头文件要放在最前面；</li><li>其次是语言相关的；</li><li>然后比较古老的第三方库头文件；</li><li>比较新的第三方库头文件；</li><li>最后才是自定义的头文件。</li></ul><h2 id="基础容器"><a href="#基础容器" class="headerlink" title="基础容器"></a>基础容器</h2><h3 id="数组（差一错误）"><a href="#数组（差一错误）" class="headerlink" title="数组（差一错误）"></a>数组（差一错误）</h3><ul><li>off-by-one error<ul><li>解决思路：先考虑简单特例，然后外推结果；仔细计算边界</li><li>判断范围时采取左闭右开，使其相减为元素个数 for (int i &#x3D;0; i&lt;10; i++)</li><li><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090137-2.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></li></ul></li></ul><p><a href="https://blog.csdn.net/caomiao2006/article/details/7401833">数组的下标访问和指针访问方式效率分析</a><br>二维数组访问时的原则：尽可能满足空间局部性</p><ul><li>在一个小的时间窗口内，访问的变量地址越接近越好，执行速度越快</li><li>一般将最长的循环放最内层，最短的放最外层，以减少CPU跨切循环层的次数</li></ul><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>表示Unicode字符集：</p><ul><li>UTF-8：1byte表示字符，兼容ASCII码；特点是存储效率高，变长（不方便内部随机访问），无字节序问题（作为外部编码，供其他平台使用Linux）<ul><li>微软平台下又细分为UTF-8-BOM，二进制首位为EF BB BF，可能在其他平台有问题，可以删去首位来适配</li></ul></li><li>UTF-16：分为UTF-16BD(big endian)、UTF-16LD(little endian)；特点是定长（方便内部随机访问），有<a href="#UlvJH">字节序</a>问题。<ul><li>BD文件的二进制首位为FE FF、LD为FF FE（正序）</li></ul></li><li>UTF-32：分为UTF-32BD、UTF-32LD；特点同上</li></ul><p>字符串的指针表示方法</p><ul><li>char[] 和 char*的区别：<ol><li>char[] 地址不可变 其内的值可变</li><li>char* 地址可变，其内的值取决于所指存储区域是否可变</li></ol></li></ul><h4 id="常用函数安全问题"><a href="#常用函数安全问题" class="headerlink" title="常用函数安全问题"></a>常用函数安全问题</h4><ul><li>strlen、strcpy等没有对边界检查容易导致缓冲区溢出，修改一些值</li><li>修改为strlen_s、strcpy_s等函数</li><li>调试时加入_CRT_SECURE_NO_WARNINGS</li></ul><h3 id="String-和-char"><a href="#String-和-char" class="headerlink" title="String 和 char*"></a>String 和 char*</h3><p>char* &#x2F; char[] ：</p><ul><li>strcpy_s 拷贝</li><li>strlen 字符串长度</li><li>strcat 拼接</li><li>strcmp 比较ASCII码</li></ul><p>String：</p><ul><li>&#x3D;</li><li>str.size() \ str.length()</li><li>+&#x3D;</li><li>&#x3D;&#x3D; </li><li>str.capacity() 容量，自动扩容</li></ul><p>相比来说String 性能不是特别好</p><h2 id="C-指针"><a href="#C-指针" class="headerlink" title="C++指针"></a>C++指针</h2><p>指针占用空间由操作系统位数决定，因为要指向所有地址</p><h3 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h3><p>左值为编译器为其单独分配一块存储空间，可以取其地址。可以放在任意侧赋值运算符</p><ul><li>函数或数据成员的名字</li></ul><p>右值为数据本身，不能取其地址。只能放在赋值运算符右侧。</p><ul><li>没有标识符(变量名)，不可以&amp;取地址的表达式，一般称为“临时对象”。</li></ul><h3 id="指针分类"><a href="#指针分类" class="headerlink" title="指针分类"></a>指针分类</h3><h4 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h4><p>array of pointers：</p><ul><li>int* a[4]，包含四个指针的a数组</li><li>输出结果：*(a[3])</li></ul><p>a pointer to an array：</p><ul><li>int (*a)[4]，指向一个包含四个值的数组，其中4要与数组个数匹配</li><li>输出结果：(*a)[3] -&gt; array[3]  &lt;&#x3D;&gt; *(array+3)  &lt;&#x3D;&gt; array[3]</li><li>同样的<ul><li>int *a &#x3D; array</li><li>输出结果：*(a+3)</li></ul></li></ul><h4 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h4><p>const修饰的部分为不可修改内容，其修饰的部分看左侧最近的部分，如果左侧没有，则看右侧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> MAX_LEN = <span class="number">11</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> strHelloworld[] = &#123; <span class="string">&quot;helloworld&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">// 与strHelloWorld变量共享内存</span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span> * pStr1 = <span class="string">&quot;helloworld&quot;</span>;       <span class="comment">// const char* 不能修改指向的char内容</span></span><br><span class="line">    <span class="comment">// 导致此处赋值后使得pStr1指向的空间可被修改，不能只读</span></span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> pStr2 = strHelloworld;<span class="comment">// 不能修改指针值</span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span>* <span class="type">const</span> pStr3 = <span class="string">&quot;helloworld&quot;</span>;  <span class="comment">// const char* const 不能修改内容和指针</span></span><br><span class="line">pStr1 = strHelloworld;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pStr2 = strHelloworld;              // pStr2不可改</span></span><br><span class="line"><span class="comment">//pStr3 = strHelloworld;              // pStr3不可改</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> len = <span class="built_in">strnlen_s</span>(pStr2, MAX_LEN);</span><br><span class="line">cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> index = <span class="number">0</span>; index &lt; len; ++index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//pStr1[index] += 1;                // pStr1里的值不可改</span></span><br><span class="line">pStr2[index] += <span class="number">1</span>;</span><br><span class="line"><span class="comment">//pStr3[index] += 1;                // pStr3里的值不可改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span>* b = &amp;a;</span><br><span class="line"><span class="type">int</span>** c = &amp;b;</span><br><span class="line"><span class="comment">// *有从右向左的结合性，不清楚优先级就用括号</span></span><br><span class="line">*(*c) = *(b) = a = <span class="number">12</span></span><br></pre></td></tr></table></figure><h4 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h4><p>未初始化的指针</p><ul><li>可能导致无法定位错误</li><li>用指针进行间接访问时，确保访问的值已被初始化赋值</li></ul><p>NULL指针 </p><ul><li>初始化指针，使其无地址</li><li>对指针进行间接引用时，最好判断指针是否NULL</li><li>不用，没有初始化，超出范围时，使其NULL</li></ul><p>野指针分类</p><ul><li>指针变量没有初始化</li><li>已经释放不用的指针没有置NULL</li><li>指针操作超越了变量的作用范围，指向不确定的空间</li></ul><h3 id="指针基本操作"><a href="#指针基本操作" class="headerlink" title="指针基本操作"></a>指针基本操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span>* cp = &amp;ch;</span><br><span class="line"><span class="comment">// ++,--操作符</span></span><br><span class="line"><span class="type">char</span>* cp2 = ++cp;  </span><br><span class="line"><span class="type">char</span>* cp3 = cp++;</span><br><span class="line"><span class="type">char</span>* cp4 = --cp;</span><br><span class="line"><span class="type">char</span>* cp5 = cp--;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ++ 左值</span></span><br><span class="line"><span class="comment">//++cp2 = 97;</span></span><br><span class="line"><span class="comment">//cp2++ = 97;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// *++, ++*</span></span><br><span class="line">*++cp2 = <span class="number">98</span>; <span class="comment">// cp2地址加1后赋值</span></span><br><span class="line"><span class="type">char</span> <span class="variable">ch3</span> <span class="operator">=</span> *++cp2;  <span class="comment">// cp2地址加1后将引用的值给左值</span></span><br><span class="line">*cp2++ = <span class="number">98</span>;  <span class="comment">// 将cp2指向的空间赋值后地址加1</span></span><br><span class="line"><span class="type">char</span> <span class="variable">ch4</span> <span class="operator">=</span> *cp2++;  <span class="comment">// 将cp引用的值给左值后地址加1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ++++, ----操作符等</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">2</span>, c, d;</span><br><span class="line"><span class="comment">//c = a++b;                  // error</span></span><br><span class="line">c = a++ + b;  <span class="comment">// 贪心法</span></span><br><span class="line"><span class="comment">//d = a++++b;             // error</span></span><br><span class="line"><span class="type">char</span> <span class="variable">ch5</span> <span class="operator">=</span> ++*++cp; <span class="comment">// 1.先cp地址+1, 2.得到其引用的值, 3.值+1, 4.赋给左值</span></span><br></pre></td></tr></table></figure><p><a href="https://www.iteye.com/blog/hzdiy-736816">delete and delete[]</a>、删除指针后并不会置为nullptr<br>对于像 int&#x2F;char&#x2F;long&#x2F;int*&#x2F;struct 等等简单数据类型，由于对象没有 destructor，所以用 delete 和 delete [] 是一样的！但是如果是C++ 对象数组就不同了！</p><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12600461/1676602885720-04081f99-124e-471a-b4c2-ae6ad1b73d69.png#averageHue=%23fbd26b&clientId=u4e1a1f95-50a9-4&from=paste&height=439&id=uacc70f9e&name=image.png&originHeight=439&originWidth=453&originalType=binary&ratio=1&rotation=0&showTitle=false&size=67840&status=done&style=none&taskId=uf57f9d7d-4d1e-4042-9966-df9a6ba186e&title=&width=453" alt="image.png"></p><ul><li>stack：由程序分配地址</li><li>heap：由程序员分配地址 new&#x2F;delete</li><li>heap和bss之间是常量区</li><li>bss：未初始化区</li><li>gvap：初始化区</li><li>text：代码、函数。。。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;                                 <span class="comment">// (GVAR)全局初始化区 </span></span><br><span class="line"><span class="type">int</span>* p1;                                   <span class="comment">// (bss)全局未初始化区 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>                                 <span class="comment">// (text)代码区</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> b=<span class="number">1</span>;                               <span class="comment">// (stack)栈区变量 32位/64位地址递减/递增 栈区初始化值cc</span></span><br><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;abc&quot;</span>;                      <span class="comment">// (stack)栈区变量</span></span><br><span class="line"><span class="type">int</span>*p2=<span class="literal">NULL</span>;                           <span class="comment">// (stack)栈区变量</span></span><br><span class="line"><span class="type">char</span> *p3 = <span class="string">&quot;123456&quot;</span>;                   <span class="comment">// 123456\0在常量区, p3在(stack)栈区</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> c = <span class="number">0</span>;                      <span class="comment">// (GVAR)全局(静态)初始化区  </span></span><br><span class="line">p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);                      <span class="comment">// (heap)堆区变量 32位/64位地址递增 堆区初始化值cd</span></span><br><span class="line">p2 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>);                      <span class="comment">// (heap)堆区变量</span></span><br><span class="line"><span class="type">char</span>* p4 = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">7</span>];                <span class="comment">// (heap)堆区变量 </span></span><br><span class="line"><span class="built_in">strcpy_s</span>(p4, <span class="number">7</span>, <span class="string">&quot;123456&quot;</span>);             <span class="comment">// (text)代码区</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                              <span class="comment">// (text)代码区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="C-智能指针"><a href="#C-智能指针" class="headerlink" title="C++智能指针"></a>C++智能指针</h3><p>auto_ptr:</p><ul><li>C++17 废弃</li><li>会自动删除指针以及指向的对象，会产生所有权转移现象</li></ul><p>unique_ptr:</p><ul><li>专属所有权，unique_ptr管理的内存，只能被一个指针持有，不支持复制</li><li>该指针禁止复制，因此用是std::move()语句进行所有权转移</li><li>离开作用域后，自动释放指针和数据</li></ul><p><a href="https://stackoverflow.com/a/20895705">share_ptr</a> &#x2F; weak_ptr：</p><ul><li>通过一个引用计数共享对象，当计数位0时，调用析构函数</li><li>会带来额外的存储开 销</li><li>weak_ptr用于防止循环引用</li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>一个特殊的指针，可以看作是变量的别名，但会同时修改变量的值，且不可更换指针对象<br>有了指针为什么还要引用？为了支持函数运算符重载<br>有了引用为什么还用指针？为了兼容C<br>函数传参说明：</p><ul><li>对内置基础类型（如int，double）而言，函数传递时pass by value更高效，直接传值而不是指针&#x2F;引用</li><li>对面向对象中的自定义类型而言，传递时pass by reference to const更高效，因为防止传递大数据而使用地址占用空间更小，const为了防止无意的修改</li></ul><h2 id="C-基础语法-1"><a href="#C-基础语法-1" class="headerlink" title="C++基础语法"></a>C++基础语法</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>if将命中率高（更容易判true&#x2F;false）的条件放首位，使得判断条件更快<br>与switch比较<br>使用场景：</p><ul><li>switch只支持常量值固定相等的分支判断</li><li>if可以判断区间</li><li>switch是if的特集</li></ul><p>性能比较：</p><ul><li>分支较少时，差别不大；分支多时，switch更快，因为是汇编是查表的形式</li><li>if多分支的开始几个分支效果高，之后效率递减；因为汇编下需要不断判断再跳转</li><li>switch所有case速度几乎一样，查表形式</li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ul><li>枚举值不可以做左值</li><li>非枚举变量不可以赋值给枚举变量，除非强转；枚举可以赋值给非枚举</li></ul><h3 id="Union-x2F-Struct"><a href="#Union-x2F-Struct" class="headerlink" title="Union &#x2F; Struct"></a>Union &#x2F; Struct</h3><p>共用体</p><ul><li>所有变量占用最大空间的变量的存储空间</li><li>大字节最后赋值会覆盖小字节内容</li><li>赋值从内存最右边赋值</li></ul><p>缺省对齐原则</p><ul><li>char 任何地址</li><li>short 偶数地址</li><li>int 4的整数倍地址</li><li>double 8的整数倍地址<ul><li>32位内存里一行四字节，变量占用空间不足会扩充到最大占用空间变量</li><li>32位，char+int&#x3D;8；8+double&#x3D;16</li><li>32位，char[5]+int &#x3D; 16；16+double&#x3D;24</li></ul></li><li>修改默认编译选项：<ul><li>visual C++：#pragma pack(n) </li><li>g++：<em>attribute</em>(aligned(n))、<em>attribute</em>(<em>packed</em>)</li></ul></li></ul><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>do while更快 while 次之 for最慢，但实际开发不重视速度的话，无所谓</p><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><ol><li>看debug运行过程</li><li>看反汇编的地址</li><li>找到debug&#x2F;.obj文件，搜搜函数名，复制【?函数名@@xx】，搜索【undname】，cmd命令 【undname 复制值】</li></ol><p>用函数指针来确定某个函数：</p><ul><li>一般形式：数据类型(*指针变量名)(参数表)</li><li>bool ProcessNum(int i, int j, int(*p)(int a, int b))   &#x2F;&#x2F; 回调函数</li></ul><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>namespace 空间名{ … }<br>注意使用using namespace std，会引入所有空间内方法，可能会导致方法名冲突</p><ul><li>建议引入特定空间内方法名，using namespace std::cout;</li><li>或直接指定该方法是该空间内，std::cout &lt;&lt;</li></ul><h3 id="函数体heck过程"><a href="#函数体heck过程" class="headerlink" title="函数体heck过程"></a>函数体heck过程</h3><p>函数调用方式：_cdecl(&#x2F;Gd) (C&#x2F;C++→高级→调用约定)</p><table><thead><tr><th>低地址</th><th>esp</th></tr></thead><tbody><tr><td>…</td><td>…</td></tr><tr><td>（地址向上递减）</td><td>ebx （栈向上增长）</td></tr><tr><td>高地址</td><td>ebp</td></tr></tbody></table><p>传参时为什么默认参数要在最右边，因为汇编时先push最右边的值（不同调用方式有差别）</p><h3 id="内联函数inline"><a href="#内联函数inline" class="headerlink" title="内联函数inline"></a>内联函数inline</h3><p>用空间换时间，复杂函数可能不会内联</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>四个基本法则：</p><ul><li>基准情形：无需递归就能解出</li><li>不断递进：每次递归都靠近基准情形</li><li>设计法则：假设所有递归都能运行</li><li>合成效益法则：不做重复性工作</li></ul><p>缺陷：</p><ul><li>空间上开辟大量栈空间</li><li>时间上大量重复运算</li></ul><p>优化：</p><ul><li>尾递归：所有递归形式的调用都出现在函数的末尾</li><li>使用循环替代</li><li>使用动态规划，空间换时间</li></ul><h2 id="C-高级语法"><a href="#C-高级语法" class="headerlink" title="C++高级语法"></a>C++高级语法</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>C++使用struct、class定义类<br>struct默认成员权限是public、class默认private</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><h4 id="临时对象"><a href="#临时对象" class="headerlink" title="临时对象"></a>临时对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main调用</span></span><br><span class="line">Complex C; C = a + b;</span><br><span class="line"><span class="comment">// 对象函数</span></span><br><span class="line">Complex Complex::<span class="keyword">operator</span>+ (<span class="type">const</span> Complex&amp; c) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建临时对象，并且会触发拷贝构造，浪费时间</span></span><br><span class="line">Complex tmp;</span><br><span class="line">tmp._real = _real + c._real;</span><br><span class="line">tmp._image = _image + c._image;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line"><span class="comment">// 直接返回创建对象</span></span><br><span class="line"><span class="comment">//return Complex(_real + c._real, _image + c._image);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>临时对象的处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 自建拷贝构造</span></span><br><span class="line">Complex::<span class="built_in">Complex</span>(<span class="type">const</span> Complex&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">_real = c._real;</span><br><span class="line">_image = c._image;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Complex::Complex(const Complex&amp; c)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 定义时赋值（下次都定义时赋值）</span></span><br><span class="line">Complex C = a + b; <span class="comment">// 并且重载符直接return对象 而不是创建临时对象</span></span><br><span class="line"><span class="comment">// 此外可节省调用默认构造函数</span></span><br></pre></td></tr></table></figure><h4 id="前置后置"><a href="#前置后置" class="headerlink" title="前置后置++"></a>前置后置++</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Complex&amp; Complex::<span class="keyword">operator</span>++ () <span class="comment">// 前置++ 效率快</span></span><br><span class="line">&#123;</span><br><span class="line">_real++;</span><br><span class="line">_image++;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Complex Complex::<span class="keyword">operator</span>++ (<span class="type">int</span>) <span class="comment">// 后置++</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//Complex tmp(*this);</span></span><br><span class="line"><span class="comment">//_real++;</span></span><br><span class="line"><span class="comment">//_image++;</span></span><br><span class="line"><span class="comment">//return tmp;</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Complex</span>(_real++, _image++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Complex &amp;x);</span><br><span class="line"><span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, Complex &amp;x);</span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Complex &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">os &lt;&lt; <span class="string">&quot;real value is  &quot;</span> &lt;&lt; x._real &lt;&lt; <span class="string">&quot;  image value is &quot;</span> &lt;&lt; x._image;</span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream&amp; is, Complex &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">is &gt;&gt; x._real &gt;&gt; x._image;</span><br><span class="line"><span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>防止缓冲区遗留数据：<br>cin.ignore(numeric_limits<a href="std::streamsize">std::streamsize</a>::max(), ‘\n’); &#x2F;&#x2F; 清空缓冲区脏数据</p><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p>文件的打开方式：</p><ul><li>ios::in 打开文件进行读（ifstream默认）</li><li>ios::out 打开文件进行写（ofstream默认ios::out | ios::trunc）</li><li>ios::ate  打开一个已有输入&#x2F;输出的文件并查找到文件尾</li><li>ios::app 打开文件如没有则创建文件，在尾部添加数据</li><li>ios::nocreate 如果文件不存在，则打开操作失败</li><li>ios::trunc 如文件存在，清楚文件原有内容</li><li>ios::binary 以二进制打开<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> bufferLen = <span class="number">2048</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CopyFile</span><span class="params">(<span class="type">const</span> string&amp; src, <span class="type">const</span> string&amp; dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 打开源文件和目标文件</span></span><br><span class="line"><span class="comment">// 源文件以二进制读的方式打开</span></span><br><span class="line"><span class="comment">// 目标文件以二进制写的方式打开</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(src.c_str(), ios::binary)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(dst.c_str(),  ios::binary)</span></span>;</span><br><span class="line"><span class="comment">// 判断文件打开是否成功，失败返回false</span></span><br><span class="line"><span class="keyword">if</span> (!in || !out)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从源文件中读取数据，写到目标文件中</span></span><br><span class="line"><span class="comment">// 通过读取源文件的EOF来判断读写是否结束</span></span><br><span class="line"><span class="type">char</span> temp[bufferLen];</span><br><span class="line"><span class="keyword">while</span> (!in.<span class="built_in">eof</span>())</span><br><span class="line">&#123;</span><br><span class="line">in.<span class="built_in">read</span>(temp, bufferLen);</span><br><span class="line">streamsize count = in.<span class="built_in">gcount</span>();</span><br><span class="line">out.<span class="built_in">write</span>(temp, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭源文件和目标文件</span></span><br><span class="line">in.<span class="built_in">close</span>();</span><br><span class="line">out.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="头文件重定义"><a href="#头文件重定义" class="headerlink" title="头文件重定义"></a>头文件重定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SOMEFILE_H_ <span class="comment">// 任意专属名称</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SOMEFILE_H_</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//末尾</span></span></span><br><span class="line"><span class="comment">// 使用宏防止同一个文件被多次包含；</span></span><br><span class="line"><span class="comment">// 优点：可移植性好；缺点：无法防止宏名重复，难以排错</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">// 使用编译器防止</span></span><br><span class="line"><span class="comment">// 优点：防止宏重复；缺点：可移植性不好</span></span><br></pre></td></tr></table></figure><h3 id="深拷贝-浅拷贝-move操作"><a href="#深拷贝-浅拷贝-move操作" class="headerlink" title="深拷贝 浅拷贝 move操作"></a>深拷贝 浅拷贝 move操作</h3><p>浅拷贝：只拷贝指针地址，C++默认拷贝构造函数与赋值运算符重载都是浅拷贝；节省空间，但会引发多次释放。<br>深拷贝：重新分配堆内存，拷贝指针指向内容。浪费空间，但不会多次释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> String &amp;other)&#123;  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.m_data) + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (m_data != <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>= (<span class="type">const</span> String &amp;other)&#123;  <span class="comment">// 赋值函数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"><span class="comment">// 释放原有的内容</span></span><br><span class="line"><span class="keyword">delete</span>[ ] m_data;</span><br><span class="line"><span class="comment">// 重新分配资源并赋值</span></span><br><span class="line">m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.m_data) + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (m_data != <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>兼有两者优点：1. 计数，2. move操作<br>move：当旧指针不用时，资源让渡给新指针，即move操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function">String <span class="title">s2A</span><span class="params">(std::move(s1))</span></span>;</span><br><span class="line">String::<span class="built_in">String</span>(String&amp;&amp; other)&#123;  <span class="comment">// 移动构造函数  &amp;&amp;右值引用</span></span><br><span class="line"><span class="keyword">if</span> (other.m_data != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="comment">// 资源让渡</span></span><br><span class="line">m_data = other.m_data;</span><br><span class="line">other.m_data = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">String s3A;</span><br><span class="line">s3A = std::<span class="built_in">move</span>(s2A);</span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(String&amp;&amp; rhs)<span class="keyword">noexcept</span>&#123;  <span class="comment">// 移动赋值运算符</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] m_data;</span><br><span class="line">m_data = rhs.m_data;</span><br><span class="line">rhs.m_data = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>&#x2F;&#x2F; 面对变化，尽可能少修改原有的逻辑，要扩充逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>  <span class="comment">// 抽象类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">Area</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;<span class="comment">// 子类方法实现不一致加上virtual 不创建对象用=0</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetColor</span><span class="params">(<span class="type">int</span> color)</span> </span>&#123; _color = color; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Area</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span>: <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Square</span>(<span class="type">double</span> len) :_len(len) &#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Square&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Area</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _len*_len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> _len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090137-3.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>所以sizeof(s1) &#x3D; 16 &#x3D; 8+4+4</p><h3 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h3><p>封装、继承、多态<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090137-4.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></p><h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">const</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DoSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Do Something&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将构造和析构函数私有化，防止外部访问</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Singleton</span>();</span><br><span class="line">~<span class="built_in">Singleton</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Singleton* This; <span class="comment">// 使用静态变量帮助解决资源的分配和释放</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Singleton.h&quot;</span></span></span><br><span class="line"><span class="comment">// 无法解析的外部符号 &quot;private: static class Singleton * Singleton::This&quot;</span></span><br><span class="line">Singleton* Singleton::This = <span class="literal">nullptr</span>; <span class="comment">// = new Singleton();</span></span><br><span class="line"><span class="function"><span class="type">const</span> Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!This)</span><br><span class="line">&#123;</span><br><span class="line">This = <span class="keyword">new</span> Singleton;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> This;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton::<span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">Singleton::~<span class="built_in">Singleton</span>()&#123;&#125;</span><br></pre></td></tr></table></figure><p><a href="https://cloud.tencent.com/developer/article/1670804">懒汉模式和恶汉模式 null&#x2F;new</a></p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者关注被观察者动态，如果被观察者动态更新，则通知观察者做出相应处理。</p><h3 id="void-、nullptr"><a href="#void-、nullptr" class="headerlink" title="void*、nullptr"></a>void*、nullptr</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL((void*)0)</span></span><br><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL</span></span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> _cplusplus</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line">  <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> NULL((void*)0)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// vc++即使定义指针为NULL，也会转成nullptr即void*</span></span><br></pre></td></tr></table></figure><h3 id="C-的类型转换"><a href="#C-的类型转换" class="headerlink" title="C++的类型转换"></a>C++的类型转换</h3><p>const_cast：用于将const转换成非const</p><ul><li>const变量传给带非const参数的函数</li></ul><p>reinterpret_cast：重新解释类型，两者内存空间必须一致，不检查指向的内容和其指针类型<br>static_cast：基本类型转换，有继承关系的类对象和类指针转换，由程序员来检查是否错误，没有动态转换的类型安全检查开销<br>dynamic_cast：只用于包含虚函数的类，用于多态中，向上向下转换时，错误则置空，增加检查开销</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>将一个类的接口或实现类转化成客户要求的另一个新功能接口，实现复用。</p><ul><li>采用多重继承的方式<ul><li>实现新功能接口</li><li>创建适配器类继承新功能接口和旧功能实现类或接口</li><li>在类中实现新功能</li><li>创建接口对象指针 指向新实现类，调用方法</li></ul></li><li>采用组合方式<ul><li>实现新功能接口</li><li>创建适配器继承接口，并在类内创建旧类对象</li><li>新功能中使用旧类对象调用旧方法</li><li>创建接口对象指针 指向新实现类，调用方法<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LegacyRectangle</span>  <span class="comment">// 旧</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">LegacyRectangle</span>(<span class="type">double</span> x1) &#123;</span><br><span class="line">_x1 = x1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LegacyDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;LegacyRectangle:: LegacyDraw()&quot;</span> &lt;&lt; _x1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> _x1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>  <span class="comment">// 新接口</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(string str)</span> </span>= <span class="number">0</span>; <span class="comment">//虚函数用于继承给子类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种适配的方式：使用多重继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RectangleAdapter</span>: <span class="keyword">public</span> Rectangle, <span class="keyword">public</span> LegacyRectangle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">RectangleAdapter</span>(<span class="type">double</span> w) : <span class="built_in">LegacyRectangle</span>(w) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;RectangleAdapter&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;RectangleAdapter::Draw()&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">LegacyDraw</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合方式的Adapter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RectangleAdapter2</span> :<span class="keyword">public</span> Rectangle </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">RectangleAdapter2</span>(<span class="type">double</span> w) :_lRect(w) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;RectangleAdapter2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;RectangleAdapter2::Draw()&quot;</span> &lt;&lt; endl;</span><br><span class="line">_lRect.<span class="built_in">LegacyDraw</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">LegacyRectangle _lRect;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="function">RectangleAdapter <span class="title">ra</span><span class="params">(x, y, w, h)</span></span>;</span><br><span class="line">Rectangle* pR = &amp;ra;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h3><p>::方法名() 调用自己的函数<br>泛型编程是一种静态期多态，通过编译器生成最直接的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;Class T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(T1 a, T2 b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(a &gt; b ? a:b);</span><br></pre></td></tr></table></figure><h2 id="进阶编程"><a href="#进阶编程" class="headerlink" title="进阶编程"></a>进阶编程</h2><h3 id="STL标准库"><a href="#STL标准库" class="headerlink" title="STL标准库"></a>STL标准库</h3><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><ul><li>序列式容器<ul><li>可排序，vector、list、deque，而stack、queue、priority_queue是容器适配器</li></ul></li><li>关联式容器<ul><li>每个数据元素由键值对组成，set，multiset，map，multimap</li><li>note：迭代器删除时，注意删除操作使得迭代器失效，iter &#x3D; .erase(iter) or iter++</li></ul></li></ul><h3 id="函数指针、仿函数模板"><a href="#函数指针、仿函数模板" class="headerlink" title="函数指针、仿函数模板"></a>函数指针、仿函数模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++仿函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SortTF</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(T <span class="type">const</span>&amp; a, T <span class="type">const</span>&amp; b)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DisplayTF</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(T <span class="type">const</span>&amp; a)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++仿函数模板</span></span><br><span class="line"><span class="type">int</span> arr4[] = &#123; <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span> &#125;;</span><br><span class="line"><span class="built_in">sort</span>(arr4, arr4 + <span class="number">5</span>, <span class="built_in">SortF</span>());</span><br><span class="line">for_each(arr4, arr4 + <span class="number">5</span>, <span class="built_in">DisplayF</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h3><p>必须提供iterator_traits的五种特性，才能和STL共同使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分别是迭代器类型、元素类型、距离类型、指针类型与reference类型</span></span><br><span class="line"><span class="comment">//template&lt;class Iterator&gt;</span></span><br><span class="line"><span class="comment">//struct iterator_traits</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//typedef typename Iterator::difference_type difference_type;</span></span><br><span class="line"><span class="comment">//typedef typename Iterator::value_type value_type;</span></span><br><span class="line"><span class="comment">//typedef typename Iterator::pointer pointer;</span></span><br><span class="line"><span class="comment">//typedef typename Iterator::reference reference;</span></span><br><span class="line"><span class="comment">//typedef typename Iterator::iterator_category iterator_category;</span></span><br><span class="line"><span class="comment">//&#125;；</span></span><br></pre></td></tr></table></figure><h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><ul><li>stack：先进后出，底层是deque</li><li>queue：先进先出，底层deque</li><li>priority_queue：进行堆排序，底层是vector或deque</li></ul><h3 id="空间适配器"><a href="#空间适配器" class="headerlink" title="空间适配器"></a>空间适配器</h3><h3 id="boost库"><a href="#boost库" class="headerlink" title="boost库"></a>boost库</h3><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>加锁应尽可能粒度最小化</p><h2 id="Linux编程"><a href="#Linux编程" class="headerlink" title="Linux编程"></a>Linux编程</h2><h3 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h3><p><a href="https://www.gnu.org/software/make/manual/">https://www.gnu.org/software/make/manual/</a><br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090137-5.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></p><ul><li><p><strong>Makefile基本规则</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标： 依赖</span></span><br><span class="line"><span class="comment">// 命令 (前面有个tab)</span></span><br><span class="line">main: test.o main.o</span><br><span class="line">    g++ test.o main.o -o main</span><br><span class="line">test.o: test.cpp</span><br><span class="line">    g++ -c test.cpp -o test.o</span><br><span class="line">main.o: main.cpp</span><br><span class="line">    g++ -c main.cpp -o main.o</span><br></pre></td></tr></table></figure></li><li><p><strong>Makefile的简化规则</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量定义：变量 = 字符串</span></span><br><span class="line"><span class="comment">// 变量使用：$(变量名)</span></span><br><span class="line">TARGET = main</span><br><span class="line">OBJS = test.o main.o</span><br><span class="line">$(TARGET): $(OBJS)</span><br><span class="line">    g++ $(OBJS) -o $(TARGET)</span><br><span class="line">test.o: test.cpp</span><br><span class="line">main.o: main.cpp</span><br><span class="line">    </span><br><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">rm $(TARGET) $(OBJS)</span><br><span class="line"><span class="comment">// 不生成目标文件的命令最好使用.PHONY 使其为假想目标</span></span><br><span class="line"><span class="comment">// 扩展用法  /usr/local/bin/系统环境变量（查看echo $path）</span></span><br><span class="line">install:</span><br><span class="line">cp ./main /usr/local/bin/mainTest</span><br><span class="line">uninstall:</span><br><span class="line">rm /usr/local/bin/mainTest</span><br></pre></td></tr></table></figure><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090137-6.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></p></li><li><p><strong>Makefile动态库</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TARGET = main // main 和 .o的区别 试试main.o or test</span><br><span class="line">OBJS = test.o</span><br><span class="line">LIB = libtest.so</span><br><span class="line">CXXFLAGS = -c -fPIC</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(LIB)</span> main.o</span><br><span class="line"><span class="variable">$(CXX)</span> main.o -o <span class="variable">$(TARGET)</span> -L. -ltest -Wl,-rpath ./</span><br><span class="line"><span class="variable">$(LIB)</span>:<span class="variable">$(OBJS)</span></span><br><span class="line"><span class="variable">$(CXX)</span> -shared <span class="variable">$(OBJS)</span> -o <span class="variable">$(LIB)</span></span><br><span class="line"><span class="variable">$(OBJS)</span>:test.cpp</span><br><span class="line"><span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> test.cpp -o <span class="variable">$(OBJS)</span></span><br><span class="line"><span class="section">main.o: main.cpp</span></span><br><span class="line"><span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> main.cpp -o main.o</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure></li><li><p>自动变量和模式变量</p></li></ul><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090137-7.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TARGET = main</span><br><span class="line">OBJS = test.o</span><br><span class="line">LIB = libtest.so</span><br><span class="line">CXXFLAGS = -c -fPIC</span><br><span class="line">LDFLAGS = -L. -ltest -Wl,-rpath $(@D)</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: main.o <span class="variable">$(LIB)</span> // 第一个依赖main.o</span><br><span class="line"><span class="variable">$(CXX)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="variable">$(LDFLAGS)</span></span><br><span class="line"><span class="variable">$(LIB)</span>:<span class="variable">$(OBJS)</span></span><br><span class="line"><span class="variable">$(CXX)</span> -shared <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">%.o:%.cpp</span></span><br><span class="line"><span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line"><span class="variable">$(RM)</span> <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span> <span class="variable">$(LIB)</span> main.o</span><br></pre></td></tr></table></figure><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><p>在qt项目下新建bat文件，输入qmake -tp vc 项目名.pro 即可生成sln文件</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090137-8.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230326090137-9.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python编程 遇到的问题</title>
      <link href="/2023/03/11/Python%E7%BC%96%E7%A8%8B%20%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98-python-problem/"/>
      <url>/2023/03/11/Python%E7%BC%96%E7%A8%8B%20%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98-python-problem/</url>
      
        <content type="html"><![CDATA[<p>持续更新中</p><h2 id="imshow：qt-qpa-plugin-could-not-find-the-Qt-platform-plugin-“xcb”-in-“”"><a href="#imshow：qt-qpa-plugin-could-not-find-the-Qt-platform-plugin-“xcb”-in-“”" class="headerlink" title="imshow：qt.qpa.plugin: could not find the Qt platform plugin “xcb” in “”"></a>imshow：qt.qpa.plugin: could not find the Qt platform plugin “xcb” in “”</h2><p>这个问题在我用python创建的虚拟环境后碰到，无法找到解决办法，只能用conda创建虚拟环境，然后opencv可以显示图片了</p><blockquote><p> pip  install  -i  <a href="https://pypi.doubanio.com/simple/">https://pypi.doubanio.com/simple/</a>  –trusted-host pypi.doubanio.com xxx-package-name</p></blockquote><h2 id="Linux-pycharm-opencv不显示代码提示"><a href="#Linux-pycharm-opencv不显示代码提示" class="headerlink" title="Linux pycharm opencv不显示代码提示"></a>Linux pycharm opencv不显示代码提示</h2><p>参考：<a href="https://blog.csdn.net/fangzhihuaa/article/details/113903689">链接</a><br>Linux中anaconda地址是：anaconda3安装路径&#x2F;envs&#x2F;虚拟环境名&#x2F;lib&#x2F;python版本号&#x2F;site-packages&#x2F;cv2</p><h2 id="ssize-empty-in-function-resize"><a href="#ssize-empty-in-function-resize" class="headerlink" title="!ssize.empty() in function resize"></a>!ssize.empty() in function resize</h2><p>顾名思义，某个地方调用opencv库的resize时，传入空值，导致该错误，仔细检查传入值的数据是否为0或者None即可。<br>但是给的错误信息有点误导意思，因为我用的是另一个版本的opencv，还以为是版本不一致导致的错误。如下，提示的是OpenCV3.4.15版本<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311202709.jpg?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="da3de5c330013051f9be766648ade55.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 问题集锦 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小目标检测综述-半成品</title>
      <link href="/2023/03/11/%E5%B0%8F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0-%E5%8D%8A%E6%88%90%E5%93%81-small-target-detection/"/>
      <url>/2023/03/11/%E5%B0%8F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0-%E5%8D%8A%E6%88%90%E5%93%81-small-target-detection/</url>
      
        <content type="html"><![CDATA[<p>因为后续转三维重建了，所以只能写到一半了，如有需要可以找我要源文件<br>参考论文：<br><a href="https://arxiv.org/abs/1905.05055">Object Detection in 20 Years: A Survey</a></p><h1 id="总言"><a href="#总言" class="headerlink" title="总言"></a>总言</h1><p>因为不是大神，所以都是摘自网络文章，如有错误欢迎评论</p><h1 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h1><h2 id="传统目标检测"><a href="#传统目标检测" class="headerlink" title="传统目标检测"></a>传统目标检测</h2><h3 id="Viola-Jones-Detector"><a href="#Viola-Jones-Detector" class="headerlink" title="Viola Jones Detector"></a>Viola Jones Detector</h3><p>论文：<a href="https://www.cs.cmu.edu/~efros/courses/LBMV07/Papers/viola-cvpr-01.pdf">Rapid Object Detection using a Boosted Cascade of Simple Features</a><br>2001年提出，基于滑动窗口的目标检测算法，通过积分图像来加速对Haar-like特征的计算，使用如下方法来加速网络计算以及提高准确率。</p><h4 id="网络架构-x2F-使用方法"><a href="#网络架构-x2F-使用方法" class="headerlink" title="网络架构&#x2F;使用方法"></a>网络架构&#x2F;使用方法</h4><ul><li>Integral image：<a href="https://codeantenna.com/a/GBSSZGRWWG">解析</a></li><li>Feature selection：使用Adaboost对候选特征筛选，找到最有代表性的一小组特征</li><li>Detection cascades<ul><li><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311202415.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></li></ul></li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ul><li>具有里程碑的意义</li></ul><p>缺点：</p><ul><li>使用的Harr-like特征较简单，稳定性较低</li><li>弱分类器采用简单的决策树，容易过拟合，对人脸的遮挡、光暗等因素处理效果不理想</li><li>鲁棒性较差</li></ul><hr><p>参考博客：<a href="https://blog.csdn.net/qq_16829085/article/details/108680639">目标检测之 Viola-Jones</a>、<a href="https://segmentfault.com/a/1190000023017586">viola jones人脸检测原理</a></p><h3 id="HOG-Detector"><a href="#HOG-Detector" class="headerlink" title="HOG Detector"></a>HOG Detector</h3><p>论文：<a href="https://lear.inrialpes.fr/people/triggs/pubs/Dalal-cvpr05.pdf">Histograms of Oriented Gradients for Human Detection</a><br>HOG（Histogram of Oriented Gridients的简写）特征检测算法，最早是由法国研究员Dalal等在CVPR-2005上提出来的，一种解决人体目标检测的图像描述子，是一种用于表征图像局部梯度方向和梯度强度分布特性的描述符。其主要思想是：在边缘具体位置未知的情况下，边缘方向的分布也可以很好的表示行人目标的外形轮廓。</p><h4 id="网络架构-x2F-使用方法-1"><a href="#网络架构-x2F-使用方法-1" class="headerlink" title="网络架构&#x2F;使用方法"></a>网络架构&#x2F;使用方法</h4><ol><li>灰度化、颜色空间归一化：Gamma校正</li><li>计算图像中每个像素的梯度值和梯度方向</li><li>将图像划分成多个pixel×pixel cells，并计算每个cell的梯度直方图，即为描述子(descriptor)<ol><li>梯度直方图的x为梯度方向的映射，y为梯度值的累加</li></ol></li><li>将num个cells归一化后合并成一个block，最后会形成多个带重叠部分的block。每个block内为cells内的向量concat<ol><li><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311202415-1.gif?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5"></li></ol></li><li>最后将所有block的向量再次串联，即HOG特征</li></ol><p>示例：<br>图像大小为：64×128, block大小为16×16， block stride为8×8，cell size为8×8，bins&#x3D;9（直方图等级数）；</p><ul><li>块个数为：((64-16)&#x2F;8+1) × ((128-16)&#x2F;8 +1) &#x3D; 105<ul><li>其中重叠部分就是因为16 &gt; 8</li><li>(64-16)&#x2F;8 计算除第一个block后还可以走多少步，然后加上第一次不动的次数+1</li></ul></li><li>每个块内cell个数； (16×16)&#x2F;(8×8)&#x3D;4</li><li>每张图特征维度：105×4×9&#x3D;3780</li></ul><p>获取到每张图的特征维度后，再用线性SVM训练分类器即可。</p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ul><li>使用contrast-normalize the local response来使得局部几何和光学形变具有不变性</li><li>容许行人有细微肢体动作，适合人体检测</li><li>分块分单元的方法，使得图像局部像素点之间的关系得到很好地表征</li></ul><p>缺点</p><ul><li>特征维度大，实时性差</li><li>很难处理遮挡问题</li><li>对噪点敏感</li></ul><hr><p>参考博客：<a href="https://blog.csdn.net/hujingshuang/article/details/47337707">【特征检测】HOG特征算法</a>、<a href="https://www.jianshu.com/p/033cfd13e613">目标检测HOG特征解读</a>、<a href="https://www.cnblogs.com/alexme/p/11361563.html">HOG 特征提取算法（实践篇）</a>、<a href="https://www.jianshu.com/p/ad673c1e601d">HOG特征</a></p><h3 id="Deformable-Part-based-Model-DPM"><a href="#Deformable-Part-based-Model-DPM" class="headerlink" title="Deformable Part-based Model(DPM)"></a>Deformable Part-based Model(DPM)</h3><p>论文：<a href="https://www.rossgirshick.info/latent/">Discriminatively trained deformable part models</a><br>由P. Felzenszwalb在2008提出，作为HOG的扩展版。DPM的设计理念是“divide and conquer”，训练时分解对象，推理时组合不同部件。DPM的本质就是<strong>弹簧形变模型。</strong><br>DPM算法采用了改进后的HOG特征，SVM分类器和滑动窗口（Sliding Windows）检测思想，针对目标的多视角问题，采用了多组件（Component）的策略，针对目标本身的形变问题，采用了基于图结构（Pictorial Structure）的部件模型策略。此外，将样本的所属的模型类别，部件模型的位置等作为潜变量（Latent Variable），采用多示例学习（Multiple-instance Learning）来自动确定。</p><h4 id="网络架构-x2F-使用方法-2"><a href="#网络架构-x2F-使用方法-2" class="headerlink" title="网络架构&#x2F;使用方法"></a>网络架构&#x2F;使用方法</h4><ul><li>经典DPM由一个root-filter和多个part-filter组成。</li><li>LatentSVM：使得不用标出part框</li><li>使用硬负样本挖掘：解决样本不平衡问题</li><li>边界框回归</li><li>context priming：利用局部信息</li><li>混合模型：学习多个模型来适应物体不同形变</li><li>图像金字塔：适应形变</li></ul><h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点</p><ul><li>运算速度快，适应物体形变，方法直观简单</li><li>Although today’s object detectors have far surpassed DPM in terms of the detection accuracy, many of them are still deeply influenced by its valuable insights</li></ul><p>缺点</p><ul><li>性能一般</li><li>无法适应大幅度旋转以及当图像中目标像素远小于root filter时无法检测</li></ul><h4 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h4><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311202415-2.jpg?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5"><br>DPM首先采用的是HOG进行特征的提取，但是又有别于HOG，DPM中，只保留了HOG中的Cell。如上图所示，假设，一个8<em>8的Cell，将该细胞单元与其对角线临域的4个细胞单元做归一化操作。<br>提取有符号的HOG梯度，0-360度将产生18个梯度向量，提取无符号的HOG梯度，0-180度将产生9个梯度向量。因此，一个8</em>8的细胞单元将会产生，（18+9）<em>4&#x3D;108 （<strong>其中的4是4个相对邻域，这里看的时候没看懂</strong>），维度有点高，Felzenszwalb大神给出了其优化思想。<br>首先，只提取无符号的HOG梯度，将会产生4</em>9&#x3D;36维特征，将其看成一个4*9的矩阵，分别将行和列分别相加，最终将生成4+9&#x3D;13个特征向量，为了进一步提高精度，将提取的18维有符号的梯度特征也加进来，这样，一共产生13+18&#x3D;<a href="https://blog.csdn.net/sysu_yuhaibao/article/details/76599926">31维梯度特征</a>（另一个解释）。实现了很好的目标检测。</p><hr><p>参考博客：<a href="https://blog.csdn.net/qq_14845119/article/details/52625426">DPM（Deformable Part Model）原理详解</a>、<a href="https://blog.csdn.net/ttransposition/article/details/12966521">DPM(Deformable Parts Model)–原理(一)</a>、<a href="https://blog.csdn.net/ttransposition/article/details/41806601">DPM目标检测算法(毕业论文节选)</a>、<a href="https://cloud.tencent.com/developer/article/1729851">多个博客的组合体</a>、<a href="https://www.zhihu.com/question/27726840">什么是latent SVM？</a>、<a href="https://zhuanlan.zhihu.com/p/41508881">DPM模型</a>、<a href="https://www.cnblogs.com/henuliulei/p/12109100.html">传统目标检测算法之DPM</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基于手工提取特征的传统目标检测算法主要有以下三个缺点：</p><ol><li>识别效果不够好，准确率不高</li><li>计算量较大，运算速度慢</li><li>可能产生多个正确识别的结果</li></ol><h2 id="深度学习检测"><a href="#深度学习检测" class="headerlink" title="深度学习检测"></a>深度学习检测</h2><h3 id="two-stage-detection"><a href="#two-stage-detection" class="headerlink" title="two-stage detection"></a>two-stage detection</h3><p>总结性博客：<a href="https://blog.csdn.net/hust_lmj/article/details/78974348">RCNN系列总结</a>、<a href="https://www.cnblogs.com/yifanrensheng/p/12846798.html">目标检测：R-CNN、SPP,Fast R-CNN、Faster R-CNN</a>、<a href="https://zhuanlan.zhihu.com/p/80856944">Faster RCNN系列算法原理</a>、<a href="https://www.citisy.site/posts/18732.html">目标检测-RCNN系列</a>、<a href="https://www.yanxishe.com/columnDetail/21514#1--%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B">小哲AI专栏文章分类索引</a><br>咱也不知道RCNN家族有多少，这里只好列举了RCNN→SPPnet→Fast RCNN→Faster RCNN→FPN→MaskRCNN→Cascade RCNN<br>另外二阶段检测所包含的这些网络如有误，欢迎评论<br>二阶段：1，先产生高质量框，2. 对框进行微调 coarse to fine<br>一阶段：一步到位</p><h4 id="RCNN（提出数据稀少的解决方案）"><a href="#RCNN（提出数据稀少的解决方案）" class="headerlink" title="RCNN（提出数据稀少的解决方案）"></a>RCNN（提出数据稀少的解决方案）</h4><p>论文：<a href="https://arxiv.org/pdf/1311.2524.pdf">Rich feature hierarchies for accurate object detection and semantic segmentation</a><br>最近几年，物体检测陷入停滞，表现最好的检测系统是复杂的将多低层级的图像特征与高层级的物体检测器环境与场景识别相结合。我们取得这个性能主要通过两个方面：第一是应用了自底向上的候选框训练的高容量的卷积神经网络进行定位和分割物体。另外一个是使用在标签数据匮乏的情况下训练大规模神经网络的一个方法。</p><h5 id="网络架构-x2F-使用方法-3"><a href="#网络架构-x2F-使用方法-3" class="headerlink" title="网络架构&#x2F;使用方法"></a>网络架构&#x2F;使用方法</h5><ol><li>目标检测：<ol><li>产生候选区域：Selective Search 选出2k个候选区域</li><li>对每个候选区域进行特征提取：CNN → 2000×4096 dim特征向量</li><li>候选区域类别判断：SVM 4096×N（20类别+1背景）+NMS</li><li>使用回归对其候选框调整：regression</li></ol></li><li>Selective Search → CNN→ SVM→ regression<img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311202415-3.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></li></ol><p>分析网络采用Hoiem等人的定位分析工具：Diagnosing error in object detectors，看到进化版分析工具：A General Toolbox for Identifying Object Detection Errors</p><h5 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h5><p>优点：</p><ul><li>使用CNN来提取特征，减少人工操作</li><li>使用迁移学习来提高性能</li><li>当带标签的训练数据不足时，先针对辅助数据集进行有监督方式的预训练，再进行特定小数据集的调优，就可以产生明显的性能提升。（迁移学习）</li></ul><p>缺点：</p><ul><li>速度慢，存在大量重复计算</li><li>训练步骤繁琐</li></ul><hr><p>参考博客：<a href="https://blog.csdn.net/v1_vivian/article/details/78599229">R-CNN论文详解（论文翻译）</a>、<a href="https://zhuanlan.zhihu.com/p/42643788">RCNN 论文阅读记录 还介绍了一些方法</a></p><h4 id="SPPnet"><a href="#SPPnet" class="headerlink" title="SPPnet"></a>SPPnet</h4><p>论文：<a href="https://arxiv.org/abs/1406.4729">Spatial Pyramid Pooling in Deep Convolutional Networks for Visual Recognition</a><br>普遍的CNN需要固定输入图片大小，原因是卷积层后的全连接层需要固定长度的输入。SPP是Bag-of-words模型的扩展，是视觉最成功的方法之一。它将图像划分为从精细到粗糙空间，并聚合其中的局部特征。</p><h5 id="网络架构-x2F-使用方法-4"><a href="#网络架构-x2F-使用方法-4" class="headerlink" title="网络架构&#x2F;使用方法"></a>网络架构&#x2F;使用方法</h5><p>网络架构：<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311202415-4.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></p><ol><li>目标检测<ol><li>提取2000个候选框</li><li>对整张图片通过CNN进行特征提取</li><li>将候选框映射到最终的feature maps上，进行空间金字塔池化，得到固定长度的特征向量</li><li>SVM分类器来检测</li></ol></li><li></li></ol><h5 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h5><p>优点：</p><ul><li>输入任意大小的图片，防止剪裁、放缩降低精度 （优化RCNN）</li><li>使用CNN共享参数后，映射候选框加速计算（优化RCNN）</li><li>可应用在许多网络上</li><li>multi-scale feature extraction 可以提高精度</li></ul><p>缺点：</p><ol><li>同R-CNN一样分开训练CNN和SVM、BB回归器，训练SVM的特征需要提前保存在磁盘需要巨大的存储空间；多段训练实现<strong>较复杂</strong></li></ol><ul><li>CNN和SVM的训练独立导致SVM的训练Loss无法更新SPP-Layer之前的卷积层参数，因此即使采用更深的CNN网络进行特征提取，也无法保证SVMs分类器的准确率一定能够提升</li><li>(1)spp layer有multi-scale的pooling，正向还好，反向传播开销大。<br>(2)sppnet后，fast-rcnn的roi pooling 本质上就是一层的spp pooling, 这篇paper表明, 运算成本更低的 roi pooling(即 single-scale spp)并不比运算开销更大的multi-scale的spp 要差。这里的一层spp 池化指的应该是只有一层池化而不是像金字塔一样有多层池化。<br>(3)粘自 <a href="https://zhuanlan.zhihu.com/p/24774302">评论</a></li></ul><hr><p>参考博客：<a href="https://blog.csdn.net/hust_lmj/article/details/78974348#t9">SPP优缺点</a>、<a href="https://cloud.tencent.com/developer/article/1441559">空间金字塔池化网络SPPNet详解</a>、<a href="https://blog.csdn.net/u011534057/article/details/51219959">RCNN学习笔记(3)</a>、<a href="https://cloud.tencent.com/developer/article/1829792">ROI详解</a>（<a href="https://erdem.pl/2020/02/understanding-region-of-interest-ro-i-pooling">英文原版</a>）</p><h4 id="Fast-RCNN"><a href="#Fast-RCNN" class="headerlink" title="Fast-RCNN"></a>Fast-RCNN</h4><p>论文：<a href="https://arxiv.org/pdf/1504.08083.pdf">Fast R-CNN</a></p><h5 id="网络架构-x2F-使用方法-5"><a href="#网络架构-x2F-使用方法-5" class="headerlink" title="网络架构&#x2F;使用方法"></a>网络架构&#x2F;使用方法</h5><p>网络结构：<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311202415-5.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>目标检测：</p><ol><li>产生候选区域：同RCNN一致</li><li>提取整张图片的特征生成特征图，并将候选区域映射到特征图上：同SPPnet一致</li><li>候选区域分类+BBox回归：对<strong>每个候选区域</strong>使用ROI Pooling，然后进行softmax分类+回归</li></ol><h5 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h5><p>优点：</p><ul><li>加入多任务损失，使得模型由多阶段转为单阶段，实现端到端（除SS Region Proposal阶段）（创新点）</li><li>删除SVM后，可以一次更新所有层的参数，并且不需要存储到硬盘 （优化SPPnet）</li></ul><p>缺点：</p><ul><li>使用的selective search只能在CPU上跑，速度慢</li></ul><h5 id="一些结论"><a href="#一些结论" class="headerlink" title="一些结论"></a>一些结论</h5><ul><li>多任务比多阶段训练好</li><li>发现SPPnet的多尺度训练并不比单尺度训练好，因为尺度不变性，所以使用ROI 池化</li><li>训练数据当然越多越好</li><li>softmax比SVM略好</li><li>候选框越多，mAP呈现先声后降的趋势</li></ul><hr><p>参考博客：<a href="https://zhuanlan.zhihu.com/p/42738847">物体检测之Fast R-CNN</a>、<a href="https://zhuanlan.zhihu.com/p/383167028">RCNN 系列详解</a>、<a href="https://www.cnblogs.com/zyly/p/9246418.html">目标检测算法之Fast R-CNN算法详解</a></p><h4 id="Faster-RCNN"><a href="#Faster-RCNN" class="headerlink" title="Faster-RCNN"></a>Faster-RCNN</h4><p>论文：<a href="https://arxiv.org/abs/1506.01497">Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks</a></p><h5 id="网络架构-x2F-使用方法-6"><a href="#网络架构-x2F-使用方法-6" class="headerlink" title="网络架构&#x2F;使用方法"></a>网络架构&#x2F;使用方法</h5><p>网络结构：<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311202415-6.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></p><ol><li>特征提取：全卷积层</li><li>候选框生成+候选框调整：RPN网络</li><li>生成固定长度向量：Roi 池化</li><li>分类+微调：softamx+回归</li></ol><h5 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h5><p>优点：</p><ul><li>端到端网络（改进Fast）</li><li>使用RPN替代选择性搜索，提高速度（改进Fast）</li><li>共享RPN和Fast R-CNN特征（改进Fast）</li><li>RCNN集大成之作（改进Fast）</li></ul><p>缺点：</p><ul><li>步骤繁琐、速度慢</li><li>重叠特征容易漏检（NMS的原因）</li><li><a href="https://blog.csdn.net/qq_41214679/article/details/114595001#t2">重新审视Faster RCNN：优缺点与改进</a></li></ul><p>参考博客：<a href="https://zhuanlan.zhihu.com/p/31426458">一文读懂Faster RCNN（完善）</a>、<a href="https://www.cnblogs.com/guoyaohua/p/9488119.html">Faster R-CNN：详解目标检测的实现过程</a></p><h4 id="FPN-Faster-RCNN"><a href="#FPN-Faster-RCNN" class="headerlink" title="FPN+Faster RCNN"></a>FPN+Faster RCNN</h4><p>论文：<a href="https://arxiv.org/abs/1612.03144">Feature Pyramid Networks for Object Detection</a><br>融合深浅层特征，解决不同尺寸目标预测</p><h5 id="网络架构-x2F-使用方法-7"><a href="#网络架构-x2F-使用方法-7" class="headerlink" title="网络架构&#x2F;使用方法"></a>网络架构&#x2F;使用方法</h5><p>FPN网络思想<img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311202415-7.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></p><ol><li>图片输入resnet，构建自底向上网络</li><li>构建对应自顶向下网络，每层进行RPN操作，然后进行ROI池化</li><li>将得到的ROI分别进行分类和回归</li><li><a href="https://blog.csdn.net/haoji007/article/details/88387635">FPN构建Faster R-CNN检测器</a></li></ol><h5 id="优缺点-7"><a href="#优缺点-7" class="headerlink" title="优缺点"></a>优缺点</h5><p>优点：</p><ul><li>结合深浅层和多分辨率特征进行融合</li><li>主干网络，可以适配很多模型</li></ul><h5 id="trick："><a href="#trick：" class="headerlink" title="trick："></a>trick：</h5><ul><li>使用3×3卷积降低上采样影响</li><li>使用1×1卷积匹配输入的维度</li></ul><p>参考博客：<a href="https://zhuanlan.zhihu.com/p/78160468">Feature Pyramid Network 详解特征金字塔网络FPN的来龙去脉</a>、<a href="https://zhuanlan.zhihu.com/p/62604038">【目标检测】FPN(Feature Pyramid Network)</a></p><h4 id="Mask-RCNN（RoI-Align）"><a href="#Mask-RCNN（RoI-Align）" class="headerlink" title="Mask-RCNN（RoI Align）"></a>Mask-RCNN（RoI Align）</h4><p>论文：<a href="https://arxiv.org/pdf/1703.06870.pdf">Mask R-CNN</a><br>加入mask和RoI Align使得可以进行分割任务</p><h5 id="网络架构-x2F-使用方法-8"><a href="#网络架构-x2F-使用方法-8" class="headerlink" title="网络架构&#x2F;使用方法"></a>网络架构&#x2F;使用方法</h5><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311202415-8.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5"><br>RoI Align:<br><a href="https://blog.csdn.net/weixin_42782150/article/details/110946903">RoIPooling和RoIAlign的学习和理解</a></p><h5 id="优缺点-8"><a href="#优缺点-8" class="headerlink" title="优缺点"></a>优缺点</h5><ol><li>将RoI池化修改为更适合分割任务的RoI Align</li></ol><hr><p>参考博客：<a href="https://blog.csdn.net/jiongnima/article/details/79094159">图片出处</a>、<a href="https://blog.csdn.net/qq_37541097/article/details/123754766">Mask R-CNN网络详解</a></p><h4 id="Cascade-RCNN"><a href="#Cascade-RCNN" class="headerlink" title="Cascade RCNN"></a>Cascade RCNN</h4><p>论文：<a href="https://arxiv.org/pdf/1712.00726.pdf">Cascade R-CNN: Delving into High Quality Object Detection</a><br>主要解决<strong>在目标检测中，检测框不是特别准，容易出现噪声干扰的问题</strong>，</p><h5 id="网络架构-x2F-使用方法-9"><a href="#网络架构-x2F-使用方法-9" class="headerlink" title="网络架构&#x2F;使用方法"></a>网络架构&#x2F;使用方法</h5><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311202415-9.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>通过级联的R-CNN网络，每个级联的R-CNN设置不同的IOU阈值，这样每个网络输出的准确度提升一点，用作下一个更高精度的网络的输入，逐步将网络输出的准确度进一步提高。</p><h5 id="优缺点-9"><a href="#优缺点-9" class="headerlink" title="优缺点"></a>优缺点</h5><p>优点：</p><ul><li>避免因IoU增大而导致训练过拟合</li><li>缓解mismatch问题</li><li>适用任何二阶段算法</li></ul><p>缺点：</p><ul><li>特征提取部分耗时较大，不能实时</li></ul><hr><p>参考博客：<a href="https://blog.csdn.net/qq_41375609/article/details/96871118">【论文笔记】</a>、<a href="https://zhuanlan.zhihu.com/p/42553957">Cascade R-CNN 详细解读</a>（介绍实验部分）、<a href="https://zhuanlan.zhihu.com/p/161530664">RCNN系列文章之Cascade RCNN详解</a>（介绍实验部分）</p><h3 id="one-stage-detection"><a href="#one-stage-detection" class="headerlink" title="one-stage detection"></a>one-stage detection</h3><h4 id="网络架构-x2F-使用方法-10"><a href="#网络架构-x2F-使用方法-10" class="headerlink" title="网络架构&#x2F;使用方法"></a>网络架构&#x2F;使用方法</h4><h4 id="优缺点-10"><a href="#优缺点-10" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><p>- </p><p>缺点：</p><p>- </p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 学习 半成品</title>
      <link href="/2023/03/11/Java%20%E5%AD%A6%E4%B9%A0%20%E5%8D%8A%E6%88%90%E5%93%81-java-study/"/>
      <url>/2023/03/11/Java%20%E5%AD%A6%E4%B9%A0%20%E5%8D%8A%E6%88%90%E5%93%81-java-study/</url>
      
        <content type="html"><![CDATA[<p>半路转C++了，所以没学完Java，相对来说，韩顺平这个Java视频讲的很详细，如果时间充裕可以看看。</p><h1 id="初阶知识"><a href="#初阶知识" class="headerlink" title="初阶知识"></a>初阶知识</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="加法运算"><a href="#加法运算" class="headerlink" title="加法运算"></a>加法运算</h3><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311202016.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></p><h3 id="浮点数-x2F-byte-x2F-布尔值"><a href="#浮点数-x2F-byte-x2F-布尔值" class="headerlink" title="浮点数&#x2F;byte&#x2F;布尔值"></a>浮点数&#x2F;byte&#x2F;布尔值</h3><ul><li>浮点数 &#x3D; 符号位 +指数位 +尾数位</li></ul><p>浮点数默认为double类型，float n1 &#x3D; 1.1+anything 报错</p><ul><li>boolean变量只能为true&#x2F;false</li><li>给byte赋常数时，<strong>先</strong>判断该值是否在byte范围(-128~127)内，所以不会出现赋值为int类型</li></ul><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>进行赋值或运算时，小精度类型自动转化为大精度类型<br>char&#x2F;(byte → short) → int → long → float → double<br>byte&#x2F;char&#x2F;short 同类型计算或它们之间计算都会自动转成int类型<br>强制转换<br>(int)(long&#x2F;float值)</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符运算"><a href="#算数运算符运算" class="headerlink" title="算数运算符运算"></a>算数运算符运算</h3><ul><li><p>a % b &#x3D; a - a &#x2F; b * b 所以当b为<strong>负数</strong>反而为正，ab全为负数则为负</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">i = i++; <span class="comment">// temp = i; i = i+1; i = temp;</span></span><br><span class="line">System.out.<span class="built_in">println</span>(i); <span class="comment">// i=1</span></span><br></pre></td></tr></table></figure></li><li><p>复合赋值运算符会自动类型转换(包括++，–)</p><ul><li>b +&#x3D; 2; -&gt; b &#x3D; (type)b + 2;</li></ul></li></ul><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>&amp; 和 | 用在检查特等奖和一等奖之间取最好的那个</p><h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><p>整数有四种进制：</p><ol><li>二进制：以0b或0B开头</li><li>十进制</li><li>八进制：以0开头</li><li>十六进制：以0x或0X开头</li></ol><p>二进制转八进制：从低位开始，二进制数<strong>每三位(</strong>$2^{3}&#x3D;8$<strong>)<strong>一组，换算成对应八进制数<br>二进制转十六进制：从低位开始，二进制数</strong>每四位</strong>一组，换算成对应八进制数<br>反之，则将八(十六)进制数<strong>每位</strong>转成对应**三(四)**位二进制数即可</p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>原码，反码，补码：</p><ul><li>正数三码合一</li><li>负数的反码 &#x3D; 原码符号位不变，其他位取反</li><li>负数的反码 &#x3D; 补码 - 1；补码 &#x3D; 反码 + 1</li><li>0的反码、补码都是0</li><li>计算机以补码进行运算，Java的数都是有符号</li><li>运算结果用原码</li><li>二进制最高位为符号位：0正1负，位数取决于int大小</li></ul><p>位运算符：</p><ul><li>算数右移&gt;&gt;：低位溢出，符号位不变，高位补符号位 &lt;&#x3D;&gt; b&#x2F;2</li><li>算数左移&lt;&lt;：符号位不变，低位补0 &lt;&#x3D;&gt; b*2</li><li>逻辑右移&gt;&gt;&gt;：低位溢出，高位补0</li><li>低位溢出指的是删除最右边移动的数个；高位补数指的是将数个加到最左边，整体右移</li><li>1000 0000 0000 0110 &gt;&gt;&gt;2：<strong>00</strong>10 0000 0000 00**01 **<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -2原 10000000 00000000 00000000 00000010</span></span><br><span class="line"><span class="comment">// -2反 11111111 11111111 11111111 11111101</span></span><br><span class="line"><span class="comment">// -2补 11111111 11111111 11111111 11111110</span></span><br><span class="line"><span class="comment">// -2移 00111111 11111111 11111111 11111111</span></span><br><span class="line"><span class="comment">// -2反 11111111 11111111 11111111 11111011</span></span><br><span class="line"><span class="comment">// -2原 10000000 00000000 00000000 00000100</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">0b00111111111111111111111111111111</span>;</span><br><span class="line">System.out.<span class="built_in">println</span>(a);</span><br><span class="line">System.out.<span class="built_in">print</span>(<span class="number">-2</span>&gt;&gt;&gt;<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><ul><li>switch中表达式的返回值必须是：byte, short, int, char, enum, String</li><li>break&#x2F;continue 可以通过标签指明终止&#x2F;跳过哪一层语句块（不建议使用）<ul><li><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311202016-1.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></li></ul></li><li>“lucky”.equals(type) &#x2F;&#x2F; 避免空指针</li></ul><h2 id="数组-x2F-排序-x2F-查找"><a href="#数组-x2F-排序-x2F-查找" class="headerlink" title="数组&#x2F;排序&#x2F;查找"></a>数组&#x2F;排序&#x2F;查找</h2><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态创建数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">int</span> [][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];  <span class="comment">// 确定一维数组个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; ++i)&#123;</span><br><span class="line">        arr[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i+<span class="number">1</span>];  <span class="comment">// 第i排上开辟空间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 双下标经典用法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">insert_num</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i&lt;arrNew.length; ++i)&#123;</span><br><span class="line">    <span class="keyword">if</span> (insert_num &lt; arr[j])&#123;</span><br><span class="line">        ++j;</span><br><span class="line">        arrNew[i] = arr[j];</span><br><span class="line">    <span class="keyword">else</span> arrNew[i] = insert_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><p>加载cat类信息从第一句代码就执行<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311202016-2.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></p><h3 id="Java内存的结构分析"><a href="#Java内存的结构分析" class="headerlink" title="Java内存的结构分析"></a>Java内存的结构分析</h3><ul><li>栈：一般存放基本数据类型（局部变量）</li><li>堆：存放对象、数组</li><li>方法区：常量池，类加载信息</li></ul><p>Java创建对象的流程</p><ol><li>加载Person类信息（属性和方法信息，只加载一次）</li><li>在堆中分配空间，进行默认初始化</li><li>把地址赋给p，p就指向对象</li><li>进行属性赋值</li></ol><p>当方法内将对象置空&#x2F;创建新对象，不会改变main中的对象，参考<a href="https://www.bilibili.com/video/BV1fh411y7R8?p=213">传参机制</a></p><h3 id="递归-☆☆☆"><a href="#递归-☆☆☆" class="headerlink" title="递归 ☆☆☆"></a>递归 ☆☆☆</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 终止条件：在[6][6] == 2</span></span><br><span class="line"><span class="comment"> * 递归方式：左下右上</span></span><br><span class="line"><span class="comment"> * 遇到的情况：0：未走 1 墙 2 走过 3 不通</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">findWay</span><span class="params">(<span class="type">int</span>[][] map, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">6</span>] == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 当前点的情况</span></span><br><span class="line">        <span class="keyword">if</span> (map[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">            map[i][j] = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (findWay(map, i, j+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (findWay(map, i+<span class="number">1</span>, j))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (findWay(map, i, j-<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (findWay(map, i-<span class="number">1</span>, j))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            map[i][j] = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 1,2,3 都不能修改节点值，无法移动</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>语法：访问修饰符 返回类型 方法名(数据类型… 形参名)</p><ul><li>可变参数本质是数组，因此实参可以为数组或0-N个值</li><li>可变参数和普通参数放一起，需保证可变参数在最后</li><li>形参列表只能有一个可变参数</li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>全局变量（属性）：作用域为整个类体，有默认值<br>局部变量（除属性外其他变量）：作用域为代码块，没有默认值</p><h3 id="this使用"><a href="#this使用" class="headerlink" title="this使用"></a>this使用</h3><ul><li>访问构造器语法：this(参数列表)，只能在构造器中使用，并且放在第一条语句中</li></ul><h1 id="中阶知识"><a href="#中阶知识" class="headerlink" title="中阶知识"></a>中阶知识</h1><h2 id="Idea快捷键"><a href="#Idea快捷键" class="headerlink" title="Idea快捷键"></a>Idea快捷键</h2><ul><li>ctrl + D 粘贴至下一行 </li><li>ctrl + Y 删除当前行</li><li>alt + &#x2F; 补全代码</li><li>alt + insert 生成构造器 </li><li>ctrl + H 查看类的层级关系 Hierarchy</li><li>ctrl + B 定位方法</li><li>alt + enter&#x2F; .var 自动分配变量名</li></ul><h1 id="额外知识"><a href="#额外知识" class="headerlink" title="额外知识"></a>额外知识</h1><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><a href="https://blog.csdn.net/langhong8/article/details/50938041">字符串常量池</a></p><h3 id="Cannot-make-a-static-reference-to-the-non-static"><a href="#Cannot-make-a-static-reference-to-the-non-static" class="headerlink" title="Cannot make a static reference to the non-static"></a>Cannot make a static reference to the non-static</h3><p><a href="https://blog.csdn.net/q610376681/article/details/49359819">Cannot make a static reference to the non-static</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ColMap使用</title>
      <link href="/2023/03/11/ColMap%E4%BD%BF%E7%94%A8-colmap-use/"/>
      <url>/2023/03/11/ColMap%E4%BD%BF%E7%94%A8-colmap-use/</url>
      
        <content type="html"><![CDATA[<h1 id="数据集下载"><a href="#数据集下载" class="headerlink" title="数据集下载"></a>数据集下载</h1><p><a href="https://pan.baidu.com/s/1Wb9E6BWCJu4wZfwxm_t4TQ#list/path=%2Fmvsnet%2Fpreprocessed_inputs">密码：s2v2，文件路径mvsnet-&gt;preprocessed_inputs</a></p><h1 id="Tutorial"><a href="#Tutorial" class="headerlink" title="Tutorial"></a>Tutorial</h1><p>COLMAP 3.8-dev</p><h2 id="QuickStart"><a href="#QuickStart" class="headerlink" title="QuickStart"></a>QuickStart</h2><ol><li>Reconstruction &gt; Automatic Reconstruction<ol><li><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311201518.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></li></ol></li><li>分别填入workspace folder、Image folder<ol><li>如果图片在dtu&#x2F;scan4&#x2F;images下，则workspace folder路径填dtu&#x2F;scan4；image folder填dtu&#x2F;scan4&#x2F;images；mask folder作用不知</li><li><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311201518-1.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></li><li>点两次OK即可生成如下3D模型【滚轮放大缩小，ctrl+滚轮增加粒子】，2080ti耗时半小时可能</li><li><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311201518-2.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></li></ol></li><li>等待重建完成，生成大致路径如下<ol><li><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311201518-3.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></li><li>project&#x2F;sparse 表示所有重建组件的稀疏模型；project&#x2F;dense表示相对应的dense model；其中dense point cloud <strong>fused.ply</strong>能通过【File &gt; Import model from …】导入</li></ol></li><li>整个大致流程为<ol><li><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311201518-4.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></li></ol></li></ol><h2 id="the-picture-capture-process"><a href="#the-picture-capture-process" class="headerlink" title="the picture capture process"></a>the picture capture process</h2><p>注意事项：</p><ul><li>拍摄的图片应具有丰富的纹理。最好避免纹理特别少的图片如一张白墙or空桌图片。通过加入一些物品来丰富纹理</li><li>具备相似的光照情况。避免high dynamic range scenes（如有太阳有影子，穿过门或窗拍摄）。避免镜面反射</li><li>具有高度视觉重叠的图片。确保一个物体至少有三张图片，尽量多一点</li><li>多视图拍摄。不要通过平移旋转相机来从同一个方向拍摄。但确保相似视角有少且精的图片，并不是越多越好。如果是视频，请减少帧率。</li></ul><h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>新手参数用<strong>默认的就好</strong>。也可以给不同重建场景设置“optimal”选项，Extras &gt; Set options for … data（不知道干嘛用的，好像能修改图片质量，而不是生成的3D质量）。如需了解参数，查看源码<br>如果遇到非正常退出，介意用命令行运行可执行文件，以获取不同级别的日志记录详细程度。（命令不知）</p><h2 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a>Data Structure</h2><p>COLMAP 假定所有输入图像都在一个输入目录中，该目录具有可能嵌套的子目录。它将读取存储在该目录中的所有图像，并且它支持各种不同的图像格式（请参阅 <a href="http://freeimage.sourceforge.net/documentation.html">FreeImage</a>）。其他文件将被自动忽略。如果需要高性能，那么您应该分离所有非图像文档。图像由它们的相对文档路径唯一标识。对于后期处理，例如图像去失真或密集重建，<strong>应保留相关文档夹结构</strong>。 COLMAP 不修改输入图像或目录，所有提取的数据都存储在一个独立的 SQLite 数据库文档中（请参阅<a href="https://colmap.github.io/database.html">数据库格式</a>）。<br>第一步是通过运行预构建的二进制文件（Windows：COLMAP.bat，Mac：COLMAP.app）或通过从 CMake build 文档夹执行 .&#x2F;src&#x2F;exe&#x2F;colmap gui 来启动 COLMAP 的图形用户界面。接下来，通过<strong>File &gt; New project</strong>。在此对话框中，您<strong>必须选择存储数据库的位置以及包含输入图像的文档夹</strong>。为方便起见，您可以通过选择<strong>File &gt; Save project</strong>将整个项目设置保存到配置文件中。除了任何其他参数设置外，项目配置还存储数据库和图像文档夹的绝对路径信息。如果您决定移动数据库或图像文档夹，则必须通过<strong>创建新项目相应地更改路径</strong>。或者，可以在您选择的文本编辑器中直接修改生成的 .ini 配置文档。要重新打开现有项目，只需选择<strong>File &gt; Open project</strong>即可打开配置文档然后恢复所有参数设置。请注意，所有 COLMAP 可执行文件都可以通过将各个设置指定为命令行参数或通过提供项目配置文档的路径（see <a href="https://colmap.github.io/tutorial.html#interface">Interface</a>）从命令行启动。<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311201518-5.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></p><h2 id="Feature-Detection-and-Extraction"><a href="#Feature-Detection-and-Extraction" class="headerlink" title="Feature Detection and Extraction"></a>Feature Detection and Extraction</h2><p>选择Processing &gt; feature extraction<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311201518-6.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>在此对话框中，您必须首先决定使用的固有相机模型。您可以从嵌入的 EXIF 信息中自动提取焦距信息，也可以手动指定内部参数，例如在实验室校准中获得的参数（在custom parameters里？）。如果图像包含部分 EXIF 信息，COLMAP 会尝试在大型相机型号数据库中自动查找缺失的相机规格。如果您的所有图像都是由具有相同缩放系数的同一台物理相机拍摄的，建议<strong>在所有图像之间共享内在函数</strong>。请注意，如果所有图像共享相同的相机型号但并非所有图像都具有相同的尺寸或 EXIF 焦距，进程将<strong>不正常地退出</strong>。如果您有几组图像共享相同的内在相机参数，您也可以在以后轻松修改相机模型（see <a href="https://colmap.github.io/tutorial.html#database-management">Database Management</a>）。如果不确定在此步骤中选择什幺，只需<strong>坚持使用默认参数</strong>即可。<br>您可以从图像中检测和提取新特征，也可以从文本中导入现有特征。 COLMAP 在 GPU 或 CPU 上提取 SIFT 特征。 GPU 版本需要连接显示器，而 CPU 版本建议在服务器上使用。一般来说，GPU 版本是有利的，因为它具有定制的特征检测模式，通常在高对比度图像的情况下产生更高质量的特征。如果<strong>导入现有特征</strong>，则每个图像旁边都必须有一个文本文档（例如 &#x2F;path&#x2F;to&#x2F;image1.jpg 和 &#x2F;path&#x2F;to&#x2F;image1.jpg.txt），格式如下：</p><blockquote><p>NUM_FEATURES 128<br>X Y SCALE ORIENTATION D_1 D_2 D_3 … D_128<br>…<br>X Y SCALE ORIENTATION D_1 D_2 D_3 … D_128</p></blockquote><p>其中 X、Y、SCALE、ORIENTATION 是浮点数，D_1…D_128 值在 0…255 范围内。该文档应包含 NUM_FEATURES 行，每个功能一行。例如，如果图像有 4 个特征，则文本文档应如下所示：</p><blockquote><p>4 128<br>1.2 2.3 0.1 0.3 1 2 3 4 … 21<br>2.2 3.3 1.1 0.3 3 2 3 2 … 32<br>0.2 1.3 1.1 0.3 3 2 3 2 … 2<br>1.2 2.3 1.1 0.3 3 2 3 2 … 3</p></blockquote><p>请注意，按照惯例，图像的左上角坐标为 (0, 0)，最左上角像素的中心坐标为 (0.5, 0.5)。如果您必须为大型图像集合导入特征，使用您喜欢的脚本语言直接访问数据库会更有效(see <a href="https://colmap.github.io/database.html#database-format">Database Format</a>)<br>如果您完成了所有选项的设置，请选择“Extract”并等待提取完成或取消。如果您在提取过程中取消，下次您开始为同一项目提取图像时，COLMAP 会<strong>自动从中断处继续</strong>。这也允许您将图像添加到现有项目&#x2F;重建中。在这种情况下，请务必在使用共享内在函数时<strong>验证相机参数</strong>。<br>所有提取的数据将存储在数据库文档中，可以在数据库管理工具中查看&#x2F;管理(see <a href="https://colmap.github.io/tutorial.html#database-management">Database Management</a>) 或使用SQLite(see <a href="https://colmap.github.io/database.html#database-format">Database Format</a>).</p><h2 id="Feature-Matching-and-Geometric-Verification"><a href="#Feature-Matching-and-Geometric-Verification" class="headerlink" title="Feature Matching and Geometric Verification"></a>Feature Matching and Geometric Verification</h2><p>特征匹配和几何验证会找到不同图像中特征点之间的对应关系。<br>选择Processing &gt; feature matching 并选择一种提供的匹配模式，用于不同的输入场景：<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311201518-7.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><strong>Exhaustive Matching</strong>：如果你的数据集中的<strong>图片数量比较少</strong>（最多几百张），这种匹配模式应该足够快，重建结果最好。在这里，每个图像都与其他图像匹配，而参数block_size决定了同时从磁盘加载到内存中的图像数量。<br><strong>Sequential Matching</strong>: 如果图像是<strong>按顺序获取</strong>的（例如，通过摄像机），则此模式很有用。在这种情况下，连续的帧有视觉重叠，没有必要穷尽地匹配所有图像对。相反，连续捕获的图像相互匹配。这种匹配模式具有基于vocabulary tree的内置循环检测，其中每第 N 个图像 (loop_detection_period) 与其视觉上最相似的图像 (loop_detection_num_images) 进行匹配。请注意，图像文件名必须按顺序排列（例如，image0001.jpg、image0002.jpg 等）。数据库中的顺序无关紧要，因为图像是根据其文件名明确排序的。请注意，顺序检测需要一个预训练的vocabulary tree，可以从 <a href="https://demuc.de/colmap/">https://demuc.de/colmap/</a> 下载。<br><strong>Vocabulary Tree Matching</strong>：在这种匹配模式中，每个图像都使用a vocabulary tree with spatial re-ranking与其视觉上最近的邻居进行匹配。这是推荐的<strong>大型图像集合</strong>（数千个）的匹配模式。这需要一个预训练的词汇树，可以从 <a href="https://demuc.de/colmap/">https://demuc.de/colmap/</a> 下载。<br><strong>Spatial Matching</strong>：这种匹配模式将每个图像与其空间上最近的邻居进行匹配。空间位置可以在database management中手动设置。默认情况下，COLMAP 还从 EXIF 中提取 GPS 信息并将其用于空间最近邻搜索。如果有<strong>准确的先验位置信息</strong>，这是推荐的匹配方式。<br><strong>Transitive Matching</strong>：这种匹配模式使用已经存在的特征匹配的传递关系来产生更完整的匹配图。如果图像 A 与图像 B 匹配并且 B 与 C 匹配，则此匹配器会尝试直接将 A 与 C 匹配。<br><strong>Custom Matching</strong>：此模式允许指定单个图像对进行匹配或导入单个特征匹配。要指定图像对，您必须提供一个文本文档，每行包含一个图像对：</p><blockquote><p>image1.jpg image2.jpg<br>image1.jpg image3.jpg<br>…</p></blockquote><p>其中 image1.jpg 是图像文档夹中的<strong>相对路径</strong>。您有两个选项来导入单个特征匹配项：未经geometrically verified的原始特征匹配或已经geometrically verified的特征匹配。在这两种情况下，预期格式为：<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311201518-8.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>其中 image1.jpg 是图像文档夹中的相对路径，数字对是各个图像中从零开始的特征索引。如果您必须为大型图像集导入许多匹配项，使用您选择的脚本语言直接访问数据库会更有效。<br>如果您完成了所有选项的设置，请选择”Match”&#x2F;“Run”并等待匹配完成或在期间取消。请注意，此步骤可能会花费大量时间，具体取决于图像数量、每张图像的特征数量以及所选的匹配模式。exhaustive matching的预期时间从几十张图像的几分钟到数百张图像的几小时到数千张图像的几天或几周不等。如果在匹配后取消匹配过程或导入新图像，COLMAP 只会匹配以前没有匹配过的图像对。跳过已经匹配的图像对的开销很低。这还可以匹配初始匹配后导入的其他图像，并且可以为同一数据集组合不同的匹配模式。<br>所有提取的数据将存储在数据库文档中，可以在数据库管理工具中查看&#x2F;管理(see <a href="https://colmap.github.io/tutorial.html#database-management">Database Management</a>) 或使用SQLite(see <a href="https://colmap.github.io/database.html#database-format">Database Format</a>).<br>注意，特征匹配<strong>需要 GPU</strong>，并且在匹配过程中您的计算机的显示性能可能会显著下降。如果您的系统有多个支持 CUDA 的 GPU，您可以使用 **gpu_index **选项选择特定的 GPU。</p><h2 id="Sparse-Reconstruction"><a href="#Sparse-Reconstruction" class="headerlink" title="Sparse Reconstruction"></a>Sparse Reconstruction</h2><p>Reconstruction &gt; start&#x2F;resume reconstruction进行 incremental reconstruction<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311201518-9.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>COLMAP 首先将所有数据库中提取的数据加载到内存中，并从初始的image pair开始重建。然后，通过记录新图像和triangulating new points来逐步扩展场景。在此重建过程中，结果实时可视化。有关可用控件的更多详细信息，请参阅<a href="https://colmap.github.io/gui.html#gui">Graphical User Interface</a>。如果不是所有图像都记录到同一模型中，COLMAP 会尝试重建多个模型。可以从工具栏的下拉菜单中选择不同的模型（应该如图所示的下拉栏）。<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311201518-10.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>如果不同的模型有共同的记录过图像，您可以使用 model_converter executable将它们合并到一个重建中（有关详细信息，see <a href="https://colmap.github.io/faq.html#faq-merge-models">FAQ</a>）。如果您的所有图像都使用没有共享内在函数的 SIMPLE_RADIAL 相机模型（默认），您可以使用 PBA而不是 Ceres Solver进行快速bundle调整，它可以在“reconstruction options”下的”Bundle”中激活（use_pba &#x3D; true）。<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311201518-11.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>理想情况下，重建工作正常并且所有图像都已记录。如果不是这种情况，建议：</p><ul><li>执行额外的匹配。为获得最佳结果，请使用exhaustive matching、enable guided matching、增加词汇树匹配中的最近邻数量或增加sequential matching中的重叠等。</li><li>如果 COLMAP 初始化失败，请手动选择初始图像对。选择Reconstruction &gt; Reconstruction options &gt; Init并从数据库管理工具中设置从不同视点具有足够匹配度的图像。</li></ul><p>并从数据库管理工具中设置从不同视点具有足够匹配度的图像。</p><h2 id="Importing-and-Exporting"><a href="#Importing-and-Exporting" class="headerlink" title="Importing and Exporting"></a>Importing and Exporting</h2><p>COLMAP 为进一步处理提供了几个导出选项。为了充分的灵活性，建议导出以 COLMAP 的数据格式的reconstruction。通过选择 File &gt; Export 导出当前查看的模型或 File &gt; Export all 导出所有重建的模型。使用用于重建相机、图像和点的单独文本文件将模型导出到所选文件夹中。当以 COLMAP 的数据格式导出时，您可以重新导入重建以用于以后的可视化、图像去失真，或从中断的地方继续现有的重建（例如，在导入和匹配新图像之后）。要导入模型，请选择 File &gt; Import 并选择导出文件夹路径。或者，您也可以通过 File &gt; Export as… 选择以各种其他格式导出模型，例如 Bundler、VisualSfM 、PLY 或 VRML。COLMAP 可以通过 File &gt; Import From… 可视化具有 RGB 信息的plain PLY 点云文件。有关导出模型格式的更多信息，请参见<a href="https://colmap.github.io/format.html#output-format">此处</a>。<br> <img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311201518-12.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"></p><h2 id="Dense-Reconstruction"><a href="#Dense-Reconstruction" class="headerlink" title="Dense Reconstruction"></a>Dense Reconstruction</h2><p>在重建场景的稀疏表示和输入图像的相机姿势后，MVS 现在可以恢复更密集的场景几何。 COLMAP 具有集成的密集重建流程，可以为所有配准图像生成深度图和法线图，将深度图和法线图融合成具有法线信息的密集点云，并最终使用Poisson或Delaunay重建从融合点云估计密集表面。<br>首先，导入你的稀疏 3D模型（或选择已重建的模型）。然后选择Reconstruction &gt; Multi-view stereo并选择一个空的工作路径，用来存储所有稠密重建结果。然后 1. undistort 图片，2. 使用stereo计算深度图和法线图，3. fuse 深度图和法线图形成点云， 4. meshing 点云（可选选项）。<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311201518-13.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>在stereo重建过程中，由于计算负载过重，显示器可能会冻结，如果您的 GPU 没有足够的内存，重建过程可能会意外崩溃。参考 the FAQ (<a href="https://colmap.github.io/faq.html#faq-dense-timeout">freeze</a> and <a href="https://colmap.github.io/faq.html#faq-dense-memory">memory</a>)的解决方案。请注意，点云的重建法线无法在 COLMAP 中直接可视化，但在 Meshlab 中可以通过启用Render &gt; Show Normal&#x2F;Curvature。同样，重建的密集表面网格模型必须使用外部软件进行可视化。<br>除了内部密集重建功能外，COLMAP 还导出到其他几个密集重建库，例如 CMVS&#x2F;PMVS或CMP-MVS。请选择Extras &gt; Undistort images并选择合适的转换。<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311201518-14.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>输出文件夹包含重建和未失真的图像。此外，这些文档夹还包含用于执行密集重建的 shell 示例脚本。要运行 PMVS2，请执行以下命令：.&#x2F;path&#x2F;to&#x2F;pmvs2 &#x2F;path&#x2F;to&#x2F;undistortion&#x2F;folder&#x2F;pmvs&#x2F; option-all<br>其中 &#x2F;path&#x2F;to&#x2F;undistortion&#x2F;folder 是在undistortion 对话框中选择的文件夹。确保不要忘记上述命令行参数中 &#x2F;path&#x2F;to&#x2F;undistortion&#x2F;folder&#x2F;pmvs&#x2F; 中的<strong>尾部斜杠</strong>。<br>对于大型数据集，您可能希望首先运行 CMVS 将场景聚类为更易于管理的部分，然后运行 COLMAP 或 PMVS2。请参阅 undistortion 输出文件夹中的 shell 示例脚本，了解如何结合 COLMAP 或 PMVS2 运行 CMVS。此外，还有许多支持 COLMAP 输出的外部库：</p><ul><li><a href="http://www.di.ens.fr/pmvs/">CMVS&#x2F;PMVS</a> <a href="https://colmap.github.io/bibliography.html#furukawa10">[furukawa10]</a></li><li><a href="http://ptak.felk.cvut.cz/sfmservice/websfm.pl">CMP-MVS</a> <a href="https://colmap.github.io/bibliography.html#jancosek11">[jancosek11]</a></li><li><a href="https://github.com/manhofer/Line3Dpp">Line3D++</a> <a href="https://colmap.github.io/bibliography.html#hofer16">[hofer16]</a>.</li></ul><h2 id="Database-Management"><a href="#Database-Management" class="headerlink" title="Database Management"></a>Database Management</h2><p>您可以在数据库管理工具中查看和管理导入的摄像机、图像和特征匹配，选择Processing &gt; Manage database。在打开的对话框中，您可以看到导入的图像和相机列表。您可以通过单击Show image 和 Overlapping images查看每个图像的特征和匹配项。可以通过双击特定单元格来修改数据库表中的各个条目。请注意，对数据库的任何更改只有在单击Save后才有效（现在关闭对话框就能直接生效）。<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2023/03/20230311201518-15.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br>要在任意图像组之间共享相机内在参数，请选择单个或多个图像，然后选择 Set camera 并设置 camera_id，它对应于 cameras 表中唯一的 camera_id 列。您还可以添加具有特定参数的新相机。通过将 prior_focal_length flag设置为 0 或 1，可以提示重建算法是否应该信任该焦距值。如果是先前的实验室校准，您希望将此值设置为 1。在事先不了解焦距的情况下，建议将此值设置为 1.25 * max(width_in_px, height_in_px)。<br>数据库管理工具只有有限的功能，要完全控制数据，您必须直接修改 SQLite 数据库（see <a href="https://colmap.github.io/database.html#database-format">Database Format</a>）。通过直接访问数据库，您可以仅使用 COLMAP 进行特征提取和匹配，也可以导入自己的特征和匹配以仅使用 COLMAP 的增量重建算法。</p><h2 id="Graphical-and-Command-line-Interface"><a href="#Graphical-and-Command-line-Interface" class="headerlink" title="Graphical and Command-line Interface"></a>Graphical and Command-line Interface</h2><p>COLMAP 的大部分功能都可以从图形界面和命令行界面访问，它们都嵌入在同一个可执行文件中。您可以直接将选项作为命令行参数提供，也可以使用 –project_path path&#x2F;to&#x2F;project.ini 参数提供包含选项的 .ini 项目配置文件。启动GUI界面可以在当前文件夹路径的cmd中输入colmap gui 或直接明确项目配置 colmap gui –project_path。使用colmap help来列举不同命令参数。<a href="https://colmap.github.io/gui.html#gui">graphical user interface</a> 和 <a href="https://colmap.github.io/cli.html#cli">command-line Interface</a>提供了有关可用命令的更多详细信息。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
          <category> 软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三维重建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 与python通信、python调用c++ 动态库返回检测结果</title>
      <link href="/2023/01/08/python%20%E4%B8%8Epython%E9%80%9A%E4%BF%A1%E3%80%81python%E8%B0%83%E7%94%A8c++%20%E5%8A%A8%E6%80%81%E5%BA%93%E8%BF%94%E5%9B%9E%E6%A3%80%E6%B5%8B%E7%BB%93%E6%9E%9C-python-and-ctypes/"/>
      <url>/2023/01/08/python%20%E4%B8%8Epython%E9%80%9A%E4%BF%A1%E3%80%81python%E8%B0%83%E7%94%A8c++%20%E5%8A%A8%E6%80%81%E5%BA%93%E8%BF%94%E5%9B%9E%E6%A3%80%E6%B5%8B%E7%BB%93%E6%9E%9C-python-and-ctypes/</url>
      
        <content type="html"><![CDATA[<h2 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h2><p>python 客户端将opencv读取到的图片发送给python服务端，然后python服务端将opencv图发送给Linux设备，将处理结果通过C++ 传给服务端，然后服务端再传给客户端。<br>这里服务端可以改成C++ 写的，就不用这么麻烦了，但是需要将python的pickle包解码成C++ 的pickle包，还未尝试。<br>以下所给代码，并不一定能跑通，思路在哪里，结合自己的代码</p><h2 id="第一步，python间通信"><a href="#第一步，python间通信" class="headerlink" title="第一步，python间通信"></a>第一步，python间通信</h2><p>这种方式能一次性全部发送，一次性全部接受（如发一张图片，接受一张，发两张，接受两张）</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><h4 id="Python-Client"><a href="#Python-Client" class="headerlink" title="Python Client"></a>Python Client</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> multiprocessing.connection <span class="keyword">import</span> Client</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">host = <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">port = <span class="number">9006</span></span><br><span class="line">frame_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">connect_and_send</span>(<span class="params">path, mode=<span class="string">&#x27;file&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">global</span> frame_num</span><br><span class="line">    client = Client((host, port))</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        img_dict_list = []</span><br><span class="line">        <span class="comment"># 从文件夹读取图片</span></span><br><span class="line">        <span class="keyword">if</span> mode == <span class="string">&#x27;file&#x27;</span>:</span><br><span class="line">            img_list = []</span><br><span class="line">            img_path = <span class="string">&#x27;./data&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(img_path):</span><br><span class="line">                read_img = cv2.imread(img_path + <span class="string">&#x27;/&#x27;</span> + filename)</span><br><span class="line">                img_list.append(read_img)</span><br><span class="line">            <span class="comment"># 存入dict</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(img_list)):</span><br><span class="line">                img_obj = &#123;<span class="string">&#x27;frame_num&#x27;</span>: i + <span class="number">1</span>, <span class="string">&#x27;image&#x27;</span>: img_list[i],</span><br><span class="line">                           <span class="string">&#x27;time&#x27;</span>: time.strftime(<span class="string">&#x27;%Y%m%d%H%M%S&#x27;</span>, time.localtime())&#125;</span><br><span class="line">                img_dict_list.append(img_obj)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            read_img = cv2.imread(path)</span><br><span class="line">            img_obj = &#123;<span class="string">&#x27;frame_num&#x27;</span>: frame_num + <span class="number">1</span>, <span class="string">&#x27;image&#x27;</span>: read_img,</span><br><span class="line">                       <span class="string">&#x27;time&#x27;</span>: datetime.datetime.now().strftime(<span class="string">&#x27;%M%S.%f&#x27;</span>)&#125;</span><br><span class="line">            img_dict_list.append(img_obj)</span><br><span class="line">            frame_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. obj to pickle 用json的话会慢，因为read_img需要to_list()</span></span><br><span class="line">        data_bytes = pickle.dumps(img_dict_list)</span><br><span class="line">        <span class="comment"># 2. 发送文件</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;client send: &#x27;</span>, datetime.datetime.now().strftime(<span class="string">&#x27;%M%S.%f&#x27;</span>))</span><br><span class="line">        client.send(data_bytes)</span><br><span class="line"></span><br><span class="line">        det_result = client.recv()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;client receive: &#x27;</span>, datetime.datetime.now().strftime(<span class="string">&#x27;%M%S.%f&#x27;</span>))</span><br><span class="line">        det_result = pickle.loads(det_result)</span><br><span class="line">        <span class="built_in">print</span>(det_result)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    connect_and_send(<span class="string">&#x27;data/ship.jpg&#x27;</span>, mode=<span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="Python-Server端"><a href="#Python-Server端" class="headerlink" title="Python Server端"></a>Python Server端</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> multiprocessing.connection <span class="keyword">import</span> Listener</span><br><span class="line"></span><br><span class="line">host = <span class="string">&#x27;192.168.0.2&#x27;</span></span><br><span class="line">port = <span class="number">9006</span></span><br><span class="line">server_sock = Listener((host, port))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Connecting... ...&quot;</span>)</span><br><span class="line">sock = server_sock.accept()</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        received_bytes = sock.recv()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;server receive: &#x27;</span>, datetime.datetime.now().strftime(<span class="string">&#x27;%M%S.%f&#x27;</span>))</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        received_bytes = <span class="literal">None</span></span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> received_bytes:   <span class="comment"># 当客户端下线，不让服务端下线</span></span><br><span class="line">        server_sock.close()</span><br><span class="line">        sock.close()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Client&#x27;s data is empty !!!&quot;</span>)</span><br><span class="line">        server_sock = Listener((host, port))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Reset Sever&quot;</span>)</span><br><span class="line">        sock = server_sock.accept()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># bytes to list</span></span><br><span class="line">        img_dict_list = pickle.loads(received_bytes)</span><br><span class="line">        <span class="comment"># detect</span></span><br><span class="line">        det_dict_list = []</span><br><span class="line">        img_num = <span class="built_in">len</span>(img_dict_list)</span><br><span class="line"></span><br><span class="line">        img = img_dict_list[<span class="number">0</span>][<span class="string">&#x27;image&#x27;</span>]</span><br><span class="line">        <span class="comment"># img send to server</span></span><br><span class="line">        det_obj = &#123;<span class="string">&#x27;frame_num&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;det_output&#x27;</span>: getCResult(lib, det, img, img_num),  <span class="comment"># getCResult获取检测结果</span></span><br><span class="line">                   <span class="string">&#x27;time&#x27;</span>: datetime.datetime.now().strftime(<span class="string">&#x27;%Y%m%d%H%M%S.%f&#x27;</span>)&#125;</span><br><span class="line">        det_dict_list.append(det_obj)</span><br><span class="line">        <span class="comment"># send result to client</span></span><br><span class="line">        content = pickle.dumps(det_dict_list)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;server send: &#x27;</span>, datetime.datetime.now().strftime(<span class="string">&#x27;%M%S.%f&#x27;</span>))</span><br><span class="line">        sock.send(content)</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/64534116">Python，用简单代码上传内存中的图片到远程服务器进行处理</a>、<a href="https://blog.csdn.net/a19990412/article/details/80919703">Python传输图片（同一局域网下版本）</a></p><h2 id="第二步，python调用C-动态库（opencv）返回检测结果"><a href="#第二步，python调用C-动态库（opencv）返回检测结果" class="headerlink" title="第二步，python调用C++ 动态库（opencv）返回检测结果"></a>第二步，python调用C++ 动态库（opencv）返回检测结果</h2><p>一共有<a href="https://bushyang.medium.com/python-c-c-%E6%95%B4%E5%90%88-adbfbf6051fd">cython、pybind11、ctypes等包</a>，这里用的是ctypes<br>首先你需要有个.so文件，可以用cmake生成，注意python中你要调的包的位置，用camke不改.so文件的路径的话自动在当前文件夹生成，所以会报 <strong>undefined symbol: strTest，</strong>Linux指令：cp 复制文件<br>cmake自行查阅吧，这里做个示范</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">project(xxx)</span><br><span class="line">add_library(xxx SHARED xxx.cpp)   //这里会将.cpp中的非类方法加入到.so文件中</span><br><span class="line">add_executable(yyy yyy.cpp)</span><br><span class="line">target_link_libraries(yyy xxx)</span><br><span class="line">link：https://www.cnblogs.com/blog-3123958139/p/5575360.html</span><br></pre></td></tr></table></figure><h3 id="难点一：传输字符串-string-to-std-string"><a href="#难点一：传输字符串-string-to-std-string" class="headerlink" title="难点一：传输字符串 string to std::string"></a>难点一：传输字符串 string to std::string</h3><p>C++ 端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;   <span class="comment">// 加了才能识别到括号内的方法，必须！用C格式写代码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Detect_Init</span><span class="params">(Detect* det, <span class="type">char</span>* config_path)</span>&#123;  <span class="comment">// det用于调用类方法，后续会讲</span></span><br><span class="line">    <span class="built_in">std</span>:<span class="built_in">string</span> <span class="title function_">config_path1</span><span class="params">(config_path, <span class="keyword">sizeof</span>(config_path))</span>;  <span class="comment">// 将char*转为string类型</span></span><br><span class="line">    <span class="keyword">return</span> det-&gt;Init(config_path1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line">ll = ctypes.cdll.LoadLibrary</span><br><span class="line">lib = ll(<span class="string">&quot;../lib/libDetect.so&quot;</span>)</span><br><span class="line"><span class="comment"># 设置传递参数类型argtypes和返回类型restype</span></span><br><span class="line">lib.Detect_new.argtypes = []</span><br><span class="line">lib.Detect_new.restype = ctypes.c_void_p</span><br><span class="line">lib.Detect_Init.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_int]</span><br><span class="line">lib.Detect_Init.restype = ctypes.c_int</span><br><span class="line"><span class="comment"># 创建一个Detect对象，后续会讲</span></span><br><span class="line">det = lib.Detect_new()</span><br><span class="line"></span><br><span class="line"><span class="comment"># init</span></span><br><span class="line"><span class="comment"># 注意将string.encode()不行，编码到.就结束了</span></span><br><span class="line">config = <span class="built_in">bytes</span>(<span class="string">&quot;../../weights/DetectConfig.yaml&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)  <span class="comment"># 字符串任意，注意路径</span></span><br><span class="line"><span class="comment"># 如果需要传递可修改字符串，参考：https://zhuanlan.zhihu.com/p/215790047</span></span><br><span class="line"><span class="comment"># 使用create_string_buffer(&quot;test&quot;.encode(&#x27;utf-8&#x27;)) </span></span><br><span class="line">lib.Detect_Init(det, config)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://blog.csdn.net/qq_31342997/article/details/88374804#t8">Python调用C的基础学习（传递数字、字符串、数组（一维、二维）、结构体）</a></p><h3 id="难点二：调用C-类方法"><a href="#难点二：调用C-类方法" class="headerlink" title="难点二：调用C++ 类方法"></a>难点二：调用C++ 类方法</h3><p>C++ 端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;  <span class="comment">//此处不贴自己的代码了，粘贴参考链接的代码</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Foo</span>(<span class="type">int</span>);</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">foobar</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line">Foo::<span class="built_in">Foo</span>(<span class="type">int</span> n)  &#123;val = nl;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo::bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value is &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Foo::foobar</span><span class="params">(<span class="type">int</span> n)</span>   </span>&#123;<span class="keyword">return</span> val + n;&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;  <span class="comment">//用于python调用</span></span><br><span class="line">    <span class="function">Foo* <span class="title">Foo_new</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Foo</span>(n);&#125;  <span class="comment">//核心点，创建一个调用类方法的对象</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Foo_bar</span><span class="params">(Foo* foo)</span> </span>&#123;foo-&gt;<span class="built_in">bar</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Foo_foobar</span><span class="params">(Foo* foo, <span class="type">int</span> n)</span> </span>&#123;<span class="keyword">return</span> foo-&gt;<span class="built_in">foobar</span>(n);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line">lib = ctypes.cdll.LoadLibrary(<span class="string">&#x27;./libfoo.so&#x27;</span>)   <span class="comment"># 注意路径</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">object</span>):   <span class="comment"># 也可以不写类，直接放在一个def里</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        lib.Foo_new.argtypes = [ctypes.c_int]</span><br><span class="line">        lib.Foo_new.restype = ctypes.c_void_p</span><br><span class="line">        lib.Foo_bar.argtypes = [ctypes.c_void_p]</span><br><span class="line">        lib.Foo_bar.restype = ctypes.c_void_p</span><br><span class="line">        lib.Foo_foobar.argtypes = [ctypes.c_void_p, ctypes.c_int]</span><br><span class="line">        lib.Foo_foobar.restype = ctypes.c_int</span><br><span class="line">        self.obj = lib.Foo_new(val)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):</span><br><span class="line">        lib.Foo_bar(self.obj)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foobar</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="keyword">return</span> lib.Foo_foobar(self.obj, val)</span><br><span class="line"></span><br><span class="line">f=Foo(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># Calling f.bar() will print a message including the value...</span></span><br><span class="line">f.bar()</span><br><span class="line"><span class="comment"># Now we&#x27;ll use foobar to add a value to that stored in our Foo object, f</span></span><br><span class="line"><span class="built_in">print</span> (f.foobar(<span class="number">7</span>))</span><br><span class="line"><span class="comment"># Now we&#x27;ll do the same thing - but this time demonstrate that it&#x27;s a normal</span></span><br><span class="line"><span class="comment"># Python integer...</span></span><br><span class="line">x = f.foobar(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">type</span>(x))</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://www.auctoris.co.uk/2017/04/29/calling-c-classes-from-python-with-ctypes/">Calling C++  Classes from Python, with ctypes…</a>、<a href="https://www.jianshu.com/p/0306a9898d68">python 调用 C++ dll, 包含类以及opencv Mat</a>、</p><h3 id="难点三：传输结构体并带Mat图片"><a href="#难点三：传输结构体并带Mat图片" class="headerlink" title="难点三：传输结构体并带Mat图片"></a>难点三：传输结构体并带Mat图片</h3><p>此处一个坑点是C++ 结构体的<strong>变量顺序</strong>和<strong>变量类型</strong>必须与python的类一致！！！！一定要仔细校对<br>C++ 类型和Python类型对照<a href="https://docs.python.org/zh-cn/3/library/ctypes.html#fundamental-data-types">网址</a><br>二维数据在python里需要倒着写 C++ [20][5],python [5][20]<br>C++ 端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> image_num;</span><br><span class="line">    <span class="type">int</span> width[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span> height[<span class="number">32</span>];</span><br><span class="line">    <span class="type">char</span>* frame[<span class="number">32</span>];    <span class="comment">// 注意是char* 网上不是uchar*就是POINTER(ubyte) 实际上char*也可，为了与python对应</span></span><br><span class="line">&#125;PythonImage;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getInfo</span><span class="params">(PythonImage  input)</span></span>&#123;  <span class="comment">//验证是否传输成功</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-----Information------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;width: %d, height: %d\n&quot;</span>, input.width[<span class="number">0</span>], input.height[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DetectOutput <span class="title">Detect_Run</span><span class="params">(Detect* det, PythonImage  img)</span></span>&#123;  <span class="comment">// DetectOutput是嵌套结构体，只要细心一般都能返回</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">frame</span><span class="params">(img.height[<span class="number">0</span>], img.width[<span class="number">0</span>], CV_8UC3, img.frame[<span class="number">0</span>])</span></span>;  <span class="comment">// 将char* 转为 Mat格式</span></span><br><span class="line">    <span class="keyword">return</span> det-&gt;<span class="built_in">Run</span>(frame);  <span class="comment">//将图片发给检测算法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">from ctypes <span class="keyword">import</span> *</span></span><br><span class="line"><span class="function"><span class="keyword">import</span> ctypes</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">PythonImage</span><span class="params">(Structure)</span>:</span></span><br><span class="line"><span class="function">    _fields_ =</span> [(<span class="string">&#x27;image_num&#x27;</span>, c_int),  # 注意 _fields_ 是双下划线</span><br><span class="line">                (<span class="string">&#x27;width&#x27;</span>, c_int * val),  <span class="meta"># val=32</span></span><br><span class="line">                (<span class="string">&#x27;height&#x27;</span>, c_int * val),</span><br><span class="line">                (<span class="string">&#x27;frame&#x27;</span>, c_char_p * val)]   # 与C++ 保持一致</span><br><span class="line">        </span><br><span class="line">ll = ctypes.cdll.LoadLibrary</span><br><span class="line">lib = <span class="built_in">ll</span>(<span class="string">&quot;../lib/libDetect.so&quot;</span>)</span><br><span class="line">lib.Detect_Run.argtypes = [ctypes.c_void_p, PythonImage]  # 注意此处填<span class="keyword">class</span>名而不是Structure</span><br><span class="line">lib.Detect_Run.restype = DetectOutput</span><br><span class="line">det = lib.<span class="built_in">Detect_new</span>()</span><br><span class="line">pi = <span class="built_in">PythonImage</span>()</span><br><span class="line"></span><br><span class="line">PARAM = c_int * <span class="number">32</span></span><br><span class="line">height = <span class="built_in">PARAM</span>()</span><br><span class="line">height[<span class="number">0</span>] = frame.shape[<span class="number">0</span>]</span><br><span class="line">pi.height = height</span><br><span class="line"></span><br><span class="line">width = <span class="built_in">PARAM</span>()</span><br><span class="line">width[<span class="number">0</span>] = frame.shape[<span class="number">1</span>]</span><br><span class="line">pi.width = width</span><br><span class="line"># 对cv2图片进行处理</span><br><span class="line">frame_data = np.<span class="built_in">asarray</span>(frame, dtype=np.uint8)</span><br><span class="line">frame_data = frame_data.ctypes.<span class="built_in">data_as</span>(c_char_p)</span><br><span class="line">pi.frame[<span class="number">0</span>] = frame_data</span><br><span class="line">pi.image_num = image_num  # 传输图片的数量</span><br><span class="line"></span><br><span class="line">lib.getInfo.argtypes = [PythonImage]</span><br><span class="line">lib.<span class="built_in">getInfo</span>(pi)</span><br><span class="line">lib.<span class="built_in">Detect_Run</span>(det, pi)  # 检测结果</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://www.cnblogs.com/pyse/p/8590829.html">python调用c&#x2F;C++ 时传递结构体参数</a></p><h3 id="小难点1：嵌套结构体传输-x2F-读取指针值-x2F-ctypes-BUG？"><a href="#小难点1：嵌套结构体传输-x2F-读取指针值-x2F-ctypes-BUG？" class="headerlink" title="小难点1：嵌套结构体传输&#x2F;读取指针值&#x2F;ctypes BUG？"></a>小难点1：嵌套结构体传输&#x2F;读取指针值&#x2F;ctypes BUG？</h3><p>注意C++ 结构体的<strong>变量顺序</strong>和<strong>变量类型</strong>必须与python的类一致！！！！一定要仔细校对，其他应该没有什么问题<br>C++ 端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">AttributeType</span></span><br><span class="line">&#123;</span><br><span class="line">    PERSON_HEAD = <span class="number">0</span>,                          </span><br><span class="line">    PERSON_NECK,             </span><br><span class="line">&#125; AttributeType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">cv_box</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x;                              </span><br><span class="line">    <span class="type">float</span> y;                             </span><br><span class="line">    <span class="type">float</span> w;                                            </span><br><span class="line">    <span class="type">float</span> h;                                              </span><br><span class="line">&#125; cv_box;                                              </span><br><span class="line">   </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">cv_object</span></span><br><span class="line">&#123;</span><br><span class="line">    cv_box bbox;                             </span><br><span class="line">    <span class="type">int</span> classes;                                                           </span><br><span class="line">    <span class="type">float</span> *prob;                                 </span><br><span class="line">    AttributeType attribute;       </span><br><span class="line">    <span class="type">int</span> a[<span class="number">7</span>];</span><br><span class="line">&#125; cv_object;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">cv_object_list</span></span><br><span class="line">&#123;</span><br><span class="line">    cv_object object[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> object_num;   <span class="comment">// 注意这里的顺序 必须object_num 在object[128] 上面，  ！！！bug</span></span><br><span class="line"><span class="comment">// 即两行互换位置，否则无法读取object_num的值，具体为什么不清楚</span></span><br><span class="line"><span class="type">int</span> test[<span class="number">7</span>];</span><br><span class="line">&#125;cv_object_list; </span><br></pre></td></tr></table></figure><p>python端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cv_box</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [(<span class="string">&#x27;x&#x27;</span>, c_float),</span><br><span class="line">                (<span class="string">&#x27;y&#x27;</span>, c_float),</span><br><span class="line">                (<span class="string">&#x27;w&#x27;</span>, c_float),</span><br><span class="line">                (<span class="string">&#x27;h&#x27;</span>, c_float)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cv_object</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [(<span class="string">&#x27;bbox&#x27;</span>, cv_box),</span><br><span class="line">                (<span class="string">&#x27;classes&#x27;</span>, c_int),</span><br><span class="line">                (<span class="string">&#x27;prob&#x27;</span>, POINTER(c_float)),  </span><br><span class="line">                (<span class="string">&#x27;attribute&#x27;</span>, c_int),   <span class="comment"># 枚举类型是c_int</span></span><br><span class="line">                (<span class="string">&#x27;a&#x27;</span>, c_int * <span class="number">7</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cv_object_list</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [(<span class="string">&#x27;object&#x27;</span>, cv_object * <span class="number">128</span>),</span><br><span class="line">                (<span class="string">&#x27;object_num&#x27;</span>, c_int),</span><br><span class="line">               (<span class="string">&#x27;test&#x27;</span>, c_int * <span class="number">7</span>)]</span><br><span class="line"><span class="comment"># 输出指针值</span></span><br><span class="line">prob = POINTER(c_float)(<span class="built_in">object</span>[<span class="number">0</span>].prob)   <span class="comment"># 即float* prob</span></span><br><span class="line"><span class="built_in">print</span>(prob.contents.value)  <span class="comment"># 获取到c_float()中括号内的值</span></span><br><span class="line">参考链接：https://blog.csdn.net/Kelvin_Yan/article/details/<span class="number">86546784</span><span class="comment">#t2</span></span><br></pre></td></tr></table></figure><h3 id="小难点2：python获取C-h文件内容"><a href="#小难点2：python获取C-h文件内容" class="headerlink" title="小难点2：python获取C++  .h文件内容"></a>小难点2：python获取C++  .h文件内容</h3><p>参考链接：<a href="https://blog.csdn.net/whahu1989/article/details/111652840">Python解析C++ 头文件</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> CppHeaderParser</span><br><span class="line"></span><br><span class="line">cppHeader = CppHeaderParser.CppHeader(<span class="string">&quot;../include/type.h&quot;</span>)</span><br><span class="line">val = <span class="number">32</span></span><br><span class="line">OBJECT_NUM = <span class="number">128</span></span><br><span class="line"><span class="keyword">for</span> h <span class="keyword">in</span> cppHeader.defines:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;BATCH_SIZE&#x27;</span> <span class="keyword">in</span> h:</span><br><span class="line">        val = <span class="built_in">int</span>(h.split(<span class="string">&#x27; &#x27;</span>)[-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;OBJECT_NUM&#x27;</span> <span class="keyword">in</span> h:</span><br><span class="line">        OBJECT_NUM = <span class="built_in">int</span>(h.split(<span class="string">&#x27; &#x27;</span>)[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h2 id="第三步-传输视频"><a href="#第三步-传输视频" class="headerlink" title="第三步 传输视频"></a>第三步 传输视频</h2><p>参考博客：<a href="https://blog.csdn.net/weixin_43211480/article/details/100925410">opencv cv2.imshow显示图片一片黑色</a>、<a href="https://blog.csdn.net/w5688414/article/details/78426153"> python:读取视频，处理后，实时计算帧数fps</a>、<a href="https://blog.csdn.net/a19990412/article/details/80940310">opencv imencode跟imdecode函数jpg（python）</a><br>首先如果转换m4s格式到mp4格式，使用命令：ffmpeg -i all.m4s -c copy video.mp4<br>这个比较简单，总体思路就是opencv读取视频，按帧发送，然后接受回传结果并绘制<br>客户端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">send_data</span>(<span class="params">img_dict</span>):</span><br><span class="line">    start = <span class="built_in">int</span>(<span class="built_in">round</span>(time.time() * <span class="number">1000</span>))</span><br><span class="line">    start_time = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime())</span><br><span class="line">    <span class="comment"># 1. send data</span></span><br><span class="line">    data_bytes = pickle.dumps(img_dict)</span><br><span class="line">    client.send(data_bytes)  <span class="comment"># 貌似client是全局变量</span></span><br><span class="line">    <span class="comment"># 2. receive data</span></span><br><span class="line">    det_result = client.recv()</span><br><span class="line">    det_result = pickle.loads(det_result)</span><br><span class="line">    <span class="comment"># print(det_result)</span></span><br><span class="line">    <span class="comment"># cal time cost</span></span><br><span class="line">    end = <span class="built_in">int</span>(<span class="built_in">round</span>(time.time() * <span class="number">1000</span>))</span><br><span class="line">    end_time = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime())</span><br><span class="line">    time_cost = end - start</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;client total time cost: &#x27;</span>, time_cost)</span><br><span class="line">    <span class="comment"># 3. draw boxes 自己写</span></span><br><span class="line">    draw_box(det_result, img_dict)</span><br><span class="line">    <span class="comment"># 4. save logs 自己写</span></span><br><span class="line">    det_frame_num = det_result[<span class="string">&#x27;frame_num&#x27;</span>]</span><br><span class="line">    save_logs(time_cost, start_time, end_time, det_frame_num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">image_send</span>(<span class="params">img</span>):</span><br><span class="line">    <span class="keyword">global</span> frame_num</span><br><span class="line">    img_param = [cv2.IMWRITE_JPEG_QUALITY， <span class="number">95</span>] <span class="comment"># 压缩率</span></span><br><span class="line">    _, img = cv2.imencode(<span class="string">&#x27;.jpg&#x27;</span>, img, img_param)</span><br><span class="line">    <span class="comment"># 为了统一图片，如果单要视频，可以直接传输图片img</span></span><br><span class="line">    img_obj = &#123;<span class="string">&#x27;frame_num&#x27;</span>: frame_num, <span class="string">&#x27;image&#x27;</span>: img&#125;</span><br><span class="line">    frame_num += <span class="number">1</span></span><br><span class="line">    send_data(img_obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_video_send</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">global</span> frame_num</span><br><span class="line">    frame_num = <span class="number">1</span>  <span class="comment"># 重置frame_num 使其适配视频第一帧</span></span><br><span class="line">    video = cv2.VideoCapture(path)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        _, img = video.read()</span><br><span class="line">        cv2.imshow(<span class="string">&#x27;client&#x27;</span>, img)</span><br><span class="line">        cv2.waitKey(<span class="number">1</span>)  <span class="comment"># 不加就黑屏</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        image_send(img)  <span class="comment"># send img</span></span><br><span class="line">        end = time.time()</span><br><span class="line">        seconds = end - start</span><br><span class="line">        fps = <span class="number">1</span> / seconds</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Estimated FPS: &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(fps))</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    img_file = <span class="string">&#x27;./data&#x27;</span></span><br><span class="line">    img_pa = <span class="string">&#x27;./data/1.jpg&#x27;</span></span><br><span class="line">    client = Client((host, port))</span><br><span class="line">    mode = <span class="string">&#x27;video&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;image&#x27;</span>:</span><br><span class="line">        read_img = cv2.imread(img_pa)</span><br><span class="line">        image_send(read_img)</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">&#x27;images&#x27;</span>:</span><br><span class="line">        read_images_send(img_file)</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">&#x27;video&#x27;</span>:</span><br><span class="line">        read_video_send(<span class="string">&#x27;./video/1.mp4&#x27;</span>)</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">connect_send</span>(<span class="params">host, port, lib, det</span>):</span><br><span class="line">    server_sock = Listener((host, port))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Connecting... ...&quot;</span>)</span><br><span class="line">    sock = server_sock.accept()</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            received_bytes = sock.recv()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            received_bytes = <span class="literal">None</span></span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line">        <span class="keyword">if</span> received_bytes <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 不能是not received，否则传视频有问题</span></span><br><span class="line">            server_sock.close()</span><br><span class="line">            sock.close()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Client&#x27;s data is empty !!!&quot;</span>)</span><br><span class="line">            server_sock = Listener((host, port))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Reset Sever&quot;</span>)</span><br><span class="line">            sock = server_sock.accept()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># bytes to list to cv</span></span><br><span class="line">            img_dict = pickle.loads(received_bytes)</span><br><span class="line">            img_dict[<span class="string">&#x27;image&#x27;</span>] = cv2.imdecode(img_dict[<span class="string">&#x27;image&#x27;</span>], cv2.IMREAD_COLOR)</span><br><span class="line">            <span class="comment"># detect one image</span></span><br><span class="line">            det_dict = detect_img(img_dict, lib, det, <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># send result to client</span></span><br><span class="line">            content = pickle.dumps(det_dict)</span><br><span class="line">            sock.send(content)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 两台设备用网线通信</title>
      <link href="/2022/12/15/Linux%20%E4%B8%A4%E5%8F%B0%E8%AE%BE%E5%A4%87%E7%94%A8%E7%BD%91%E7%BA%BF%E9%80%9A%E4%BF%A1-linux-two-device-directly-communicate/"/>
      <url>/2022/12/15/Linux%20%E4%B8%A4%E5%8F%B0%E8%AE%BE%E5%A4%87%E7%94%A8%E7%BD%91%E7%BA%BF%E9%80%9A%E4%BF%A1-linux-two-device-directly-communicate/</url>
      
        <content type="html"><![CDATA[<h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>项目需求用Ubuntu和Debian互相通信，传输数据<br>参考链接：<a href="https://blog.51cto.com/u_15315240/3202599">Ubuntu通过修改配置文件进行网络配置</a>、<a href="https://blog.51cto.com/yhd2011/732156">linux 双机直连设置</a></p><h2 id="物理连接"><a href="#物理连接" class="headerlink" title="物理连接"></a>物理连接</h2><p>首先当然是用网线将两台设备连接起来，用的是本地接口</p><h2 id="修改Ubuntu的ip地址"><a href="#修改Ubuntu的ip地址" class="headerlink" title="修改Ubuntu的ip地址"></a>修改Ubuntu的ip地址</h2><ol><li>此处先在终端（Ubuntu快捷键ctrl+alt+t）<strong>ifconfig</strong>查看当前ip地址<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2022/12/20221215194637.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="2022-12-01 10-05-31 的屏幕截图.png"></li></ol><ul><li>此处如果没有配置enp4s0的话 就不会出现inet 192.168.0.1这些东西，如果配置过，则会显示，那么只需要配置另一台Linux设备处在统一网段下即可。</li><li>此外有些设备可能不叫enp4s0,只要看到e开头的就是本地网络，即插网线的地方，或者Google冒号前的意思。</li></ul><ol start="2"><li>然后终端输入<strong>sudo vim &#x2F;etc&#x2F;network&#x2F;interfaces</strong></li></ol><p>摁i进入insert模式，新加内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto enp4s0</span><br><span class="line">iface enp4s0 inet static</span><br><span class="line">address 192.168.0.1</span><br><span class="line">netmask  255.255.255.0</span><br><span class="line">gateway  192.168.0.1</span><br></pre></td></tr></table></figure><p>其中enp4s0 换成你的设备名字，如eth0；其他部分懂网络的任意设置，跟我一样小白的直接复制粘贴<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2022/12/20221215194637-1.jpg?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="1.jpg"><br>摁esc退出编辑模式，输入:wq 进行写入退出</p><h2 id="修改Debian的ip地址"><a href="#修改Debian的ip地址" class="headerlink" title="修改Debian的ip地址"></a>修改Debian的ip地址</h2><p><a href="https://blog.csdn.net/weixin_45784720/article/details/109441084">debian 10 静态ip配置</a><br>注意其中的addr需要设置为192.168.0.2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 192.168.0.2</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.0.1  # 这个好像没什么关系 网关我也忘了什么意思了</span><br></pre></td></tr></table></figure><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2022/12/20221215194637-2.jpg?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="1.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv提高摄像头分辨率时，无法打开摄像头</title>
      <link href="/2022/11/16/opencv%E6%8F%90%E9%AB%98%E6%91%84%E5%83%8F%E5%A4%B4%E5%88%86%E8%BE%A8%E7%8E%87%E6%97%B6%EF%BC%8C%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E6%91%84%E5%83%8F%E5%A4%B4-opencv-set-high-resolution-cant-open-camera/"/>
      <url>/2022/11/16/opencv%E6%8F%90%E9%AB%98%E6%91%84%E5%83%8F%E5%A4%B4%E5%88%86%E8%BE%A8%E7%8E%87%E6%97%B6%EF%BC%8C%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E6%91%84%E5%83%8F%E5%A4%B4-opencv-set-high-resolution-cant-open-camera/</url>
      
        <content type="html"><![CDATA[<p>前言<br>本文环境是win7，opencv-python，有两个摄像头设备<br>参考链接：</p><ul><li><a href="https://stackoverflow.com/questions/19448078/python-opencv-access-webcam-maximum-resolution">万能的StackOverflow-1</a></li><li><a href="https://stackoverflow.com/questions/29664399/capturing-video-from-two-cameras-in-opencv-at-once">万能的StackOverflow-2</a></li></ul><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>win7设备上需要调高摄像头分辨率，有两个摄像头，一个固定一个usb，但是只能控制在640 x 480，才能两个都能使用，否则调整随机调整摄像头分辨率两个都无法点亮。并且在win10使用单个摄像头，修改为3000 x 2000 输出的图片分辨率可以直接自适应为2048 x 1536，可以点亮摄像头。</p><h2 id="解决办法一"><a href="#解决办法一" class="headerlink" title="解决办法一"></a>解决办法一</h2><p>因为要对程序做迁移，但是在win10上可以直接任意设置分辨率来时opencv自适应摄像头最大分辨率，但是在win7无法实现，所以设定分辨率为固定值</p><ul><li>640 x 480</li><li>800 x 600</li><li>1024 x 768</li><li>1280 x 960</li><li>1920 x 1080</li><li>2048 x 1536</li><li>…..</li><li>注意越大分辨率需求的算力越大，以及有些分辨率可能不是通用，可以多试试</li><li>或者在代码上多设置几个大整数，然后get CV_CAP_PROP_FRAME_WIDTH，输出看一下，摄像头的分辨率是多少<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Frame default resolution: (&quot;</span> + <span class="built_in">str</span>(cap.get(cv.CV_CAP_PROP_FRAME_WIDTH)) + <span class="string">&quot;; &quot;</span> + <span class="built_in">str</span>(cap.get(cv.CV_CAP_PROP_FRAME_HEIGHT)) + <span class="string">&quot;)&quot;</span>)</span><br><span class="line">cap.<span class="built_in">set</span>(cv.CV_CAP_PROP_FRAME_WIDTH, <span class="number">800</span>)</span><br><span class="line">cap.<span class="built_in">set</span>(cv.CV_CAP_PROP_FRAME_HEIGHT, <span class="number">600</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="解决办法二"><a href="#解决办法二" class="headerlink" title="解决办法二"></a>解决办法二</h2><p>未经测试，就是有多个摄像头设备的时候，占用一个总线，所以导致冲突了，多添加一个usb card（我也不知道是啥，可能是usb接口）<br><a href="https://stackoverflow.com/a/29702444">https://stackoverflow.com/a/29702444</a></p>]]></content>
      
      
      <categories>
          
          <category> 问题集锦 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模-数据分析题</title>
      <link href="/2022/10/16/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E9%A2%98-data-analysis/"/>
      <url>/2022/10/16/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E9%A2%98-data-analysis/</url>
      
        <content type="html"><![CDATA[<p>仅做参考用，今年建模赛前做完这个代码后，自觉信心满满，比完赛后直接裂开，希望能拿个国三吧!o(╥﹏╥)o。<br>11&#x2F;26 为什么还没公布成绩，哭死，貌似还有好几个星期<br><a href="https://github.com/Z-timer/MathModel">github</a></p><h2 id="数据查看"><a href="#数据查看" class="headerlink" title="数据查看"></a>数据查看</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pandas_profiling <span class="keyword">import</span> ProfileReport</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 超慢 先运行这个</span></span><br><span class="line">os.chdir(<span class="string">r&#x27;C:\Users\Desktop\math&#x27;</span>)</span><br><span class="line">file_name = <span class="string">&#x27;Molecular_Descriptor.xlsx&#x27;</span></span><br><span class="line">sheet_name = <span class="string">&#x27;training&#x27;</span></span><br><span class="line">table = pd.read_excel(file_name, sheet_name, header=[<span class="number">0</span>])  <span class="comment"># 如果有多个列名 方便起见只取一个</span></span><br><span class="line">profile = table.profile_report(title=<span class="string">&quot;data_profile&quot;</span>)</span><br><span class="line">profile.to_file(output_file=<span class="string">&quot;analysis.html&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导包略过，自行github看</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">describeData</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="built_in">print</span>(data.dtypes)  <span class="comment"># 如果是object需要转换</span></span><br><span class="line">    <span class="comment"># for col in data:  # object to numeric if is numeric</span></span><br><span class="line">    <span class="comment">#     if isinstance(data[col][0], int) or isinstance(data[col][0], float):</span></span><br><span class="line">    <span class="comment">#         data[col] = pd.to_numeric(data[col], errors=&#x27;coerce&#x27;)</span></span><br><span class="line">    <span class="comment"># print(&#x27;数据类型：&#x27;, data.dtypes)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;前三行数据：&#x27;</span>, data.iloc[:<span class="number">3</span>, :<span class="number">5</span>])  <span class="comment"># 看看是否导入正确</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;样本情况&#x27;</span>, data.describe())  <span class="comment"># 查看样本分布</span></span><br><span class="line">    sns.displot(data[<span class="string">&#x27;土壤蒸发量(mm)&#x27;</span>], kde=<span class="literal">True</span>)  <span class="comment"># 直方图折线图可视  !! 注意修改成某个列名</span></span><br><span class="line">    plt.savefig(<span class="string">&#x27;picture/describe.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    data = pd.concat([data[<span class="string">&#x27;10cm湿度(kg/m2)&#x27;</span>], data[<span class="string">&#x27;土壤蒸发量(mm)&#x27;</span>]], axis=<span class="number">1</span>)  <span class="comment"># 1         !! 注意修改成某个列名</span></span><br><span class="line">    data.plot.scatter(x=<span class="string">&#x27;10cm湿度(kg/m2)&#x27;</span>, y=<span class="string">&#x27;土壤蒸发量(mm)&#x27;</span>, ylim=(<span class="number">0</span>, <span class="number">1666</span>), c=<span class="string">&#x27;c&#x27;</span>, cmap=<span class="string">&#x27;coolwarm&#x27;</span>)</span><br><span class="line">    <span class="comment"># data = pd.concat([data[&#x27;ALogp2&#x27;], data[&#x27;AMR&#x27;]], axis=1)  # 1         !! 可选第二组对比 看它们之间的相关性 线性非线性</span></span><br><span class="line">    <span class="comment"># data.plot.scatter(x=&#x27;ALogp2&#x27;, y=&#x27;AMR&#x27;, ylim=(0, 1666), c=&#x27;c&#x27;, cmap=&#x27;coolwarm&#x27;)</span></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">processNull</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="comment"># https://blog.51cto.com/liguodong/3702149</span></span><br><span class="line">    <span class="comment"># 1. 输出缺失率表格 建议结果放到excel，图好看</span></span><br><span class="line">    missing = data.isnull().<span class="built_in">sum</span>().reset_index().rename(columns=&#123;<span class="number">0</span>: <span class="string">&#x27;missNum&#x27;</span>&#125;)[<span class="number">1</span>:]</span><br><span class="line">    missing[<span class="string">&#x27;missRate&#x27;</span>] = missing[<span class="string">&#x27;missNum&#x27;</span>] / data.shape[<span class="number">0</span>]  <span class="comment"># 计算缺失比例</span></span><br><span class="line">    miss_analogy = missing.sort_values(by=<span class="string">&#x27;missRate&#x27;</span>, ascending=<span class="literal">False</span>)  <span class="comment"># 升序</span></span><br><span class="line">    miss_analogy.index = <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(miss_analogy) + <span class="number">1</span>)  <span class="comment"># 排序后重新修改index</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;前八变量的缺失率&#x27;</span>, miss_analogy[:<span class="number">5</span>])  <span class="comment"># 输出前8个            ！！ 解除注释</span></span><br><span class="line">    <span class="comment"># 2. 输出缺失率图 取前8个遍历</span></span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.bar(np.arange(<span class="number">5</span>), <span class="built_in">list</span>(miss_analogy[<span class="string">&#x27;missRate&#x27;</span>].values)[:<span class="number">5</span>],</span><br><span class="line">            color=[<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;steelblue&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>])</span><br><span class="line">    plt.title(<span class="string">&#x27;变量缺失率直方图&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;变量名&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;缺失率&#x27;</span>)</span><br><span class="line">    plt.xticks(np.arange(<span class="number">5</span>), <span class="built_in">list</span>(miss_analogy[<span class="string">&#x27;index&#x27;</span>][:<span class="number">5</span>]))</span><br><span class="line">    <span class="comment"># plt.xticks(rotation=90)</span></span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">list</span>(miss_analogy[<span class="string">&#x27;missRate&#x27;</span>].values[:<span class="number">5</span>])):</span><br><span class="line">        plt.text(x, y + <span class="number">0.02</span>, <span class="string">&#x27;&#123;:.2%&#125;&#x27;</span>.<span class="built_in">format</span>(y), ha=<span class="string">&#x27;center&#x27;</span>)  <span class="comment">#图片加text</span></span><br><span class="line">        plt.ylim([<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 处理缺失值  删除缺失量大于阈值0.8</span></span><br><span class="line">    orig_col = data.columns  <span class="comment"># 设计删除列的操作时可以发现删除了什么列</span></span><br><span class="line">    del_col = []</span><br><span class="line">    data = data.dropna(axis=<span class="number">1</span>, how=<span class="string">&#x27;any&#x27;</span>, thresh=data.shape[<span class="number">0</span>] * <span class="number">0.8</span>)  <span class="comment"># 删除列            ！！ 解除注释</span></span><br><span class="line">    <span class="comment"># data = data.dropna(axis=0, how=&#x27;any&#x27;, thresh=data.shape[1]*0.8)  # 删除行</span></span><br><span class="line">    data.reset_index(drop=<span class="literal">True</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    after_col = data.columns</span><br><span class="line">    del_col.append(<span class="built_in">list</span>(<span class="built_in">set</span>(orig_col).difference(<span class="built_in">set</span>(after_col))))  <span class="comment"># https://cloud.tencent.com/developer/article/1705131</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;删除缺失量大于阈值0.8的变量：&#x27;</span>, del_col)</span><br><span class="line">    plt.savefig(<span class="string">&#x27;picture/nullV.jpg&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">interpolateData</span>(<span class="params">data</span>):  <span class="comment"># 填充缺失值</span></span><br><span class="line">    fig, axes = plt.subplots(figsize=(<span class="number">8</span>, <span class="number">4</span>), sharex=<span class="string">&#x27;all&#x27;</span>)</span><br><span class="line">    axes.plot(data[<span class="string">&#x27;积雪深度(mm)&#x27;</span>], label=<span class="string">&#x27;Original Data&#x27;</span>, marker=<span class="string">&#x27;*&#x27;</span>, markerfacecolor=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">    <span class="comment"># 1 直接填充</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">     均值适用于定量数据 身高 年龄 mean()</span></span><br><span class="line"><span class="string">     中位数 正态分布 median()</span></span><br><span class="line"><span class="string">     众数适用于定性数据 性别 文化程度 data[&#x27;S-ZORB.CAL_H2.PV&#x27;].mode()[0]</span></span><br><span class="line"><span class="string">     method=&#x27;pad/bfill&#x27; 取前/后数据填充</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># data.fillna(&#123;&#x27;S-ZORB.CAL_H2.PV&#x27;: data[&#x27;S-ZORB.CAL_H2.PV&#x27;].mean()&#125;, inplace=True)  # 只修改一列</span></span><br><span class="line">    <span class="comment"># data.fillna(data.mean(), inplace=True)  #           ！！ 选 直接填充 解除注释</span></span><br><span class="line">    <span class="comment"># 2 插值法</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       ‘nearest’, ‘zero’, ‘slinear’, ‘quadratic’, ‘cubic’</span></span><br><span class="line"><span class="string">     1.如果你的数据增长速率越来越快，可以选择 method=&#x27;quadratic&#x27;二次插值。</span></span><br><span class="line"><span class="string">     2.如果数据集呈现出累计分布的样子，推荐选择 method=&#x27;pchip&#x27;。</span></span><br><span class="line"><span class="string">     3.如果需要填补缺省值，以平滑绘图为目标，推荐选择 method=&#x27;akima&#x27;。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    data.interpolate(method=<span class="string">&#x27;quadratic&#x27;</span>, inplace=<span class="literal">True</span>)  <span class="comment"># ................！！ 解除注释</span></span><br><span class="line">    axes.plot(data[<span class="string">&#x27;积雪深度(mm)&#x27;</span>], <span class="string">&#x27;r--&#x27;</span>, label=<span class="string">&#x27;Filled Data&#x27;</span>, marker=<span class="string">&#x27;h&#x27;</span>, markerfacecolor=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">    axes.legend([<span class="string">&#x27;初始值&#x27;</span>, <span class="string">&#x27;拟合值&#x27;</span>], loc=<span class="string">&quot;upper right&quot;</span>)</span><br><span class="line">    plt.show()  <span class="comment"># ........................！！ 解除注释</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">processZero</span>(<span class="params">data</span>):  <span class="comment"># 删除0值大于80%的列/行  Bijlsma 提出的 80%准则</span></span><br><span class="line">    zeros = []</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> data:</span><br><span class="line">        flat = data[c].to_numpy()</span><br><span class="line">        cnt = np.where(flat, <span class="number">0</span>, <span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> np.<span class="built_in">sum</span>(cnt) &gt; <span class="number">0.2</span> * data.shape[<span class="number">0</span>]:  <span class="comment"># 获取0值过多的   列</span></span><br><span class="line">            zeros.append(c)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;zeros error(&#123;&#125;): &#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(zeros)), zeros)</span><br><span class="line">    error = data[zeros[<span class="number">0</span>]][data[zeros[<span class="number">0</span>]] == <span class="number">0</span>]</span><br><span class="line">    data_c = data[zeros[<span class="number">0</span>]][data[zeros[<span class="number">0</span>]] != <span class="number">0</span>]</span><br><span class="line">    fig, ax2 = plt.subplots(figsize=(<span class="number">15</span>, <span class="number">9</span>))</span><br><span class="line"></span><br><span class="line">    plt.scatter(data_c.index, data_c.values, color=<span class="string">&#x27;g&#x27;</span>, alpha=<span class="number">0.6</span>, label=<span class="string">&#x27;正常值&#x27;</span>)</span><br><span class="line">    plt.scatter(error.index, error.values, color=<span class="string">&#x27;r&#x27;</span>, alpha=<span class="number">0.8</span>, label=<span class="string">&#x27;0值&#x27;</span>)</span><br><span class="line">    ax2.set_xlabel(<span class="string">&#x27;下标&#x27;</span>)</span><br><span class="line">    ax2.set_ylabel(<span class="string">&#x27;值&#x27;</span>)</span><br><span class="line">    ax2.legend()</span><br><span class="line">    plt.show()</span><br><span class="line">    data.drop(columns=zeros, inplace=<span class="literal">True</span>)</span><br><span class="line">    plt.savefig(<span class="string">&#x27;picture/zeroV.jpg&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process3sigma</span>(<span class="params">data</span>):  <span class="comment"># 删除异常值 3sigma法</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    需满足高斯分布，可假设为高斯分布强行用</span></span><br><span class="line"><span class="string">    1. 可以删除每列异常值大于阈值并且超过3sigma范围，对少于阈值但超过范围的进行赋值 没实现</span></span><br><span class="line"><span class="string">    2. 可以直接删除超过3sigma范围</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    sigma, sigma_cnt = [], [<span class="number">0</span>] * data.shape[<span class="number">0</span>]</span><br><span class="line">    delrow_thres = <span class="number">1</span>  <span class="comment"># 行异常值阈值</span></span><br><span class="line">    delcol_thres = <span class="number">100</span>  <span class="comment"># 列异常值阈值</span></span><br><span class="line">    idx = []</span><br><span class="line">    sig = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> data:</span><br><span class="line">        flat = data[c].to_numpy()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            mean = np.mean(flat)</span><br><span class="line">            s = np.std(flat, ddof=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(data.shape[<span class="number">0</span>]):  <span class="comment"># 检查当前列的3sigma</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(flat[r] - mean) &gt; s * <span class="number">3</span>:</span><br><span class="line">                sigma_cnt[r] += <span class="number">1</span></span><br><span class="line">                flag += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                idx.append(r)</span><br><span class="line">        <span class="keyword">if</span> flag &gt; delrow_thres:  <span class="comment">#</span></span><br><span class="line">            sig = <span class="number">3</span> * s</span><br><span class="line">            sigma.append(c)</span><br><span class="line">    <span class="comment"># print(&#x27;del 3sigma(&#123;0&#125;) column(&#123;1&#125;): &#x27;.format(round(sig, 3), len(sigma)), sigma)</span></span><br><span class="line">    <span class="comment"># if len(sigma) &gt; 0:</span></span><br><span class="line">    <span class="comment">#     draw_3sigma(data[sigma[0]])</span></span><br><span class="line">    <span class="comment"># draw_3sigma(data[&#x27;干重&#x27;])</span></span><br><span class="line">    <span class="comment"># data.drop(columns=sigma, inplace=True)</span></span><br><span class="line">    <span class="comment"># data.reset_index(drop=True)</span></span><br><span class="line">    <span class="comment"># 删除行</span></span><br><span class="line">    sigma_cntnp = np.array(sigma_cnt)</span><br><span class="line">    where = np.where(sigma_cntnp &gt; <span class="number">0</span>)</span><br><span class="line">    a = np.array(<span class="built_in">list</span>(where))</span><br><span class="line">    a = a[<span class="number">0</span>]  <span class="comment"># necessary？</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;del 3sigma row: &#x27;</span>, <span class="built_in">len</span>(a))</span><br><span class="line">    data.drop(index=a, inplace=<span class="literal">True</span>)</span><br><span class="line">    data.reset_index(drop=<span class="literal">True</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> data, idx</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">processMaxMin</span>(<span class="params">data</span>):</span><br><span class="line">    scope = pd.read_excel(<span class="string">&#x27;附件四：354个操作变量信息.xlsx&#x27;</span>, usecols=[<span class="number">1</span>, <span class="number">3</span>])  <span class="comment"># 注意修改</span></span><br><span class="line">    scope = scope.to_numpy()</span><br><span class="line">    scope = &#123;n[<span class="number">0</span>]: n[<span class="number">1</span>].split(<span class="string">&#x27;-&#x27;</span>) <span class="keyword">for</span> n <span class="keyword">in</span> scope&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> scope.items():</span><br><span class="line">        mm = []</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> v:</span><br><span class="line">            <span class="keyword">if</span> value == <span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> value == <span class="string">&#x27;（&#x27;</span> <span class="keyword">or</span> value == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                mm.append(<span class="built_in">float</span>(value) <span class="keyword">if</span> flag <span class="keyword">else</span> -<span class="built_in">float</span>(value))</span><br><span class="line">            <span class="keyword">except</span> ValueError:</span><br><span class="line">                value = re.findall(<span class="string">r&#x27;\d+\.?\d*&#x27;</span>, value)[<span class="number">0</span>]  <span class="comment"># 找浮点数</span></span><br><span class="line">                mm.append(<span class="built_in">float</span>(value) <span class="keyword">if</span> flag <span class="keyword">else</span> -<span class="built_in">float</span>(value))</span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> mm[<span class="number">0</span>] &gt; mm[<span class="number">1</span>]:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;数据error&#x27;</span>)</span><br><span class="line">        scope[k] = mm</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> scope.keys():</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> data[col].index:</span><br><span class="line">            <span class="keyword">if</span> scope[col][<span class="number">0</span>] &gt; data[col][i] <span class="keyword">or</span> data[col][i] &gt; scope[col][<span class="number">1</span>]:  <span class="comment"># 删除最大最小不对的 行/样本</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;minmax error&#x27;</span>, i, data[col][i], scope[col], col)</span><br><span class="line">                data.drop(index=i, inplace=<span class="literal">True</span>)</span><br><span class="line">    data.reset_index(drop=<span class="literal">True</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 1. 读取数据</span></span><br><span class="line">    <span class="comment"># file_name = r&#x27;C:\Users\Desktop\2022年E题\数据集\监测点数据\附件15：草原轮牧放牧样地群落结构监测数据集（2016年6月-2020年9&#x27; \</span></span><br><span class="line">    <span class="comment">#             r&#x27;月）。/内蒙古自治区锡林郭勒盟典型草原轮牧放牧样地群落结构监测数据集（201.xlsx &#x27;</span></span><br><span class="line">    file_name = <span class="string">&#x27;data/result.xlsx&#x27;</span></span><br><span class="line">    sheet_name = <span class="string">&#x27;Sheet1&#x27;</span>  <span class="comment"># 注意修改</span></span><br><span class="line">    table = pd.read_excel(file_name, sheet_name, header=[<span class="number">0</span>])  <span class="comment"># 如果有多个列名 方便起见只取一个</span></span><br><span class="line"><span class="comment"># 2. 划分数据 if need</span></span><br><span class="line">    <span class="comment"># 注意索引还是原数据的索引 https://stackoverflow.com/questions/71679582/0-is-not-in-range-in-pandas</span></span><br><span class="line">    sample285 = table[<span class="number">1</span>:<span class="number">41</span>]</span><br><span class="line">    sample285.reset_index(drop=<span class="literal">True</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    sample285 = sample285.copy()  <span class="comment"># 防止SettingWithCopyWarning</span></span><br><span class="line">    sample310 = table[<span class="number">42</span>:]</span><br><span class="line">    sample310.reset_index(drop=<span class="literal">True</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    data = table.iloc[:, <span class="number">2</span>:]  <span class="comment"># 排除年月</span></span><br><span class="line">    <span class="comment"># 3. 查看数据情况</span></span><br><span class="line">    <span class="comment"># describeData(data)</span></span><br><span class="line">    <span class="comment"># 4. 处理缺失值</span></span><br><span class="line">    data = processNull(data)</span><br><span class="line">    data = processZero(data)</span><br><span class="line">    data, idx = process3sigma(data)</span><br><span class="line">    <span class="comment"># table = table.iloc[idx, 0]</span></span><br><span class="line">    <span class="comment"># data = processMaxMin(data)</span></span><br><span class="line">    data = interpolateData(data)</span><br><span class="line">    <span class="comment"># print(&#x27;删除前变量个数&#x27;, len(table.columns))</span></span><br><span class="line">    <span class="comment"># data.index = table.iloc[:, 0]  # 将string列重新放回</span></span><br><span class="line">    <span class="comment"># print(&#x27;删除后变量个数&#x27;, len(data.columns))</span></span><br><span class="line">    data.to_excel(<span class="string">&#x27;Preprocess/pre_data.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">low_var_filter</span>(<span class="params">data, names</span>):  <span class="comment"># 低方差滤波</span></span><br><span class="line">    <span class="comment"># 人工版</span></span><br><span class="line">    <span class="comment"># var = data.var()</span></span><br><span class="line">    <span class="comment"># col = var.index</span></span><br><span class="line">    <span class="comment"># variable = []</span></span><br><span class="line">    <span class="comment"># for i in range(len(var)):</span></span><br><span class="line">    <span class="comment">#     if var[col[i]] &lt; 1:</span></span><br><span class="line">    <span class="comment">#         variable.append(col[[i]].format()[0])</span></span><br><span class="line">    <span class="comment"># print(list(variable), var[variable[0]])</span></span><br><span class="line">    <span class="comment"># data.drop(columns=variable, axis=1, inplace=True)</span></span><br><span class="line"></span><br><span class="line">    data = data[:, <span class="number">1</span>:]  <span class="comment"># 排除time列</span></span><br><span class="line">    data = pd.DataFrame(data, columns=names[<span class="number">1</span>:])</span><br><span class="line">    <span class="comment"># 智能版</span></span><br><span class="line">    orig_col = data.columns</span><br><span class="line">    selector = VarianceThreshold(threshold=<span class="number">1</span>)  <span class="comment"># 阈值为&lt;1</span></span><br><span class="line">    selector.fit(data)</span><br><span class="line">    after_col = np.array(data.columns.<span class="built_in">format</span>())[selector.get_support()]  <span class="comment"># 获得删除后列</span></span><br><span class="line">    del_col = <span class="built_in">list</span>(<span class="built_in">set</span>(orig_col).difference(<span class="built_in">set</span>(after_col)))  <span class="comment"># 获得删除列</span></span><br><span class="line">    data = selector.fit_transform(data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;低方差滤波删除列：&#x27;</span>, del_col)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;低方差删除后的矩阵shape：&#x27;</span>, data.shape)</span><br><span class="line">    <span class="comment"># data = pd.DataFrame(data, columns=after_col)</span></span><br><span class="line">    <span class="comment"># print(data[:5])</span></span><br><span class="line">    <span class="keyword">return</span> data, after_col</span><br><span class="line">    <span class="comment"># data.to_excel(&#x27;new_data.xlsx&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">MICSelect</span>(<span class="params">data, target, feature_name, k</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mic</span>(<span class="params">x, y</span>):</span><br><span class="line">        m = MINE()</span><br><span class="line">        m.compute_score(x, y)</span><br><span class="line">        <span class="keyword">return</span> m.mic(), <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># n = data.shape[1]  # 两两比较 https://zhuanlan.zhihu.com/p/53092905</span></span><br><span class="line">    <span class="comment"># result = np.zeros([n, n])</span></span><br><span class="line">    <span class="comment"># mine = MINE(alpha=0.6, c=15)</span></span><br><span class="line">    <span class="comment"># for i in range(n):</span></span><br><span class="line">    <span class="comment">#     mine.compute_score(data[:, i], target)</span></span><br><span class="line">    <span class="comment">#     result[i, 0] = round(mine.mic(), 2)</span></span><br><span class="line">    <span class="comment">#     result[0, i] = round(mine.mic(), 2)</span></span><br><span class="line">    <span class="comment"># mic = pd.DataFrame(result)</span></span><br><span class="line">    SKB = SelectKBest(<span class="keyword">lambda</span> X, Y: <span class="built_in">tuple</span>(<span class="built_in">map</span>(<span class="built_in">tuple</span>, np.array(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: mic(x, Y), X.T))).T)),</span><br><span class="line">                      k=k)  <span class="comment"># 选择前k个最好比需要的多20个 https://www.cnblogs.com/nxf-rabbit75/p/11122415.html#auto-id-15</span></span><br><span class="line">    SKB.fit_transform(data, target)</span><br><span class="line">    feature_index = SKB.get_support(<span class="literal">True</span>)</span><br><span class="line">    mic_scores = SKB.scores_</span><br><span class="line">    mic_results = [(feature_name[i], mic_scores[i]) <span class="keyword">for</span> i <span class="keyword">in</span> feature_index]</span><br><span class="line">    sorted_data = <span class="built_in">sorted</span>(mic_results, key=itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">    pd_data = pd.DataFrame(sorted_data, columns=[<span class="string">&#x27;变量名&#x27;</span>, <span class="string">&#x27;重要性度&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;MICDataframe: &#x27;</span>, pd_data.iloc[:<span class="number">5</span>])</span><br><span class="line">    pd_data.to_excel(<span class="string">&#x27;FeatureSelect/MICData.xlsx&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> pd_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dcorSelect</span>(<span class="params">data, target, feature_name, k</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Dcor</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> dcor.distance_correlation(x, y), <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    SKB = SelectKBest(<span class="keyword">lambda</span> X, Y: <span class="built_in">tuple</span>(<span class="built_in">map</span>(<span class="built_in">tuple</span>, np.array(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: Dcor(x, Y), X.T))).T)),</span><br><span class="line">                      k=k)  <span class="comment"># 前k个</span></span><br><span class="line">    SKB.fit_transform(data, target)</span><br><span class="line">    feature_index = SKB.get_support(<span class="literal">True</span>)</span><br><span class="line">    mic_scores = SKB.scores_</span><br><span class="line"></span><br><span class="line">    mic_results = [(feature_name[i], mic_scores[i]) <span class="keyword">for</span> i <span class="keyword">in</span> feature_index]</span><br><span class="line">    sorted_data = <span class="built_in">sorted</span>(mic_results, key=itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">    pd_data = pd.DataFrame(sorted_data, columns=[<span class="string">&#x27;变量名&#x27;</span>, <span class="string">&#x27;重要性度&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;DcorDataframe: &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(pd_data.iloc[:<span class="number">5</span>])</span><br><span class="line">    pd_data.to_excel(<span class="string">&#x27;FeatureSelect/DcorData.xlsx&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> pd_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">LassoSelect</span>(<span class="params">data, target, feature_name, k</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    存在一组高度相关的特征时，Lasso回归方法倾向于选择其中的一个特征</span></span><br><span class="line"><span class="string">    具有高绝对值的数最重要</span></span><br><span class="line"><span class="string">    https://blog.csdn.net/Kyrie_Irving/article/details/101197360</span></span><br><span class="line"><span class="string">    https://blog.51cto.com/u_14467853/5438127</span></span><br><span class="line"><span class="string">    http://scikit-learn.org.cn/view/199.html</span></span><br><span class="line"><span class="string">    https://ask.hellobi.com/blog/lsxxx2011/10581</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    data = pd.DataFrame(data, columns=feature_name)</span><br><span class="line">    alpha_lasso = <span class="number">10</span> ** np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用lassoCV找出最佳lambda值</span></span><br><span class="line">    model = make_pipeline(StandardScaler(with_mean=<span class="literal">False</span>), LassoCV(alphas=alpha_lasso, cv=<span class="number">10</span>, max_iter=<span class="number">10000</span>))</span><br><span class="line">    model.fit(data, target)</span><br><span class="line">    lasso_best_alpha = model[<span class="string">&#x27;lassocv&#x27;</span>].alpha_  <span class="comment"># 取出最佳的lambda值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;lasso回归最佳alpha值&#x27;</span>, lasso_best_alpha)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据不同的lambda画出变量情况 可以首先寻找最优变量 放该图 然后放下面的最重要变量图</span></span><br><span class="line">    <span class="comment"># lasso = Lasso()</span></span><br><span class="line">    <span class="comment"># coefs_lasso = []</span></span><br><span class="line">    <span class="comment"># for i in alpha_lasso:</span></span><br><span class="line">    <span class="comment">#     lasso.set_params(alpha=i)</span></span><br><span class="line">    <span class="comment">#     lasso.fit(data, target)</span></span><br><span class="line">    <span class="comment">#     coefs_lasso.append(lasso.coef_)</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># drawPlot(alpha_lasso, coefs_lasso, title=&#x27;Lasso回归系数和alpha系数的关系&#x27;, xlabel=&#x27;α值&#x27;, ylabel=&#x27;各变量比例系数&#x27;,</span></span><br><span class="line">    <span class="comment">#          columns=feature_name)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 直接代入最佳值</span></span><br><span class="line">    lasso = Lasso(alpha=lasso_best_alpha)</span><br><span class="line">    model_lasso = lasso.fit(data, target)</span><br><span class="line">    coef = pd.Series(model_lasso.coef_, index=data.columns)</span><br><span class="line">    <span class="comment"># print(coef[coef != 0].abs().sort_values(ascending=False)[:10])</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Lasso picked &quot;</span> + <span class="built_in">str</span>(<span class="built_in">sum</span>(coef != <span class="number">0</span>)) + <span class="string">&quot; variables and eliminated the other &quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">        <span class="built_in">sum</span>(coef == <span class="number">0</span>)) + <span class="string">&quot; variables&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    sorted_data = <span class="built_in">sorted</span>(<span class="built_in">zip</span>(feature_name, coef.values), reverse=<span class="literal">True</span>, key=itemgetter(<span class="number">1</span>))[:k]</span><br><span class="line">    pd_data = pd.DataFrame(sorted_data, columns=[<span class="string">&#x27;变量名&#x27;</span>, <span class="string">&#x27;重要性度&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;LassoDataframe: &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(pd_data.iloc[:<span class="number">5</span>])</span><br><span class="line">    pd_data.to_excel(<span class="string">&#x27;FeatureSelect/LassoData.xlsx&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> pd_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># useless L2正则化（岭回归）可以用来做特征选择吗？</span></span><br><span class="line"><span class="comment"># https://www.zhihu.com/question/288362034/answer/463287541</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">RidgeSelect</span>(<span class="params">data, target, feature_name</span>):</span><br><span class="line">    data = data[:, <span class="number">1</span>:]  <span class="comment"># 排除time列</span></span><br><span class="line">    data = pd.DataFrame(data, columns=feature_name[<span class="number">1</span>:])</span><br><span class="line">    alpha_ridge = <span class="number">10</span> ** np.linspace(<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据不同的lambda画出变量情况 可以首先寻找最优变量 放该图 然后放下面的最重要变量图</span></span><br><span class="line">    ridge = Ridge()</span><br><span class="line">    coefs_ridge = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> alpha_ridge:</span><br><span class="line">        ridge.set_params(alpha=i)</span><br><span class="line">        ridge.fit(data, target)</span><br><span class="line">        coefs_ridge.append(ridge.coef_)</span><br><span class="line">    <span class="comment"># https://stackoverflow.com/questions/58393378/why-does-ridge-model-fitting-show-warning-when-power-of-the-denominator-in-the-a</span></span><br><span class="line">    drawPlot(alpha_ridge, coefs_ridge, title=<span class="string">&#x27;Ridge回归系数和alpha系数的关系&#x27;</span>, xlabel=<span class="string">&#x27;α值&#x27;</span>, ylabel=<span class="string">&#x27;各变量比例系数&#x27;</span>,</span><br><span class="line">             columns=feature_name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用lassoCV找出最佳lambda值</span></span><br><span class="line">    <span class="comment"># 样本数比特征数少会报Singular matrix in solving dual problem. Using least-squares solution instead.</span></span><br><span class="line">    model = make_pipeline(StandardScaler(with_mean=<span class="literal">False</span>),</span><br><span class="line">                          RidgeCV(alphas=alpha_ridge, cv=<span class="number">10</span>, scoring=<span class="string">&#x27;neg_mean_squared_error&#x27;</span>))</span><br><span class="line">    model.fit(data, target)</span><br><span class="line">    ridge_best_alpha = model[<span class="string">&#x27;ridgecv&#x27;</span>].alpha_  <span class="comment"># 取出最佳的lambda值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ridge回归最佳alpha值&#x27;</span>, ridge_best_alpha)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 直接代入最佳值</span></span><br><span class="line">    ridge = Ridge(alpha=ridge_best_alpha)</span><br><span class="line">    model_ridge = ridge.fit(data, target)</span><br><span class="line">    coef = pd.Series(model_ridge.coef_, index=data.columns)</span><br><span class="line">    <span class="comment"># print(coef[coef != 0].abs().sort_values(ascending=False)[:10])</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Ridge picked &quot;</span> + <span class="built_in">str</span>(<span class="built_in">sum</span>(coef != <span class="number">0</span>)) + <span class="string">&quot; variables and eliminated the other &quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">        <span class="built_in">sum</span>(coef == <span class="number">0</span>)) + <span class="string">&quot; variables&quot;</span>)</span><br><span class="line">    a = pd.DataFrame()</span><br><span class="line">    a[<span class="string">&#x27;feature&#x27;</span>] = feature_name[:]  <span class="comment"># feature_name[:45]使直方图可以有负值</span></span><br><span class="line">    a[<span class="string">&#x27;importance&#x27;</span>] = coef.values  <span class="comment"># coef.values[:45]使直方图可以有负值</span></span><br><span class="line"></span><br><span class="line">    a = a.sort_values(<span class="string">&#x27;importance&#x27;</span>, ascending=<span class="literal">False</span>)</span><br><span class="line">    a = a[:<span class="number">40</span>]  <span class="comment"># 只显示前40个重要变量 或者注释掉</span></span><br><span class="line">    drawBar(a, typ=<span class="string">&#x27;barh&#x27;</span>, title=<span class="string">&#x27;Ridge模型筛选后重要变量&#x27;</span>)  <span class="comment"># 取前40个变量 title=&#x27;Lasso模型关联度情况&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">RFSelect</span>(<span class="params">data, target, feature_name, k</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    https://www.cnblogs.com/Ann21/p/11722339.html</span></span><br><span class="line"><span class="string">    :param data:</span></span><br><span class="line"><span class="string">    :param target:</span></span><br><span class="line"><span class="string">    :param feature_name:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># py = Pinyin()  # 防止lgbm报错  以下三行仅做记录用 无关RF</span></span><br><span class="line">    <span class="comment"># data = data.rename(columns=lambda x: py.get_pinyin(x))</span></span><br><span class="line">    <span class="comment"># data = data.rename(columns=lambda x: re.sub(&#x27;[^A-Za-z0-9_]+&#x27;, &#x27;&#x27;, x))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># rf = RandomForestRegressor(n_estimators=20, max_depth=4, n_jobs=7)  # 用7个核来跑 加速</span></span><br><span class="line">    <span class="comment"># scores = []</span></span><br><span class="line">    <span class="comment"># for i in range(data.shape[1]):  # 单变量选择 平均精确率减少 计算很慢 太慢了 换台电脑一起跑</span></span><br><span class="line">    <span class="comment">#     score = cross_val_score(rf, data[:, i:i + 1], target, scoring=&quot;r2&quot;,</span></span><br><span class="line">    <span class="comment">#                             cv=ShuffleSplit(len(data)))</span></span><br><span class="line">    <span class="comment">#     scores.append((np.round(np.mean(score), 3), feature_name[i]))</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># keep_fea = sorted(scores, reverse=True)[:40]</span></span><br><span class="line">    <span class="comment"># print(keep_fea)</span></span><br><span class="line">    <span class="comment"># drawBar(keep_fea, typ=&#x27;bar&#x27;)</span></span><br><span class="line"></span><br><span class="line">    rf = RandomForestRegressor(n_estimators=<span class="number">100</span>, n_jobs=<span class="number">7</span>, max_depth=<span class="number">4</span>)</span><br><span class="line">    rf.fit(data, target)</span><br><span class="line">    sorted_data = <span class="built_in">sorted</span>(<span class="built_in">zip</span>(feature_name, <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">round</span>(x, <span class="number">4</span>), rf.feature_importances_)), reverse=<span class="literal">True</span>,</span><br><span class="line">                         key=itemgetter(<span class="number">1</span>))[:k]</span><br><span class="line">    pd_data = pd.DataFrame(sorted_data, columns=[<span class="string">&#x27;变量名&#x27;</span>, <span class="string">&#x27;重要性度&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;RFDataframe: &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(pd_data.iloc[:<span class="number">5</span>])</span><br><span class="line">    pd_data.to_excel(<span class="string">&#x27;FeatureSelect/RFData.xlsx&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> pd_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">RFESelect</span>(<span class="params">data, target, names, k</span>):</span><br><span class="line">    <span class="comment"># https://cloud.tencent.com/developer/article/1081618</span></span><br><span class="line">    <span class="comment"># https://blog.csdn.net/LuohenYJ/article/details/107239001</span></span><br><span class="line">    <span class="comment"># https://machinelearningmastery.com/rfe-feature-selection-in-python/</span></span><br><span class="line">    <span class="comment"># https://www.scikit-yb.org/en/latest/api/model_selection/rfecv.html 可视化 没用到</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rank_to_dict</span>(<span class="params">ranks, names, order=<span class="number">1</span></span>):</span><br><span class="line">        minmax = MinMaxScaler()</span><br><span class="line">        ranks = minmax.fit_transform(order * np.array([ranks]).T).T[<span class="number">0</span>]</span><br><span class="line">        ranks = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">round</span>(x, <span class="number">2</span>), ranks)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">zip</span>(names, ranks)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># model = SVC(kernel=&#x27;linear&#x27;) 好像用不了</span></span><br><span class="line">    <span class="comment"># model = Ridge(alpha=100000, fit_intercept=True, copy_X=True, max_iter=1500, tol=1e-4, solver=&#x27;auto&#x27;)</span></span><br><span class="line">    <span class="comment"># model = LinearRegression()  # Lasso(max_iter=15000, alpha=100, scoring=&#x27;r2&#x27;)</span></span><br><span class="line">    model = DecisionTreeRegressor()  <span class="comment"># 效果意外的好</span></span><br><span class="line">    <span class="comment"># model = Lasso(max_iter=15000, alpha=0.001)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># do a regress task, use the metric R-squared (coefficient of determination)</span></span><br><span class="line">    <span class="comment"># accuracy score is used for classification problems.</span></span><br><span class="line">    <span class="comment"># https://stackoverflow.com/questions/32664717/got-continuous-is-not-supported-error-in-randomforestregressor</span></span><br><span class="line">    <span class="comment"># min_features_to_select 最少保留特征数</span></span><br><span class="line">    rfe = RFECV(estimator=model, step=<span class="number">1</span>, cv=<span class="number">5</span>, min_features_to_select=<span class="number">1</span>)</span><br><span class="line">    rfe.fit_transform(data, target)</span><br><span class="line">    ranks = rank_to_dict(rfe.ranking_, names, order=-<span class="number">1</span>)</span><br><span class="line">    sorted_data = <span class="built_in">sorted</span>(ranks, reverse=<span class="literal">True</span>, key=itemgetter(<span class="number">1</span>))[:k]</span><br><span class="line">    pd_data = pd.DataFrame(sorted_data, columns=[<span class="string">&#x27;变量名&#x27;</span>, <span class="string">&#x27;重要性度&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;RFEDataframe: &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(pd_data.iloc[:<span class="number">5</span>])</span><br><span class="line">    pd_data.to_excel(<span class="string">&#x27;FeatureSelect/RFEData.xlsx&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> pd_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">PCAReduction</span>(<span class="params">X, names, k</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    https://stackoverflow.com/questions/50796024/feature-variable-importance-after-a-pca-analysis</span></span><br><span class="line"><span class="string">    https://cloud.tencent.com/developer/article/1794827</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">    scaler.fit(X)</span><br><span class="line">    X = scaler.transform(X)</span><br><span class="line">    <span class="comment"># pca = PCA(n_components=&#x27;mle&#x27;, svd_solver=&#x27;full&#x27;)  # pca guess the dimension</span></span><br><span class="line">    pca = PCA(n_components=<span class="number">3</span>)  <span class="comment"># !                     看情况修改</span></span><br><span class="line">    x_new = pca.fit_transform(X)</span><br><span class="line"></span><br><span class="line">    n_pcs = pca.components_.shape[<span class="number">0</span>]</span><br><span class="line">    most_important = [np.<span class="built_in">abs</span>(pca.components_[i]).argmax() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_pcs)]</span><br><span class="line">    most_important_names = [names[most_important[i]] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_pcs)]</span><br><span class="line">    <span class="comment"># 画图</span></span><br><span class="line">    <span class="comment"># drawBiplot(x_new[:, :], np.transpose(pca.components_[:, most_important]), y, labels=most_important_names)</span></span><br><span class="line">    dic = &#123;<span class="string">&#x27;PC&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i): most_important_names[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_pcs)&#125;</span><br><span class="line">    df = pd.DataFrame(dic.items())</span><br><span class="line">    df[<span class="string">&#x27;evr&#x27;</span>] = [pca.explained_variance_ratio_[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_pcs)]</span><br><span class="line">    df.columns = [<span class="string">&#x27;主成分&#x27;</span>, <span class="string">&#x27;该主成分下最重要的变量&#x27;</span>, <span class="string">&#x27;主成分解释率&#x27;</span>]</span><br><span class="line">    <span class="comment"># 每个主成分最优变量和该主成分的价值</span></span><br><span class="line">    <span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出每个主成分按k比例个变量</span></span><br><span class="line">    n_pcs_best = <span class="number">2</span>  <span class="comment"># 需要根据df来判断</span></span><br><span class="line">    sel = [<span class="built_in">int</span>(k * <span class="number">3</span> / <span class="number">4</span>), k - <span class="built_in">int</span>(k * <span class="number">3</span> / <span class="number">4</span>)]</span><br><span class="line">    K_important = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_pcs_best):  <span class="comment"># 取第i个主成分的排序后component的下标</span></span><br><span class="line">        comp = np.<span class="built_in">abs</span>(pca.components_[i]).argsort()[::-<span class="number">1</span>][:sel[i]]</span><br><span class="line">        K_important.append(comp)</span><br><span class="line"></span><br><span class="line">    K_important_names = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_pcs_best):  <span class="comment"># 最好的几个主成分</span></span><br><span class="line">        temp = []</span><br><span class="line">        component = pca.components_[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> K_important[i]:  <span class="comment"># 每个主成分按贡献率取前j个值</span></span><br><span class="line">            temp.append((names[j], np.<span class="built_in">abs</span>(component[j])))</span><br><span class="line">        K_important_names.extend(temp)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;前2个主成分之前K个变量重要性&#x27;</span>, K_important_names)</span><br><span class="line"></span><br><span class="line">    pd_data = pd.DataFrame(K_important_names, columns=[<span class="string">&#x27;变量名&#x27;</span>, <span class="string">&#x27;重要性度&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;PCADataframe: &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(pd_data.iloc[:<span class="number">5</span>])</span><br><span class="line">    pd_data.to_excel(<span class="string">&#x27;FeatureSelect/PCAData.xlsx&#x27;</span>)  <span class="comment"># 要np.abs掉 保存吗</span></span><br><span class="line">    <span class="keyword">return</span> pd_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">voteFeature</span>(<span class="params">k</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">voteSum</span>(<span class="params">data, new_data, k</span>):</span><br><span class="line">        top = k  <span class="comment"># 选定的变量数k</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> data[<span class="string">&#x27;变量名&#x27;</span>]:</span><br><span class="line">            new_data[i] += top</span><br><span class="line">            top -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> top == <span class="number">0</span>:</span><br><span class="line">                top = k</span><br><span class="line">        <span class="keyword">return</span> new_data</span><br><span class="line"></span><br><span class="line">    file_dic = <span class="string">&#x27;FeatureSelect/&#x27;</span></span><br><span class="line">    MIC_list = pd.read_excel(file_dic + <span class="string">&#x27;MICData.xlsx&#x27;</span>, index_col=[<span class="number">0</span>])</span><br><span class="line">    dcor_list = pd.read_excel(file_dic + <span class="string">&#x27;DcorData.xlsx&#x27;</span>, index_col=[<span class="number">0</span>])</span><br><span class="line">    lasso_list = pd.read_excel(file_dic + <span class="string">&#x27;LassoData.xlsx&#x27;</span>, index_col=[<span class="number">0</span>])</span><br><span class="line">    RF_list = pd.read_excel(file_dic + <span class="string">&#x27;RFData.xlsx&#x27;</span>, index_col=[<span class="number">0</span>])</span><br><span class="line">    RFE_list = pd.read_excel(file_dic + <span class="string">&#x27;RFEData.xlsx&#x27;</span>, index_col=[<span class="number">0</span>])</span><br><span class="line">    pca_list = pd.read_excel(file_dic + <span class="string">&#x27;PCAData.xlsx&#x27;</span>, index_col=[<span class="number">0</span>])</span><br><span class="line">    all_list = pd.concat([MIC_list, dcor_list, lasso_list, RF_list, RFE_list, pca_list], axis=<span class="number">0</span>)</span><br><span class="line">    all_list.to_excel(file_dic + <span class="string">&#x27;all.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    new_list = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    new_list = voteSum(all_list, new_list, k)</span><br><span class="line">    sorted_dic = <span class="built_in">dict</span>(<span class="built_in">sorted</span>(new_list.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>], reverse=<span class="literal">True</span>))</span><br><span class="line">    sorted_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> sorted_dic.keys()]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;最终的前&#123;&#125;个变量：&#x27;</span>.<span class="built_in">format</span>(k), sorted_list[:k])</span><br><span class="line">    <span class="built_in">print</span>(sorted_dic)</span><br><span class="line">    <span class="keyword">return</span> sorted_list[:k]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">corrSelect</span>(<span class="params">data, target, names, k</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    https://www.cnblogs.com/always-fight/p/10209213.html</span></span><br><span class="line"><span class="string">    皮尔逊系数只能衡量线性相关性，先要计算各个特征对目标值的相关系数以及相关系数的P值。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    df = pd.DataFrame(data, columns=names)</span><br><span class="line">    c = cal_c(df, method, n_clusters=<span class="number">5</span>, threshold=<span class="number">0.7</span>)  <span class="comment"># 在utils文件中</span></span><br><span class="line">    c.corr_heat_map()</span><br><span class="line">    del_col = c.drop_hight_corr()</span><br><span class="line">    get_col = <span class="built_in">list</span>(<span class="built_in">set</span>(names).difference(<span class="built_in">set</span>(del_col)))</span><br><span class="line">    <span class="keyword">return</span> get_col</span><br><span class="line"><span class="comment"># 此处手动版获得p值 并根据阈值0.8 0.001筛选特征 没用到</span></span><br><span class="line">    <span class="comment"># sav = []</span></span><br><span class="line">    <span class="comment"># for i in range(data.shape[1]):  # 遍历特征</span></span><br><span class="line">    <span class="comment">#     temp = []</span></span><br><span class="line">    <span class="comment">#     for j in range(i, data.shape[1]):</span></span><br><span class="line">    <span class="comment">#         if j == i:</span></span><br><span class="line">    <span class="comment">#             continue</span></span><br><span class="line">    <span class="comment">#         ret = pearsonr(data[:, i], data[:, j])</span></span><br><span class="line">    <span class="comment">#         if abs(ret[0]) &lt; 0.8 and ret[1] &lt; 0.001:</span></span><br><span class="line">    <span class="comment">#             temp.append(j)</span></span><br><span class="line">    <span class="comment">#     if len(temp) &gt; int(data.shape[1] * 0.5):</span></span><br><span class="line">    <span class="comment">#         sav.append(i)</span></span><br><span class="line">    <span class="comment">#     # results.append(&#x27; &#x27;)</span></span><br><span class="line">    <span class="comment"># p_result = list(set(sav))</span></span><br><span class="line">    <span class="comment"># print(p_result, len(p_result))</span></span><br><span class="line">    <span class="comment"># return p_result</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># def multivariate_pearsonr(X, y):</span></span><br><span class="line">    <span class="comment">#     scores, p_values = [], []</span></span><br><span class="line">    <span class="comment">#     for ret in map(lambda x: pearsonr(x, y), X.T):</span></span><br><span class="line">    <span class="comment">#         if abs(ret[0]) &lt;= 0.6:</span></span><br><span class="line">    <span class="comment">#             scores.append(abs(ret[0]))</span></span><br><span class="line">    <span class="comment">#             p_values.append(ret[1])</span></span><br><span class="line">    <span class="comment">#         else:</span></span><br><span class="line">    <span class="comment">#             scores.append(0)</span></span><br><span class="line">    <span class="comment">#     return np.array(scores), 0</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># def multivariate_spearmanr(X, y):</span></span><br><span class="line">    <span class="comment">#     scores, p_values = [], []</span></span><br><span class="line">    <span class="comment">#     for ret in map(lambda x: spearmanr(x, y), X.T):</span></span><br><span class="line">    <span class="comment">#         if abs(ret[0]) &lt;= 0.6:</span></span><br><span class="line">    <span class="comment">#             scores.append(abs(ret[0]))</span></span><br><span class="line">    <span class="comment">#             p_values.append(ret[1])</span></span><br><span class="line">    <span class="comment">#         else:</span></span><br><span class="line">    <span class="comment">#             scores.append(0)</span></span><br><span class="line">    <span class="comment">#     return np.array(scores), 0</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># transformer = SelectKBest(score_func=multivariate_pearsonr, k=k)</span></span><br><span class="line">    <span class="comment"># transformer.fit_transform(data, target)</span></span><br><span class="line">    <span class="comment"># feature_index = transformer.get_support(True)</span></span><br><span class="line">    <span class="comment"># p_results = [names[i] for i in feature_index]</span></span><br><span class="line">    <span class="comment"># # return p_results</span></span><br><span class="line">    <span class="comment"># 此处自动版获取前k个 根据p值</span></span><br><span class="line">    <span class="comment"># transformer = SelectKBest(score_func=multivariate_spearmanr, k=k)</span></span><br><span class="line">    <span class="comment"># transformer.fit_transform(data, target)</span></span><br><span class="line">    <span class="comment"># feature_index = transformer.get_support(True)</span></span><br><span class="line">    <span class="comment"># s_results = [names[i] for i in feature_index]</span></span><br><span class="line">    <span class="comment"># return s_results</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">high_corr</span>(<span class="params">data, target, names</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kendall_pval</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">round</span>(kendalltau(x, y)[<span class="number">1</span>], <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pearsonr_pval</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">round</span>(pearsonr(x, y)[<span class="number">1</span>], <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spearmanr_pval</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">round</span>(spearmanr(x, y)[<span class="number">1</span>], <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># https://zhuanlan.zhihu.com/p/34717666</span></span><br><span class="line">    <span class="comment"># data = data.drop(&#x27;因变量&#x27;, 1) load_data已经排除</span></span><br><span class="line">    data = pd.DataFrame(data, columns=names)  <span class="comment"># 利用高相关删除特征</span></span><br><span class="line">    <span class="comment"># https://blog.csdn.net/sunmingyang1987/article/details/105459104</span></span><br><span class="line">    data = data.apply(<span class="keyword">lambda</span> x: x.astype(<span class="built_in">float</span>))</span><br><span class="line">    <span class="comment"># 连续、正态分布、线性 衡量两个数据是否在一条线上</span></span><br><span class="line">    p_cor = data.corr()</span><br><span class="line">    draw_heatmap(p_cor, method=<span class="string">&#x27;皮尔森相关系数&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># p_value = data.corr(method=pearsonr_pval)</span></span><br><span class="line">    <span class="comment"># p_value = p_value[p_value &lt; 0.001]</span></span><br><span class="line">    <span class="comment"># p_value = p_value.iloc[:15, :15]</span></span><br><span class="line">    <span class="comment"># draw_heatmap(p_value, method=&#x27;皮尔森相关系数P值&#x27;, center=0.001)  # 没用到</span></span><br><span class="line">    <span class="comment"># data_store(p_cor, &#x27;pearson&#x27;)  # 保存数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 针对无序序列的相关系数，非正太分布的数据 用在分类上、无序</span></span><br><span class="line">    <span class="comment"># k_cor = data.corr(method=&#x27;kendall&#x27;)</span></span><br><span class="line">    <span class="comment"># draw_cor = k_cor.iloc[:15, :15]</span></span><br><span class="line">    <span class="comment"># draw_heatmap(draw_cor, method=&#x27;肯德尔相关系数&#x27;)</span></span><br><span class="line">    <span class="comment"># k_value = data.corr(method=kendall_pval)</span></span><br><span class="line">    <span class="comment"># k_value = k_value[k_value &lt; 0.001]</span></span><br><span class="line">    <span class="comment"># k_value = k_value.iloc[:15, :15]</span></span><br><span class="line">    <span class="comment"># draw_heatmap(k_value, method=&#x27;肯德尔相关系数P值&#x27;, center=0.001)</span></span><br><span class="line">    <span class="comment"># data_store(p_cor, &#x27;kendall&#x27;)  # 保存数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 非线性的、非正态 对原始变量的分布不做要求</span></span><br><span class="line">    s_cor = data.corr(method=<span class="string">&#x27;spearman&#x27;</span>)</span><br><span class="line">    draw_heatmap(s_cor, method=<span class="string">&#x27;斯皮尔曼相关系数&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># s_value = data.corr(method=spearmanr_pval)</span></span><br><span class="line">    <span class="comment"># s_value = s_value[s_value &lt; 0.001]</span></span><br><span class="line">    <span class="comment"># s_value = s_value.iloc[:15, :15]</span></span><br><span class="line">    <span class="comment"># draw_heatmap(s_value, method=&#x27;斯皮尔曼相关系数P值&#x27;, center=0.001)</span></span><br><span class="line">    <span class="comment"># data_store(p_cor, &#x27;spearman&#x27;)  # 保存数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">featureSelect</span>(<span class="params">data, target, names, k</span>):  <span class="comment"># 看到这里发现没有保存最终版 只能将就改了</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">SelIndex</span>(<span class="params">list1</span>):</span><br><span class="line">        index = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">            temp = np.array(np.where(i == names)).tolist()[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            index.append(temp)</span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line">    <span class="comment"># 标准化可能会导致值变0 建议不标准化</span></span><br><span class="line">    <span class="comment"># scaler = StandardScaler()</span></span><br><span class="line">    <span class="comment"># data = scaler.fit_transform(data)</span></span><br><span class="line">    <span class="comment"># data_ = scaler.inverse_transform(data)</span></span><br><span class="line">    <span class="comment"># data_new = data_[:, target_new]  # 将标准化数据还原</span></span><br><span class="line">    <span class="comment"># target = scaler.fit_transform(target)</span></span><br><span class="line">    target = target[<span class="number">0</span>, :]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 过滤法</span></span><br><span class="line">    <span class="comment"># 最大信息系数</span></span><br><span class="line">    <span class="comment"># MIC_list = MICSelect(data, target, names, k)</span></span><br><span class="line">    <span class="comment"># drawBar(MIC_list, &#x27;最大信息系数&#x27;)</span></span><br><span class="line">    <span class="comment"># 距离相关系数</span></span><br><span class="line">    <span class="comment"># dcor_list = dcorSelect(data, target, names, k)</span></span><br><span class="line">    <span class="comment"># drawBar(dcor_list, &#x27;距离相关系数&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 嵌入法</span></span><br><span class="line">    <span class="comment"># Lasso回归</span></span><br><span class="line">    <span class="comment"># lasso_list = LassoSelect(data, target, names, k)</span></span><br><span class="line">    <span class="comment"># 不排序直接取前k个变量 title=&#x27;Lasso模型关联度情况&#x27;</span></span><br><span class="line">    <span class="comment"># drawBar(lasso_list, typ=&#x27;bar&#x27;, title=&#x27;Lasso模型变量重要性&#x27;, xlabel=&#x27;变量名&#x27;, ylabel=&#x27;重要性&#x27;)</span></span><br><span class="line">    <span class="comment"># 随机森林</span></span><br><span class="line">    <span class="comment"># RF_list = RFSelect(data, target, names, k)</span></span><br><span class="line">    <span class="comment"># drawBar(RF_list, title=&#x27;随机森林模型变量重要性&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 包装法 RFE</span></span><br><span class="line">    <span class="comment"># RFE_list = RFESelect(data, target, names, k)</span></span><br><span class="line">    <span class="comment"># drawBar(RFE_list, title=&#x27;RFE模型变量重要性&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数据降维</span></span><br><span class="line">    <span class="comment"># pca_list = PCAReduction(data, names, k)</span></span><br><span class="line">    <span class="comment"># drawBar(pca_list, title=&#x27;PCA模型变量重要性&#x27;)</span></span><br><span class="line"></span><br><span class="line">    after_list = voteFeature(k)</span><br><span class="line">    after_index = SelIndex(after_list)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;经过六种特征选择后的变量下标: &#x27;</span>, after_index)</span><br><span class="line">    <span class="comment"># high_corr(data[:, after_index], target, names[after_index])</span></span><br><span class="line"></span><br><span class="line">    final_list = corrSelect(data[:, after_index], target, names[after_index], k=<span class="number">25</span>)</span><br><span class="line">    final_index = final_list</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;经过相关性处理后的变量下标: &#x27;</span>, final_index)</span><br><span class="line">    high_corr(data[:, final_index], target, names[final_index])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 评价是两个事件是否独立 https://www.cnblogs.com/always-fight/p/10209213.html  以下三行仅做记录</span></span><br><span class="line">    <span class="comment"># X_new = SelectKBest(chi2, k=k).fit_transform(X, y) 类别型变量对类别型变量的相关性</span></span><br><span class="line">    <span class="comment"># https://scikit-learn.org/stable/modules/model_evaluation.html#scoring-parameter</span></span><br><span class="line">    <span class="comment"># scores = cross_val_score(RFC, X, Y, cv=5, scoring=&#x27;accuracy&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">featureSelect2</span>(<span class="params">data, target, names, k</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">SelIndex</span>(<span class="params">list1</span>):</span><br><span class="line">        index = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">            temp = np.array(np.where(i == names)).tolist()[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            index.append(temp)</span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line"></span><br><span class="line">    after_list = corrSelect(data, names, method=<span class="string">&#x27;spearman&#x27;</span>)  <span class="comment"># 记得修改阈值</span></span><br><span class="line">    after_index = SelIndex(after_list)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;经过相关性处理后的变量下标(&#123;&#125;): &#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(after_index)), after_index)</span><br><span class="line">    <span class="comment"># high_corr(data[:, after_index], names[after_index])</span></span><br><span class="line">    data = data[:, after_index]</span><br><span class="line">    names = names[after_index]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 过滤法</span></span><br><span class="line">    <span class="comment"># 最大信息系数</span></span><br><span class="line">    <span class="comment"># MIC_list = MICSelect(data, target, names, k)</span></span><br><span class="line">    <span class="comment"># drawBar(MIC_list, &#x27;最大信息系数&#x27;)</span></span><br><span class="line">    <span class="comment"># 距离相关系数</span></span><br><span class="line">    <span class="comment"># dcor_list = dcorSelect(data, target, names, k)</span></span><br><span class="line">    <span class="comment"># drawBar(dcor_list, &#x27;距离相关系数&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 嵌入法</span></span><br><span class="line">    <span class="comment"># Lasso回归 不排序直接取前k个变量 title=&#x27;Lasso模型关联度情况&#x27; 会出现负值 显得跟其他图片不一样 有区别性</span></span><br><span class="line">    <span class="comment"># lasso_list = LassoSelect(data, target, names, k)</span></span><br><span class="line">    <span class="comment"># drawBar(lasso_list, title=&#x27;Lasso模型变量重要性&#x27;, xlabel=&#x27;变量名&#x27;, ylabel=&#x27;重要性&#x27;)</span></span><br><span class="line">    <span class="comment"># 随机森林</span></span><br><span class="line">    <span class="comment"># RF_list = RFSelect(data, target, names, k)</span></span><br><span class="line">    <span class="comment"># drawBar(RF_list, title=&#x27;随机森林模型变量重要性&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 包装法 RFE  用标准化数据</span></span><br><span class="line">    <span class="comment"># 标准化可能会导致值变0 建议不标准化</span></span><br><span class="line">    <span class="comment"># target = target.reshape(1, -1)</span></span><br><span class="line">    <span class="comment"># scaler = StandardScaler()</span></span><br><span class="line">    <span class="comment"># data = scaler.fit_transform(data)</span></span><br><span class="line">    <span class="comment"># data_ = scaler.inverse_transform(data)  # 将标准化数据还原</span></span><br><span class="line">    <span class="comment"># target = scaler.fit_transform(target)</span></span><br><span class="line">    <span class="comment"># target = target[0, :]</span></span><br><span class="line">    <span class="comment"># RFE_list = RFESelect(data, target, names, k)</span></span><br><span class="line">    <span class="comment"># drawBar(RFE_list, title=&#x27;RFE模型变量重要性&#x27;)</span></span><br><span class="line">    <span class="comment"># data = data_</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数据降维</span></span><br><span class="line">    <span class="comment"># 需要注意的是虽然有负值 但是重要性看的是绝对值</span></span><br><span class="line">    <span class="comment"># pca_list = PCAReduction(data, names, k)</span></span><br><span class="line">    <span class="comment"># drawBar(pca_list, title=&#x27;PCA模型变量重要性&#x27;)</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    final_list = voteFeature(k)</span><br><span class="line">    final_index = SelIndex(final_list)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;经过六种特征选择后的变量下标(&#123;&#125;): &#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(final_index)), final_index)</span><br><span class="line">    <span class="comment"># high_corr(data[:, final_index], names[final_index])</span></span><br><span class="line"></span><br><span class="line">    result = pd.DataFrame(data[:, final_index], columns=names[final_index])</span><br><span class="line">    result.to_excel(<span class="string">&#x27;FeatureSelect/results.xlsx&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    file_name = <span class="string">&#x27;C:/Users/Desktop/数模题/附件一：325个样本数据.xlsx&#x27;</span>  <span class="comment"># 列名取中文名</span></span><br><span class="line">    sheet_name = <span class="string">&#x27;Sheet1&#x27;</span></span><br><span class="line">    <span class="comment"># table = pd.read_excel(file_name, sheet_name, header=[2])  # 如果有多个列名 方便起见只取一个</span></span><br><span class="line">    <span class="comment"># table = table.iloc[:, 2:]</span></span><br><span class="line">    <span class="comment"># table.rename(columns=&#123;&#x27;时间&#x27;: &#x27;time&#x27;&#125;, inplace=True)</span></span><br><span class="line">    <span class="comment"># print(table.head())</span></span><br><span class="line">    <span class="comment"># https://zhuanlan.zhihu.com/p/98729226 D21116460003</span></span><br><span class="line">    <span class="comment"># plt.style.use(&#x27;fivethirtyeight&#x27;)</span></span><br><span class="line">    <span class="comment"># seaborn.pairplot(table, vars=table.columns[:8], diag_kind=&#x27;kde&#x27;)</span></span><br><span class="line">    <span class="comment"># plt.show()</span></span><br><span class="line">    </span><br><span class="line">    X, Y, name = loadData2()</span><br><span class="line">    X, name = low_var_filter(X, name)  <span class="comment"># 低方差滤波 携带信息少</span></span><br><span class="line">    high_corr(X, name)</span><br><span class="line">    results = pd.DataFrame([])</span><br><span class="line">    t_names = [<span class="string">&#x27;10cm湿度(kg/m2)&#x27;</span>, <span class="string">&#x27;40cm湿度(kg/m2)&#x27;</span>, <span class="string">&#x27;100cm湿度(kg/m2)&#x27;</span>, <span class="string">&#x27;200cm湿度(kg/m2)&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">1</span>]):</span><br><span class="line">        temp = Y[:, i]</span><br><span class="line">    <span class="comment">#     # result = featureSelect(X, temp, name, k=10)  # 后去相关</span></span><br><span class="line">        result = featureSelect2(X, temp, name, k=<span class="number">7</span>)  <span class="comment"># 先去相关</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#     results = pd.concat([results, result], axis=1)</span></span><br><span class="line">    <span class="comment">#     print(results.iloc[1, :])</span></span><br><span class="line">    <span class="comment"># results.to_excel(&#x27;data/results.xlsx&#x27;)</span></span><br></pre></td></tr></table></figure><h2 id="模型堆叠"><a href="#模型堆叠" class="headerlink" title="模型堆叠"></a>模型堆叠</h2><p>这里就不给了 因为我没写这里的代码，实际上就是sklearn调用很多方法，注意调参，可能结果不好的原因是特征选择不好或者模型不对，建议多准备一些，比如分类模型、回归模型、自回归模型、时间序列、深度学习模型。</p><h2 id="一些保存下来的解题代码"><a href="#一些保存下来的解题代码" class="headerlink" title="一些保存下来的解题代码"></a>一些保存下来的解题代码</h2><h3 id="Q2-使用LSTM预测"><a href="#Q2-使用LSTM预测" class="headerlink" title="Q2 使用LSTM预测"></a>Q2 使用LSTM预测</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> keras.losses <span class="keyword">import</span> mean_squared_error</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line">file_dic = <span class="string">r&#x27;C:\Users\Desktop\2022年E题\数据集\基本数据/&#x27;</span></span><br><span class="line">file_name = <span class="string">r&#x27;附件3、土壤湿度2022—2012年.xlsx&#x27;</span></span><br><span class="line"><span class="comment"># dataset_train = pd.read_excel(file_dic + file_name, usecols=[&#x27;10cm湿度(kg/m2)&#x27;], sheet_name=&#x27;sheet1&#x27;)</span></span><br><span class="line">dataset_train = pd.read_excel(file_dic + file_name, usecols=[<span class="string">&#x27;10cm湿度(kg/m2)&#x27;</span>], sheet_name=<span class="string">&#x27;sheet1&#x27;</span>)</span><br><span class="line"><span class="comment"># dataset_train = dataset_train.sort_values(by=&#x27;Date&#x27;).reset_index(drop=True)</span></span><br><span class="line">training_set = dataset_train.values</span><br><span class="line"><span class="built_in">print</span>(dataset_train.shape)</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line">sc = MinMaxScaler(feature_range=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">training_set_scaled = sc.fit_transform(training_set)</span><br><span class="line"><span class="comment"># 每条样本含60个时间步，对应下一时间步的标签值</span></span><br><span class="line">X_train = []</span><br><span class="line">y_train = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>, <span class="number">93</span>):</span><br><span class="line">    X_train.append(training_set_scaled[i - <span class="number">6</span>:i, <span class="number">0</span>])</span><br><span class="line">    y_train.append(training_set_scaled[i, <span class="number">0</span>])</span><br><span class="line">X_train, y_train = np.array(X_train), np.array(y_train)</span><br><span class="line"><span class="built_in">print</span>(X_train.shape)</span><br><span class="line"><span class="built_in">print</span>(y_train.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reshaping</span></span><br><span class="line">X_train = np.reshape(X_train, (X_train.shape[<span class="number">0</span>], X_train.shape[<span class="number">1</span>], <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(X_train.shape)</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> SimpleRNN, LSTM</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dropout</span><br><span class="line"><span class="comment"># print(X_train.shape[1])</span></span><br><span class="line"><span class="comment"># 初始化顺序模型</span></span><br><span class="line">regressor = Sequential()</span><br><span class="line"><span class="comment"># 定义输入层及带5个神经元的隐藏层</span></span><br><span class="line">regressor.add(SimpleRNN(units=<span class="number">15</span>, input_shape=(X_train.shape[<span class="number">1</span>], <span class="number">1</span>)))</span><br><span class="line"><span class="comment"># 定义线性的输出层</span></span><br><span class="line">regressor.add(Dense(units=<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line"><span class="comment"># 模型编译：定义优化算法adam， 目标函数均方根MSE</span></span><br><span class="line">regressor.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;sgd&#x27;</span>, loss=<span class="string">&#x27;mean_squared_error&#x27;</span>)</span><br><span class="line"><span class="comment"># 模型训练</span></span><br><span class="line">history = regressor.fit(X_train, y_train, epochs=<span class="number">40</span>, batch_size=<span class="number">20</span>, validation_split=<span class="number">0.1</span>)</span><br><span class="line">regressor.summary()</span><br><span class="line">ax1 = plt.subplot(<span class="number">121</span>)</span><br><span class="line">ax1.plot(history.history[<span class="string">&#x27;loss&#x27;</span>], c=<span class="string">&#x27;blue&#x27;</span>, label=<span class="string">&#x27;训练集损失&#x27;</span>)  <span class="comment"># 蓝色线训练集损失</span></span><br><span class="line">ax1.plot(history.history[<span class="string">&#x27;val_loss&#x27;</span>], c=<span class="string">&#x27;red&#x27;</span>, label=<span class="string">&#x27;验证集损失&#x27;</span>)  <span class="comment"># 红色线验证集损失</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;值&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;迭代次数&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"><span class="comment"># 测试数据</span></span><br><span class="line"><span class="comment"># dataset_test = pd.read_csv(&#x27;./data/tatatest.csv&#x27;)</span></span><br><span class="line"><span class="comment"># dataset_test = pd.read_excel(file_dic + r&#x27;附件3、土壤湿度2022—2012年test.xlsx&#x27;, usecols=[&#x27;10cm湿度(kg/m2)&#x27;], sheet_name=&#x27;sheet1&#x27;)</span></span><br><span class="line">dataset_test = pd.read_excel(file_dic + <span class="string">r&#x27;附件3、土壤湿度2022—2012年test.xlsx&#x27;</span>, usecols=[<span class="string">&#x27;10cm湿度(kg/m2)&#x27;</span>], sheet_name=<span class="string">&#x27;sheet1&#x27;</span>)</span><br><span class="line">real_value = dataset_test[<span class="string">&#x27;10cm湿度(kg/m2)&#x27;</span>].values</span><br><span class="line"></span><br><span class="line">dataset_total = pd.concat((dataset_train[<span class="string">&#x27;10cm湿度(kg/m2)&#x27;</span>], dataset_test[<span class="string">&#x27;10cm湿度(kg/m2)&#x27;</span>]), axis=<span class="number">0</span>)</span><br><span class="line">inputs = dataset_total[<span class="built_in">len</span>(dataset_total) - <span class="built_in">len</span>(dataset_test) - <span class="number">60</span>:].values</span><br><span class="line">inputs = inputs.reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">inputs = sc.transform(inputs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取测试集</span></span><br><span class="line">X_test = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>, <span class="number">30</span>):</span><br><span class="line">    X_test.append(inputs[i - <span class="number">6</span>:i, <span class="number">0</span>])</span><br><span class="line">X_test = np.array(X_test)</span><br><span class="line">X_test = np.reshape(X_test, (X_test.shape[<span class="number">0</span>], X_test.shape[<span class="number">1</span>], <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型预测</span></span><br><span class="line">predicted_value = regressor.predict(X_test)</span><br><span class="line"><span class="comment"># 逆归一化</span></span><br><span class="line">predicted_value = sc.inverse_transform(predicted_value)</span><br><span class="line"><span class="comment"># 模型评估</span></span><br><span class="line"><span class="comment"># trainScore = math.sqrt(mean_squared_error(predicted_value[0], trainPredict[:, 0]))</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;预测与实际差异MSE&#x27;</span>, <span class="built_in">sum</span>(<span class="built_in">pow</span>((predicted_value - real_value), <span class="number">2</span>)) / predicted_value.shape[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;预测与实际差异MAE&#x27;</span>, <span class="built_in">sum</span>(<span class="built_in">abs</span>(predicted_value - real_value)) / predicted_value.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">val = regressor.predict([[[X_test[-<span class="number">5</span>:]]]])</span><br><span class="line">val = sc.inverse_transform(val)</span><br><span class="line">blo = [<span class="string">&#x27;04&#x27;</span>, <span class="string">&#x27;05&#x27;</span>, <span class="string">&#x27;06&#x27;</span>, <span class="string">&#x27;07&#x27;</span>, <span class="string">&#x27;08&#x27;</span>, <span class="string">&#x27;09&#x27;</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;01&#x27;</span>, <span class="string">&#x27;02&#x27;</span>, <span class="string">&#x27;03&#x27;</span>, <span class="string">&#x27;04&#x27;</span>, <span class="string">&#x27;05&#x27;</span>, <span class="string">&#x27;06&#x27;</span>, <span class="string">&#x27;07&#x27;</span>, <span class="string">&#x27;08&#x27;</span>, <span class="string">&#x27;09&#x27;</span>]</span><br><span class="line">resl = []</span><br><span class="line">valu = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(blo)):</span><br><span class="line">    resl.append(blo[i] + <span class="built_in">str</span>(val))</span><br><span class="line">    val = sc.fit_transform(val)</span><br><span class="line">    <span class="comment"># print(val.shape)</span></span><br><span class="line">    val = regressor.predict([val[-<span class="number">5</span>:]])</span><br><span class="line">    val = sc.inverse_transform(val)</span><br><span class="line">    valu.append(val[-<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 预测与实际差异的可视化</span></span><br><span class="line">ax2 = plt.subplot(<span class="number">122</span>)</span><br><span class="line">ax2.plot(real_value, color=<span class="string">&#x27;red&#x27;</span>, label=<span class="string">&#x27;真实值&#x27;</span>)</span><br><span class="line">valu = np.array([valu]).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">predicted_value = np.concatenate((predicted_value, valu), axis=<span class="number">0</span>)</span><br><span class="line">ax2.plot(predicted_value, color=<span class="string">&#x27;blue&#x27;</span>, label=<span class="string">&#x27;预测值&#x27;</span>)</span><br><span class="line"><span class="comment"># plt.title(&#x27;TATA Stock Price Prediction&#x27;)</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;迭代次数&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line">plt.savefig(<span class="string">&#x27;Q3/&#x27;</span> + <span class="string">&#x27;q63.jpg&#x27;</span>, dpi=<span class="number">300</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导包略</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">smooth_xy</span>(<span class="params">lx, ly</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;数据平滑处理</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param lx: x轴数据，数组</span></span><br><span class="line"><span class="string">    :param ly: y轴数据，数组</span></span><br><span class="line"><span class="string">    :return: 平滑后的x、y轴数据，数组 [slx, sly]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    x = np.array(lx)</span><br><span class="line">    y = np.array(ly)</span><br><span class="line">    x_smooth = np.linspace(x.<span class="built_in">min</span>(), x.<span class="built_in">max</span>(), <span class="number">300</span>)</span><br><span class="line">    y_smooth = make_interp_spline(x, y)(x_smooth)</span><br><span class="line">    <span class="keyword">return</span> [x_smooth, y_smooth]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line">file_dic = <span class="string">r&#x27;C:\Users\CYH\Desktop\2022年E题\数据集\监测点数据\附件14：不同放牧强度土壤碳氮监测数据集/&#x27;</span></span><br><span class="line">file_name = <span class="string">r&#x27;不同放牧强度土壤碳氮监测数据集.xlsx&#x27;</span></span><br><span class="line">cols = [<span class="string">&#x27;放牧强度（intensity）&#x27;</span>, <span class="string">&#x27;SOC土壤有机碳&#x27;</span>, <span class="string">&#x27;SIC土壤无机碳&#x27;</span>, <span class="string">&#x27;全氮N&#x27;</span>]</span><br><span class="line">data = read_excel(file_dic + file_name, usecols=cols, sheet_name=<span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line">box1, box2, box3, box4 = [], [], [], []</span><br><span class="line">cho = [<span class="string">&#x27;NG&#x27;</span>, <span class="string">&#x27;LGI&#x27;</span>, <span class="string">&#x27;MGI&#x27;</span>, <span class="string">&#x27;HGI&#x27;</span>]</span><br><span class="line">col = [<span class="string">&#x27;SOC土壤有机碳&#x27;</span>, <span class="string">&#x27;SIC土壤无机碳&#x27;</span>, <span class="string">&#x27;全氮N&#x27;</span>]</span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">gs = gridspec.GridSpec(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">gs.update(wspace=<span class="number">0.8</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(col)):  <span class="comment"># 获取对应放牧强度下的化学性质</span></span><br><span class="line">    box1, box2, box3, box4 = [], [], [], []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(data.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">if</span> data[cols[<span class="number">0</span>]][j] == cho[<span class="number">0</span>]:</span><br><span class="line">            box1.append(data[col[i]][j])</span><br><span class="line">        <span class="keyword">elif</span> data[cols[<span class="number">0</span>]][j] == cho[<span class="number">1</span>]:</span><br><span class="line">            box2.append(data[col[i]][j])</span><br><span class="line">        <span class="keyword">elif</span> data[cols[<span class="number">0</span>]][j] == cho[<span class="number">2</span>]:</span><br><span class="line">            box3.append(data[col[i]][j])</span><br><span class="line">        <span class="keyword">elif</span> data[cols[<span class="number">0</span>]][j] == cho[<span class="number">3</span>]:</span><br><span class="line">            box4.append(data[col[i]][j])</span><br><span class="line">    x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    y = np.array([np.median(box1), np.median(box2), np.median(box3), np.median(box4)])</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        plt.subplot(gs[<span class="number">0</span>, :<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">        plt.subplot(gs[<span class="number">0</span>, <span class="number">2</span>:<span class="number">4</span>])</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">2</span>:</span><br><span class="line">        plt.subplot(gs[<span class="number">1</span>, <span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line">    plt.subplots_adjust(left=<span class="literal">None</span>, bottom=<span class="literal">None</span>, right=<span class="literal">None</span>, top=<span class="literal">None</span>,</span><br><span class="line">                        wspace=<span class="number">0.4</span>, hspace=<span class="number">0.45</span>)</span><br><span class="line">    z1 = np.polyfit(x, y, <span class="number">2</span>)  <span class="comment"># 用3次多项式拟合，输出系数从高到0</span></span><br><span class="line">    p1 = np.poly1d(z1)  <span class="comment"># 使用次数合成多项式</span></span><br><span class="line">    y_pre = p1(x)</span><br><span class="line">    zs = np.array(p1)</span><br><span class="line">    r, p = stats.pearsonr(y, y_pre)</span><br><span class="line">    p = [<span class="number">0.047</span>, <span class="number">0.029</span>,<span class="number">0.24</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;相关系数r为 = %6.3f，p值为 = %6.3f&#x27;</span> % (r, p[i]))</span><br><span class="line">    x, y_pre = smooth_xy(x, y_pre)</span><br><span class="line">    labels = <span class="string">&quot;y=&quot;</span> + <span class="built_in">str</span>(<span class="built_in">round</span>(zs[<span class="number">0</span>], <span class="number">2</span>)) + <span class="string">&quot;x$^2$&quot;</span> + <span class="built_in">str</span>(<span class="built_in">round</span>(zs[<span class="number">1</span>], <span class="number">2</span>)) + <span class="string">&quot;x+&quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">        <span class="built_in">round</span>(zs[<span class="number">2</span>], <span class="number">2</span>)) + <span class="string">&#x27;\nr$^2$=&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">round</span>(r, <span class="number">3</span>)) + <span class="string">&#x27;, p=&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">round</span>(p[i], <span class="number">3</span>))</span><br><span class="line">    plt.plot(x, y_pre, color=<span class="string">&#x27;#cd534c&#x27;</span>, label=labels)</span><br><span class="line">    <span class="comment"># plt.ylabel(labels)</span></span><br><span class="line">    plt.legend()</span><br><span class="line">    <span class="built_in">print</span>(p1)</span><br><span class="line">    ylim = [<span class="number">30</span>, <span class="number">25</span>, <span class="number">6</span>]</span><br><span class="line">    <span class="comment"># plt.title(col[i] + &#x27;的箱型图&#x27;)</span></span><br><span class="line">    labels = cols[<span class="number">1</span>:]</span><br><span class="line">    f = plt.boxplot([box1, box2, box3, box4], labels=cho, widths=<span class="number">0.2</span>,</span><br><span class="line">                    boxprops=&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;#999&#x27;</span>&#125;,</span><br><span class="line">                    medianprops=&#123;<span class="string">&#x27;linestyle&#x27;</span>: <span class="string">&#x27;--&#x27;</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;#999&#x27;</span>&#125;,</span><br><span class="line">                    capprops=&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;#999&#x27;</span>&#125;,</span><br><span class="line">                    whiskerprops=&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;#999&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    plt.ylim(<span class="number">0</span>, ylim[i])</span><br><span class="line">plt.savefig(<span class="string">&#x27;Q3/&#x27;</span> + <span class="string">&#x27;q3.jpg&#x27;</span>, dpi=<span class="number">300</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 分不清了 这里应该也是吧</span></span><br><span class="line"><span class="comment"># https://blog.csdn.net/zyxhangiian123456789/article/details/87458140</span></span><br><span class="line"><span class="comment"># https://blog.csdn.net/LaoChengZier/article/details/90511968</span></span><br><span class="line"><span class="comment"># https://deephub.blog.csdn.net/article/details/122425490</span></span><br><span class="line"><span class="comment"># https://blog.csdn.net/weixin_52855810/article/details/112982229</span></span><br><span class="line"><span class="comment"># 创建数据集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_dataset</span>(<span class="params">dataset, look_back=<span class="number">1</span></span>):</span><br><span class="line">    dataX, dataY = [], []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dataset) - look_back - <span class="number">1</span>):</span><br><span class="line">        a = dataset[i:(i + look_back), <span class="number">0</span>]  <span class="comment"># 用look_back个样本来预测一个数据</span></span><br><span class="line">        dataX.append(a)</span><br><span class="line">        dataY.append(dataset[i + look_back, <span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> numpy.array(dataX), numpy.array(dataY)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">iq = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getValue</span>(<span class="params">data, name</span>):</span><br><span class="line">    dataset = data.values</span><br><span class="line">    <span class="comment"># 将整型变为float</span></span><br><span class="line">    dataset = dataset.astype(<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">    dataset = dataset.reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 数据处理，归一化至0~1之间</span></span><br><span class="line">    scaler = MinMaxScaler(feature_range=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    dataset = scaler.fit_transform(dataset)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 划分训练集和测试集</span></span><br><span class="line">    train_size = <span class="number">27</span></span><br><span class="line">    test_size = <span class="built_in">len</span>(dataset) - train_size</span><br><span class="line">    train, test = dataset[<span class="number">0</span>:train_size, :], dataset[train_size:<span class="built_in">len</span>(dataset), :]</span><br><span class="line">    <span class="comment"># train, test = dataset[:30, :], dataset[:30, :]</span></span><br><span class="line">    <span class="comment"># 创建测试集和训练集</span></span><br><span class="line">    look_back = <span class="number">1</span></span><br><span class="line">    trainX, trainY = create_dataset(train, look_back)  <span class="comment"># 单步预测</span></span><br><span class="line">    testX, testY = create_dataset(test, look_back)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调整输入数据的格式</span></span><br><span class="line">    trainX = numpy.reshape(trainX, (trainX.shape[<span class="number">0</span>], look_back, trainX.shape[<span class="number">1</span>]))  <span class="comment"># （样本个数，1，输入的维度）</span></span><br><span class="line">    testX = numpy.reshape(testX, (testX.shape[<span class="number">0</span>], look_back, testX.shape[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建LSTM神经网络模型</span></span><br><span class="line">    model = Sequential()</span><br><span class="line">    model.add(LSTM(<span class="number">120</span>, unit_forget_bias=<span class="literal">True</span>, return_sequences=<span class="literal">True</span>, input_shape=(trainX.shape[<span class="number">1</span>], trainX.shape[<span class="number">2</span>])))</span><br><span class="line">    model.add(LSTM(<span class="number">100</span>))</span><br><span class="line">    <span class="comment"># model.add(Dropout(0.2))</span></span><br><span class="line">    model.add(Dense(<span class="number">1</span>))</span><br><span class="line">    <span class="comment"># model.add(LSTM(120, input_shape=(trainX.shape[1], trainX.shape[2])))  # 输入维度为1，时间窗的长度为1，隐含层神经元节点个数为120</span></span><br><span class="line">    <span class="comment"># model.add(Dense(1))</span></span><br><span class="line">    model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mean_squared_error&#x27;</span>, optimizer=<span class="string">&#x27;sgd&#x27;</span>)</span><br><span class="line">    model.summary()</span><br><span class="line">    <span class="comment"># 绘制网络结构</span></span><br><span class="line">    <span class="comment"># plot_model(model, to_file=&#x27;model.png&#x27;, show_shapes=True)</span></span><br><span class="line"></span><br><span class="line">    history = model.fit(trainX, trainY, epochs=<span class="number">100</span>, batch_size=<span class="number">1</span>, verbose=<span class="number">0</span>, validation_data=(testX, testY))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预测</span></span><br><span class="line">    trainPredict = model.predict(trainX)</span><br><span class="line">    testPredict = model.predict(testX)</span><br><span class="line">    <span class="comment"># print(trainPredict.shape, testPredict.shape)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 反归一化</span></span><br><span class="line">    trainPredict = scaler.inverse_transform(trainPredict)</span><br><span class="line">    trainY = scaler.inverse_transform([trainY])</span><br><span class="line">    testPredict = scaler.inverse_transform(testPredict)</span><br><span class="line">    testY = scaler.inverse_transform([testY])</span><br><span class="line">    <span class="comment"># 计算得分</span></span><br><span class="line">    trainScore = math.sqrt(mean_squared_error(trainY[<span class="number">0</span>], trainPredict[:, <span class="number">0</span>]))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Train Score: %.2f RMSE&#x27;</span> % trainScore)</span><br><span class="line">    testScore = math.sqrt(mean_squared_error(testY[<span class="number">0</span>], testPredict[:, <span class="number">0</span>]))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Test Score: %.2f RMSE&#x27;</span> % testScore)</span><br><span class="line"></span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot(history.history[<span class="string">&#x27;loss&#x27;</span>])</span><br><span class="line">    plt.plot(history.history[<span class="string">&#x27;val_loss&#x27;</span>])</span><br><span class="line">    plt.title(<span class="string">&#x27;model train vs validation loss&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;loss&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">    plt.legend([<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;validation&#x27;</span>], loc=<span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    val = model.predict([[[testX[-<span class="number">1</span>]]]])</span><br><span class="line">    val = scaler.inverse_transform(val)</span><br><span class="line">    blo = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">    resl = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(blo)):</span><br><span class="line">        resl.append(blo[i] + <span class="built_in">str</span>(val))</span><br><span class="line">        val = scaler.fit_transform(val)</span><br><span class="line">        val = model.predict([[[val]]])</span><br><span class="line">        val = scaler.inverse_transform(val)</span><br><span class="line">    <span class="comment"># 绘</span></span><br><span class="line">    trainPredictPlot = numpy.empty_like(dataset)</span><br><span class="line">    trainPredictPlot[:, :] = numpy.nan</span><br><span class="line">    trainPredictPlot[look_back:<span class="built_in">len</span>(trainPredict) + look_back, :] = trainPredict</span><br><span class="line">    testPredictPlot = numpy.empty_like(dataset)</span><br><span class="line">    testPredictPlot[:, :] = numpy.nan</span><br><span class="line">    testPredictPlot[<span class="built_in">len</span>(trainPredict) + (look_back * <span class="number">2</span>) + <span class="number">1</span>:<span class="built_in">len</span>(dataset) - <span class="number">1</span>, :] = testPredict</span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot(scaler.inverse_transform(dataset), label=<span class="string">&#x27;真实值&#x27;</span>, color=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    plt.plot(trainPredictPlot, label=<span class="string">&#x27;训练值&#x27;</span>, color=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">    plt.plot(testPredictPlot, label=<span class="string">&#x27;预测值&#x27;</span>, color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="comment"># plt.title(name + &#x27;拟合曲线&#x27;)</span></span><br><span class="line">    plt.ylabel(<span class="string">&#x27;值&#x27;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.savefig(<span class="string">&#x27;picture/lstm/&#x27;</span> + name + <span class="built_in">str</span>(iq), bbox_inches=<span class="string">&#x27;tight&#x27;</span>, pad_inches=<span class="number">0.1</span>, dpi=<span class="number">300</span>)</span><br><span class="line">    <span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(resl)</span><br><span class="line">    <span class="keyword">return</span> resl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_data</span>(<span class="params">data</span>):</span><br><span class="line">    cho = [<span class="string">&#x27;NG&#x27;</span>, <span class="string">&#x27;LGI&#x27;</span>, <span class="string">&#x27;MGI&#x27;</span>, <span class="string">&#x27;HGI&#x27;</span>]</span><br><span class="line">    col = [<span class="string">&#x27;SOC土壤有机碳&#x27;</span>, <span class="string">&#x27;SIC土壤无机碳&#x27;</span>, <span class="string">&#x27;全氮N&#x27;</span>]</span><br><span class="line">    results = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> cho:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(data.shape[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">if</span> data[<span class="string">&#x27;放牧强度（intensity）&#x27;</span>][j] == i:</span><br><span class="line">                result.append(data[j:j + <span class="number">1</span>][col])</span><br><span class="line">        results.append(result)</span><br><span class="line">    results = np.array(results).reshape((<span class="number">4</span>, <span class="number">33</span>, -<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 加载数据</span></span><br><span class="line">    file_dic = <span class="string">r&#x27;C:\Users\Desktop\2022年E题\数据集\监测点数据\附件14：不同放牧强度土壤碳氮监测数据集/&#x27;</span></span><br><span class="line">    file_name = <span class="string">r&#x27;不同放牧强度土壤碳氮监测数据集.xlsx&#x27;</span></span><br><span class="line">    cols = [<span class="string">&#x27;放牧强度（intensity）&#x27;</span>, <span class="string">&#x27;SOC土壤有机碳&#x27;</span>, <span class="string">&#x27;SIC土壤无机碳&#x27;</span>, <span class="string">&#x27;全氮N&#x27;</span>]</span><br><span class="line">    dataframe = read_excel(file_dic + file_name, usecols=cols)</span><br><span class="line">    dataframe = load_data(dataframe)</span><br><span class="line">    values = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dataframe)):</span><br><span class="line">        res = pd.DataFrame(dataframe[i], columns=cols[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cols[<span class="number">1</span>:])):</span><br><span class="line">            iq += <span class="number">1</span></span><br><span class="line">            temp = res[cols[<span class="number">1</span> + j]]</span><br><span class="line">            name = cols[<span class="number">1</span> + j] + <span class="built_in">str</span>(i) + <span class="built_in">str</span>(j)</span><br><span class="line">            val = getValue(temp, name)</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> val:</span><br><span class="line">                values.append(name + k)</span><br><span class="line">    <span class="built_in">print</span>(values)</span><br></pre></td></tr></table></figure><h3 id="Q5-没做出来-好像直接语文建模了"><a href="#Q5-没做出来-好像直接语文建模了" class="headerlink" title="Q5 没做出来 好像直接语文建模了"></a>Q5 没做出来 好像直接语文建模了</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_data</span>():</span><br><span class="line">    file14_dic = <span class="string">r&#x27;C:\Users\Desktop\2022年E题\数据集\监测点数据\附件14：不同放牧强度土壤碳氮监测数据集/&#x27;</span></span><br><span class="line">    file14_name = <span class="string">r&#x27;不同放牧强度土壤碳氮监测数据集.csv&#x27;</span></span><br><span class="line">    file15_dic = <span class="string">r&#x27;C:\Users\Desktop\2022年E题\数据集\监测点数据\附件15：草原轮牧放牧样地群落结构监测数据集（2016年6月-2020年9月）。/&#x27;</span></span><br><span class="line">    file15_name = <span class="string">r&#x27;内蒙古自治区锡林郭勒盟典型草原轮牧放牧样地群落结构监测数据集（201.xlsx&#x27;</span></span><br><span class="line">    data15 = pd.read_excel(file15_dic + file15_name, sheet_name=<span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    data14 = pd.read_csv(file14_dic + file14_name, encoding=<span class="string">&#x27;unicode_escape&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(data15.columns)</span><br><span class="line">    <span class="built_in">print</span>(data14.columns)</span><br><span class="line">    X = data14[[<span class="string">&#x27;SOC&#x27;</span>, <span class="string">&#x27;SIC&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;jyl&#x27;</span>]]</span><br><span class="line">    X = np.array(X)</span><br><span class="line">    Y = data14[<span class="string">&#x27;intensity&#x27;</span>]</span><br><span class="line">    Y = np.array(Y)</span><br><span class="line">    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=<span class="number">0.2</span>)</span><br><span class="line">    model = RandomForestRegressor(max_depth=<span class="number">10</span>, n_estimators=<span class="number">100</span>)</span><br><span class="line">    <span class="built_in">print</span>(X_train.shape, Y_train.shape)</span><br><span class="line">    model.fit(X_train, Y_train)</span><br><span class="line">    y_pred = model.predict(X_test)</span><br><span class="line">    score = model.score(X_test, Y_test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; 得分:&#x27;</span> + <span class="built_in">str</span>(score))</span><br><span class="line">    plt.figure()</span><br><span class="line">    x = np.arange(<span class="number">0</span>, <span class="number">17</span>)</span><br><span class="line">    plt.plot(x, Y_test, color=<span class="string">&#x27;#E0A97C&#x27;</span>, label=<span class="string">&quot;TRUE&quot;</span>)</span><br><span class="line">    plt.plot(x, y_pred, color=<span class="string">&#x27;#889BB7&#x27;</span>, label=<span class="string">&quot;PREDICT&quot;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line">    mse = mean_squared_error(Y_test, y_pred)</span><br><span class="line">    mae = mean_absolute_error(Y_test, y_pred)</span><br><span class="line">    rmse = np.sqrt(mean_squared_error(Y_test, y_pred))  <span class="comment"># RMSE就是对MSE开方即可</span></span><br><span class="line">    r2 = r2_score(Y_test, y_pred)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;mse: &#x27;</span>, mse, <span class="string">&#x27;mae: &#x27;</span>, mae, <span class="string">&#x27;rmse: &#x27;</span>, rmse, <span class="string">&#x27;r2: &#x27;</span>, r2)</span><br><span class="line">    model.predict([])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    load_data()</span><br></pre></td></tr></table></figure><h3 id="Q6-用来LSTM和RNN"><a href="#Q6-用来LSTM和RNN" class="headerlink" title="Q6 用来LSTM和RNN"></a>Q6 用来LSTM和RNN</h3><p>但是rnn代码丢了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> read_excel</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> LSTM</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="keyword">from</span> keras.utils.vis_utils <span class="keyword">import</span> plot_model</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决中文显示问题</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_dataset</span>(<span class="params">dataset, look_back=<span class="number">1</span></span>):</span><br><span class="line">    dataX, dataY = [], []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dataset) - look_back - <span class="number">1</span>):</span><br><span class="line">        a = dataset[i:(i + look_back), <span class="number">0</span>]  <span class="comment"># 用look_back个样本来预测一个数据</span></span><br><span class="line">        dataX.append(a)</span><br><span class="line">        dataY.append(dataset[i + look_back, <span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> np.array(dataX), np.array(dataY)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file_dic = <span class="string">r&#x27;C:\Users\Desktop\2022年E题\数据集\基本数据/&#x27;</span></span><br><span class="line">file_name = <span class="string">r&#x27;附件6、植被指数-NDVI2012-2022年.xls&#x27;</span></span><br><span class="line">data = pd.read_excel(file_dic + file_name, sheet_name=<span class="string">&#x27;sheet1&#x27;</span>, usecols=[<span class="string">&#x27;植被指数(NDVI)&#x27;</span>])</span><br><span class="line">data1 = np.array([<span class="number">165.92</span>, <span class="number">165.92</span>, <span class="number">165.92</span>, <span class="number">165.92</span>, <span class="number">165.91</span>, <span class="number">165.71</span>, <span class="number">165.46</span>, <span class="number">165.15</span>, <span class="number">164.85</span>, <span class="number">164.59</span>, <span class="number">164.49</span>, <span class="number">164.48</span>, <span class="number">12.86</span>,</span><br><span class="line">                  <span class="number">12.26</span>, <span class="number">13.48</span>, <span class="number">12.53</span>, <span class="number">10.96</span>, <span class="number">16.88</span>])</span><br><span class="line"><span class="built_in">print</span>(data.head())</span><br><span class="line">dataset = np.array(data)</span><br><span class="line"><span class="comment"># 将整型变为float</span></span><br><span class="line">dataset = dataset.astype(<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">dataset = dataset.reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 数据处理，归一化至0~1之间</span></span><br><span class="line">scaler = MinMaxScaler(feature_range=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">dataset = scaler.fit_transform(dataset)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集和测试集</span></span><br><span class="line">train_size = <span class="number">100</span></span><br><span class="line">test_size = <span class="built_in">len</span>(dataset) - train_size</span><br><span class="line">train, test = dataset[<span class="number">0</span>:train_size, :], dataset[train_size:<span class="built_in">len</span>(dataset), :]</span><br><span class="line"><span class="comment"># train, test = dataset[:30, :], dataset[:30, :]</span></span><br><span class="line"><span class="comment"># 创建测试集和训练集</span></span><br><span class="line">look_back = <span class="number">1</span></span><br><span class="line">trainX, trainY = create_dataset(train, look_back)  <span class="comment"># 单步预测</span></span><br><span class="line">testX, testY = create_dataset(test, look_back)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整输入数据的格式</span></span><br><span class="line"></span><br><span class="line">trainX = np.reshape(trainX, (trainX.shape[<span class="number">0</span>], look_back, trainX.shape[<span class="number">1</span>]))  <span class="comment"># （样本个数，1，输入的维度）</span></span><br><span class="line">testX = np.reshape(testX, (testX.shape[<span class="number">0</span>], look_back, testX.shape[<span class="number">1</span>]))</span><br><span class="line"><span class="built_in">print</span>(testX.shape)</span><br><span class="line"><span class="comment"># 创建LSTM神经网络模型</span></span><br><span class="line">model = Sequential()</span><br><span class="line"><span class="comment"># model.add(LSTM(120, unit_forget_bias=True, return_sequences=True, input_shape=(trainX.shape[1], trainX.shape[2])))</span></span><br><span class="line"><span class="comment"># model.add(Dropout(0.2))</span></span><br><span class="line"><span class="comment"># model.add(Dense(1))</span></span><br><span class="line"></span><br><span class="line">model.add(LSTM(<span class="number">20</span>, input_shape=(trainX.shape[<span class="number">1</span>], trainX.shape[<span class="number">2</span>])))  <span class="comment"># 输入维度为1，时间窗的长度为1，隐含层神经元节点个数为120</span></span><br><span class="line">model.add(Dense(<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mean_squared_error&#x27;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>)</span><br><span class="line">model.summary()</span><br><span class="line"><span class="comment"># 绘制网络结构</span></span><br><span class="line"><span class="comment"># plot_model(model, to_file=&#x27;model.png&#x27;, show_shapes=True)</span></span><br><span class="line"></span><br><span class="line">history = model.fit(trainX, trainY, epochs=<span class="number">30</span>, batch_size=<span class="number">10</span>, verbose=<span class="number">0</span>, validation_data=(testX, testY))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">trainPredict = model.predict(trainX)</span><br><span class="line">testPredict = model.predict(testX)</span><br><span class="line"><span class="comment"># print(trainPredict.shape, testPredict.shape)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 反归一化</span></span><br><span class="line">trainPredict = scaler.inverse_transform(trainPredict) + np.array([<span class="number">0.6</span>])</span><br><span class="line">trainY = scaler.inverse_transform([trainY])</span><br><span class="line">testPredict = scaler.inverse_transform(testPredict) + np.array([<span class="number">0.6</span>])</span><br><span class="line">testY = scaler.inverse_transform([testY])</span><br><span class="line"><span class="comment"># 计算得分</span></span><br><span class="line">trainScore = math.sqrt(mean_squared_error(trainY[<span class="number">0</span>], trainPredict[:, <span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Train Score: %.2f RMSE&#x27;</span> % trainScore)</span><br><span class="line">testScore = math.sqrt(mean_squared_error(testY[<span class="number">0</span>], testPredict[:, <span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Test Score: %.2f RMSE&#x27;</span> % testScore)</span><br><span class="line"></span><br><span class="line">ax1 = plt.subplot(<span class="number">121</span>)</span><br><span class="line">ax1.plot(history.history[<span class="string">&#x27;loss&#x27;</span>], label=<span class="string">&#x27;训练损失&#x27;</span>)</span><br><span class="line">ax1.plot(history.history[<span class="string">&#x27;val_loss&#x27;</span>], label=<span class="string">&#x27;验证损失&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;损失&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;轮次&#x27;</span>)</span><br><span class="line">plt.legend([<span class="string">&#x27;训练集损失&#x27;</span>, <span class="string">&#x27;验证集损失&#x27;</span>], loc=<span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(testX[-6:].shape)</span></span><br><span class="line">val = model.predict([[[testX[-<span class="number">21</span>:]]]])</span><br><span class="line">val = scaler.inverse_transform(val)</span><br><span class="line">blo = [<span class="string">&#x27;04&#x27;</span>, <span class="string">&#x27;05&#x27;</span>, <span class="string">&#x27;06&#x27;</span>, <span class="string">&#x27;07&#x27;</span>, <span class="string">&#x27;08&#x27;</span>, <span class="string">&#x27;09&#x27;</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;01&#x27;</span>, <span class="string">&#x27;02&#x27;</span>, <span class="string">&#x27;03&#x27;</span>, <span class="string">&#x27;04&#x27;</span>, <span class="string">&#x27;05&#x27;</span>, <span class="string">&#x27;06&#x27;</span>, <span class="string">&#x27;07&#x27;</span>, <span class="string">&#x27;08&#x27;</span>, <span class="string">&#x27;09&#x27;</span>]</span><br><span class="line">resl = []</span><br><span class="line">valu = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(blo)):</span><br><span class="line">    resl.append(blo[i] + <span class="built_in">str</span>(val))</span><br><span class="line">    val = scaler.fit_transform(val)</span><br><span class="line">    <span class="comment"># print(val.shape)</span></span><br><span class="line">    val = model.predict([val[-<span class="number">21</span>:]])</span><br><span class="line">    val = scaler.inverse_transform(val)</span><br><span class="line">    valu.append(val[-<span class="number">1</span>][<span class="number">0</span>]+<span class="number">0.2</span>)</span><br><span class="line"><span class="comment"># 绘</span></span><br><span class="line">trainPredictPlot = np.empty_like(dataset)</span><br><span class="line">trainPredictPlot[:, :] = np.nan</span><br><span class="line">trainPredictPlot[look_back:<span class="built_in">len</span>(trainPredict) + look_back, :] = trainPredict</span><br><span class="line">testPredictPlot = np.empty_like(dataset)</span><br><span class="line">testPredictPlot[:, :] = np.nan</span><br><span class="line">testPredictPlot[<span class="built_in">len</span>(trainPredict) + (look_back * <span class="number">2</span>) + <span class="number">1</span>:<span class="built_in">len</span>(dataset) - <span class="number">1</span>, :] = testPredict</span><br><span class="line"><span class="comment"># fig, ax = plt.figure()</span></span><br><span class="line">ax2 = plt.subplot(<span class="number">122</span>)</span><br><span class="line">ax2.plot(scaler.inverse_transform(dataset), label=<span class="string">&#x27;真实值&#x27;</span>, color=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">ax2.plot(trainPredictPlot, label=<span class="string">&#x27;训练值&#x27;</span>, color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">valu = np.array([valu]).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">testPredictPlot = np.concatenate((testPredictPlot, valu), axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># print(testPredictPlot.shape)</span></span><br><span class="line"></span><br><span class="line">ax2.plot(testPredictPlot, label=<span class="string">&#x27;预测值&#x27;</span>, color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="comment"># plt.title(name + &#x27;拟合曲线&#x27;)</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;值&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.savefig(<span class="string">&#x27;picture/lstm/&#x27;</span> + <span class="string">&#x27;Q61&#x27;</span>, bbox_inches=<span class="string">&#x27;tight&#x27;</span>, pad_inches=<span class="number">0.1</span>, dpi=<span class="number">300</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># plt.savefig(&#x27;Q3/&#x27; + &#x27;q62.jpg&#x27;, dpi=300)</span></span><br><span class="line"><span class="built_in">print</span>(resl)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里代码有些残缺，建议谨慎参考，一些地方的代码已附来源。老天保佑我拿个国三，我收回之前觉得建模简单 哭死</p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《太空堡垒卡拉狄加》终极无剧透观影顺序指南+下载链接</title>
      <link href="/2022/08/25/%E3%80%8A%E5%A4%AA%E7%A9%BA%E5%A0%A1%E5%9E%92%E5%8D%A1%E6%8B%89%E7%8B%84%E5%8A%A0%E3%80%8B%E7%BB%88%E6%9E%81%E6%97%A0%E5%89%A7%E9%80%8F%E8%A7%82%E5%BD%B1%E9%A1%BA%E5%BA%8F%E6%8C%87%E5%8D%97+%E4%B8%8B%E8%BD%BD%E9%93%BE%E6%8E%A5-the-ultimate-battlestar-galactica-spoiler-free-viewing-order/"/>
      <url>/2022/08/25/%E3%80%8A%E5%A4%AA%E7%A9%BA%E5%A0%A1%E5%9E%92%E5%8D%A1%E6%8B%89%E7%8B%84%E5%8A%A0%E3%80%8B%E7%BB%88%E6%9E%81%E6%97%A0%E5%89%A7%E9%80%8F%E8%A7%82%E5%BD%B1%E9%A1%BA%E5%BA%8F%E6%8C%87%E5%8D%97+%E4%B8%8B%E8%BD%BD%E9%93%BE%E6%8E%A5-the-ultimate-battlestar-galactica-spoiler-free-viewing-order/</url>
      
        <content type="html"><![CDATA[<p>原文网址：<a href="https://kknews.cc/entertainment/jjnora6.html">https://kknews.cc/entertainment/jjnora6.html</a><br>英文版：<a href="https://thunderpeel2001.blogspot.com/2010/02/battlestar-galactica-viewing-order.html">https://thunderpeel2001.blogspot.com/2010/02/battlestar-galactica-viewing-order.html</a><br>磁链基本都是高清或4k版本，如有更清晰的版本，务必留言、<br>如需要磁力链可以鼠标移到链接上，右键<strong>复制链接地址</strong></p><h2 id="1978老版本"><a href="#1978老版本" class="headerlink" title="1978老版本"></a>1978老版本</h2><p>注: 本指南对应从2003年开始上映的新版太空堡垒卡拉狄加系列， 为系列的重制版，有始有终，不需要从1978年原版开始看起。</p><h2 id="The-Miniseries-迷你剧"><a href="#The-Miniseries-迷你剧" class="headerlink" title="The Miniseries (迷你剧)"></a>The Miniseries (迷你剧)</h2><ul><li><a href="magnet:?xt=urn:btih:ca22675d30c1011bc3b5b86971c4c1a5bc608a56&dn=Battlestar.Galactica.Miniseries.Part1.1080p.BluRay.x264.DTS-FraMeSToR%5Brartv%5D&tr=http%3A%2F%2Ftracker.trackerfix.com%3A80%2Fannounce&tr=udp%3A%2F%2F9.rarbg.me%3A2770&tr=udp%3A%2F%2F9.rarbg.to%3A2750">Battlestar.Galactica.Miniseries.Part1</a></li><li><a href="magnet:?xt=urn:btih:611c799d221b7aaa1318a717d4bc353644917303&dn=Battlestar.Galactica.Miniseries.Part2.1080p.BluRay.x264.DTS-FraMeSToR%5Brartv%5D&tr=http%3A%2F%2Ftracker.trackerfix.com%3A80%2Fannounce&tr=udp%3A%2F%2F9.rarbg.me%3A2820&tr=udp%3A%2F%2F9.rarbg.to%3A2760">Battlestar.Galactica.Miniseries.Part2</a></li></ul><h2 id="Season-1-第一季"><a href="#Season-1-第一季" class="headerlink" title="Season 1 (第一季)"></a>Season 1 (第一季)</h2><p><a href="magnet:?xt=urn:btih:55007f35b979fb60792ab95bf5ba5ade5e300e6e&dn=Battlestar.Galactica.2003.S01.1080p.BluRay.REMUX.VC-1.DTS-HD.MA.5.1-NOGRP%5Brartv%5D&tr=http%3A%2F%2Ftracker.trackerfix.com%3A80%2Fannounce&tr=udp%3A%2F%2F9.rarbg.me%3A2850&tr=udp%3A%2F%2F9.rarbg.to%3A2860&tr=udp%3A%2F%2Ftracker.fatkhoala.org%3A13800&tr=udp%3A%2F%2Ftracker.slowcheetah.org%3A14740">Battlestar Galactica Season 1</a></p><h2 id="Season-2-第二季"><a href="#Season-2-第二季" class="headerlink" title="Season 2 (第二季)"></a>Season 2 (第二季)</h2><p><a href="magnet:?xt=urn:btih:1efc0f019de1a5f9033e683d941e16fdf775bac4&dn=Battlestar.Galactica.2003.S02.1080p.BluRay.REMUX.AVC.DTS-HD.MA.5.1-NOGRP%5Brartv%5D&tr=http%3A%2F%2Ftracker.trackerfix.com%3A80%2Fannounce&tr=udp%3A%2F%2F9.rarbg.me%3A2790&tr=udp%3A%2F%2F9.rarbg.to%3A2830&tr=udp%3A%2F%2Ftracker.fatkhoala.org%3A13790&tr=udp%3A%2F%2Ftracker.tallpenguin.org%3A15710">Battlestar Galactica Season 2</a><br>其中在第17集后看<a href="magnet:?xt=urn:btih:e825b657ac962660604e496191a77f810909c4ba&amp;dn=Battlestar.Galactica.Razor.2007.EXTENDED.1080p.BluRay.x264-LEVERAGE&amp;tr=http%3A%2F%2Ftracker.trackerfix.com%3A80%2Fannounce&amp;tr=udp%3A%2F%2F9.rarbg.me%3A2710%2Fannounce&amp;tr=udp%3A%2F%2F11.rarbg.me%3A80%2Fannounce">Battlestar Galactica Razor(Extended Version)</a></p><blockquote><p>这部电影的最后10分钟有几句台词是为第四季做的准备，如果在这里听到了那几句台词, 虽然算不上剧透，但是会影响这之后的感受，特别是第三季。<br>方法：<br>在那几句台词出现之前关闭声音和字幕，你只会看见画面上的人物在说话，但是你不会知道他们说的是什么。这几句台词过了之后再把声音和字幕打开即可。<br>这样你会完整的享受完整个电影的故事，直到看完第三季后再回来听这几句台词即可，这几句台词发生在最后的10分钟里面（不算制作人员名单），所以你可以安心放心的看前90分钟。总共只有两处需要关闭声音和字幕，会在不剧透的前提下给予提示。<br>第一处：当Hybrid用手抓住Shaw的时候立即关闭声音和字幕（Hybrid可能翻译为混合体, Shaw可能翻译为肖），当Hybrid放手后即可打开声音和字幕。<br>第二处: 在第一处后不久, 当Red One开始与总部联系的时候(Red One可能翻译为红一号), 你会听见Red One说”Actual, This is Red One, Come in”, 在这里即可关闭声音和字幕. 在红一号再次出现在画面上时即可打开声音和字幕. (其实在这之前就可以了, 不过实在是没有其他的线索可提供)</p></blockquote><p>可选项：<a href="magnet:?xt=urn:btih:D06F404C8F2F9F0C416B32303F0AA39FBABD0081&dn=Battlestar+Galactica+Razor+Flashbacks+%5BH264+Eng+Ac3+Sub+Ita%5D%5BTNTVillage%5D&tr=http%3A%2F%2Ftracker.tntvillage.scambioetico.org%3A2710%2Fannounce&tr=udp%3A%2F%2Ftracker.tntvillage.scambioetico.org%3A2710%2Fannounce&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969%2Fannounce&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80%2Fannounce&tr=udp%3A%2F%2Ftracker.publicbt.com%3A80&tr=udp%3A%2F%2Ftracker.istole.it%3A80&tr=udp%3A%2F%2Fopen.demonii.com%3A1337%2Fannounce&tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337%2Fannounce&tr=http%3A%2F%2Ftracker.openbittorrent.com%3A80%2Fannounce&tr=udp%3A%2F%2Fopentracker.i2p.rocks%3A6969%2Fannounce&tr=udp%3A%2F%2Ftracker.internetwarriors.net%3A1337%2Fannounce&tr=udp%3A%2F%2Ftracker.leechers-paradise.org%3A6969%2Fannounce&tr=udp%3A%2F%2Fcoppersurfer.tk%3A6969%2Fannounce&tr=udp%3A%2F%2Ftracker.zer0day.to%3A1337%2Fannounce">Battlestar Galactica Razor Flashbacks</a>(利刃 闪回, 网络剧, 共7集, 7集总时长18分钟左右)<br>之所以是可选项是因为这部所谓网络剧其实就是Razor电影的删减片段，有1到7的合集版。其中4个部分已经添加到加长版中，剩下的3个未加入电影的片段为1、2、7，这7集连起来是一个完整的故事，有兴趣的话可以完整看一遍。</p><p>然后继续看完第二季。</p><p><strong>The Resistance (抵抗, 网络剧, 共10集, 10集总时长25分钟左右)</strong><br><a href="https://dy.town/uploads/download/file/50046/Battlestar.Galactica.The.Resistance.Webisodes.SD.RUS.torrent">Battlestar Galactica: The Resistance</a> or <a href="https://www.youtube.com/watch?v=A1uXKLr3dyc">youtobe</a><br>这部网络剧的作用是<strong>连接第二季和第三季</strong>，有1到10的合集版，十分推荐。</p><h2 id="Season-3-第三季"><a href="#Season-3-第三季" class="headerlink" title="Season 3 (第三季)"></a>Season 3 (第三季)</h2><p><a href="magnet:?xt=urn:btih:978de315c5674d1ef31ba967f74dfaa9fb2e3771&dn=Battlestar.Galactica.2003.S03.1080p.BluRay.REMUX.VC-1.DTS-HD.MA.5.1-NOGRP%5Brartv%5D&tr=http%3A%2F%2Ftracker.trackerfix.com%3A80%2Fannounce&tr=udp%3A%2F%2F9.rarbg.me%3A2990&tr=udp%3A%2F%2F9.rarbg.to%3A2910&tr=udp%3A%2F%2Ftracker.slowcheetah.org%3A14790&tr=udp%3A%2F%2Ftracker.tallpenguin.org%3A15760">Battlestar Galactica Season 3</a><br><strong>上一季的Razor（静音部分）</strong><br>是的，你现在可以去看那最后十分钟里面静音掉的台词了。这里也是本来这部电影上映的时期，如果可以的话可以看看这十分钟之前的一些内容，重新听听Hybrid之前说的那些话，你会十分惊讶你现在居然能够明白这些话的意思了。</p><h2 id="Season-4-第四季"><a href="#Season-4-第四季" class="headerlink" title="Season 4 (第四季)"></a>Season 4 (第四季)</h2><p><a href="magnet:?xt=urn:btih:7a04f2e3f070fabed8b0d83a5d423ed00ec3c2c3&dn=Battlestar.Galactica.2003.S04.1080p.BluRay.REMUX.VC-1.DTS-HD.MA.5.1-NOGRP%5Brartv%5D&tr=http%3A%2F%2Ftracker.trackerfix.com%3A80%2Fannounce&tr=udp%3A%2F%2F9.rarbg.me%3A2990&tr=udp%3A%2F%2F9.rarbg.to%3A2770&tr=udp%3A%2F%2Ftracker.thinelephant.org%3A12740&tr=udp%3A%2F%2Ftracker.fatkhoala.org%3A13730">Battlestar Galactica Season 4</a></p><ol><li>He That Believeth In Me</li><li>Six of One</li><li>The Ties That Bind</li><li>Escape Velocity</li><li>The Road Less Traveled</li><li>Faith</li><li>Guess What’s Coming to Dinner</li><li>Sine Qua Non</li><li>The Hub</li><li>Revelations</li><li>Sometimes a Great Notion<br>11b. <a href="https://dy.town/uploads/download/file/50041/Battlestar.Galactica.Face.Of.The.Enemy.Single.File.Fanedit.HQ.torrent">The Face of the Enemy</a>、<a href="https://www.youtube.com/watch?v=dvhsSxyzvyk">在线</a> 这部网络剧十分推荐， 为之后发生的事情做了十分详细的铺垫，有1-10集的合集版。</li><li>A Disquite Follows My Soul (Extended Version) 53分钟左右加长版</li><li>The Oath</li><li>Blood on the Scales</li><li>No Exit<br>15b. <a href="magnet:?xt=urn:btih:b9bff0bf6f13504ff530687426f88cc3d2b13f76&dn=Battlestar.Galactica.The.Plan.2009.1080p.BluRay.x264.DTS-EbP&tr=http%3A%2F%2Ftracker.trackerfix.com%3A80%2Fannounce&tr=udp%3A%2F%2F9.rarbg.me%3A2780&tr=udp%3A%2F%2F9.rarbg.to%3A2970">The Plan</a> (计划, 电影)<br>这部电影本来是在全剧终后上映的，不过放在这里看效果最好。它将前两季用Cylon人的视角演绎了一遍，解答了很多问题(比如那个计划到底是什么!)，让你安心的通向结局。</li></ol><p>16-19. 一直看到最后一集即可</p><h2 id="BSG之后的衍生作品"><a href="#BSG之后的衍生作品" class="headerlink" title="BSG之后的衍生作品"></a>BSG之后的衍生作品</h2><p><a href="magnet:?xt=urn:btih:cea3f71d201c44284c1b7a2871f0616d8b5072fd&dn=Caprica.S01.1080i.BluRay.REMUX.AVC.DTS-HD.MA.5.1-NOGRP%5Brartv%5D&tr=http%3A%2F%2Ftracker.trackerfix.com%3A80%2Fannounce&tr=udp%3A%2F%2F9.rarbg.me%3A2890&tr=udp%3A%2F%2F9.rarbg.to%3A2800&tr=udp%3A%2F%2Ftracker.fatkhoala.org%3A13750&tr=udp%3A%2F%2Ftracker.tallpenguin.org%3A15790">Caprica</a> (全一季共18集)<br>这部剧的时间线是在BSG的前58年，很多人把这个剧当做前传放在BSG之前看，不过个人不推荐这么做：并不是这部剧不好，其原因是Caprica跟BSG太不一样了，导致很多人对BSG的内容产生了误解。打个比方的话，如果说BSG是政治剧的话那么Caprica就是家庭剧。有兴趣可以在BSG之后看，不过需要注意的是这部剧在第一季之后就被砍了，所以剧情方面是肯定有问题的。</p><p>Blood and Chrome (电影)<br>这本来是想要作为一部新剧播出的， 但各种原因导致其最终变为了一部电影。时间线在Caprica之后BSG之前，这部电影里面没有任何BSG正剧的剧透，所以任何时候看都没有问题。 目前这部电影有3个版本，一个是分为10集的电视版(连起来看就是这部电影，<a href="magnet:?xt=urn:btih:012500751652a4d8616adaceeed3b51d803d29bb&dn=Battlestar.Galactica.Blood.and.Chrome.2012.1080p.BluRay.x264-GECKOS&tr=http%3A%2F%2Ftracker.trackerfix.com%3A80%2Fannounce&tr=udp%3A%2F%2F9.rarbg.me%3A2930&tr=udp%3A%2F%2F9.rarbg.to%3A2890">合集版</a>)，另外两个分别是分级版和未分级版。</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>至此已施工完毕，建议先看参考网址的英文版，没时间看中文版，然后再看我这部分，如有遗漏欢迎留言。</p>]]></content>
      
      
      <categories>
          
          <category> 琐言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Movie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Delving into Deep Imbalanced Regression笔记</title>
      <link href="/2022/08/17/Delving%20into%20Deep%20Imbalanced%20Regression%E7%AC%94%E8%AE%B0-dir-note/"/>
      <url>/2022/08/17/Delving%20into%20Deep%20Imbalanced%20Regression%E7%AC%94%E8%AE%B0-dir-note/</url>
      
        <content type="html"><![CDATA[<p>DIR</p><h2 id="难点："><a href="#难点：" class="headerlink" title="难点："></a>难点：</h2><ul><li><p>现实中，数据不平衡随处可见，通常是带长尾的偏态分布，其中某些标签的值很少。</p></li><li><p>解决不平衡的分类任务的方法具有局限性，它们只适合分类任务，主要关注于类别的不平衡，直接用于连续数据会产生歧义以及忽略了连续数据中每个数据周围的信息。</p></li><li><p>解决不平衡的回归任务没有很好的探索过，没有考虑目标间的信息，同时对于极高维度的数据来说，线性插值不会产生有意义的样本</p></li></ul><h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><ul><li><p>提出了LDS</p><ol><li><p>由“Figure 2.” [Yang 等。, 2021, p. 3] 可以看出分类和连续的区别</p></li><li><p>原因是所有不平衡学习方法是通过改善经验标签密度分布的不平衡来进行的，没有学习到临近标签的数据样本间的依赖性</p></li><li><p>因此提出LDS，它提倡使用核密度估计来学习连续标签的不平衡区域</p></li><li><p>由“Figure 3.” [Yang 等。, 2021, p. 3] 可以看出连续问题可能转化成分类问题，因此可以使用不平衡的分类方法，如重加权、重采样</p></li></ol></li><li><p>提出了FDS</p><ol><li><p>作者认为有目标空间的连续性，应该也有特征空间的连续性</p></li><li><p>首先从“Figure 4.” [Yang 等。, 2021, p. 4] 可以看出在样本很多的区域，它们的均值和方差的余弦相似度相似且高，但是在少样本区域也表现得很高（因为数据不平衡，它们从数据量大的区域学习它们学习到的值）</p></li><li><p>因此提出FDS，它通过对称核来平衡目标的均值和<strong>协</strong>方差，进行特征空间分布平滑</p></li><li><p>它可以整合到任何神经网络和改善标签不平衡的工作中来提升性能。</p></li></ol></li><li><p>整理出五个DIR基准数据集。</p></li></ul><h2 id="实验及结果"><a href="#实验及结果" class="headerlink" title="实验及结果"></a>实验及结果</h2><ul><li><p>应用不平衡回归任务的方法在高维数据上时性能不好，vanilla模型在manyshot区域易过拟合</p></li><li><p>添加了LDS+FDS取得最好结果，并且提高了all-, many-, medium-, few-shot区域的性能</p></li><li><p>LDS和FDS在有数据区域和无数据区域都取得收益，具体来说，内插和外插都有提升，内插最多。</p></li><li><p>“Figure 8” [Yang 等。, 2021, p. 8] 表明了FDS可以很好的校准统计数据，使得尽在其周围具有高相似度，并随着目标值变大，相似度下降。此外运行统计数据和平滑统计数据的L1距离随训练进行而减少。</p></li><li><p>Gaussian核带来最优结果</p></li><li><p>LDS和FDS对不同的损失函数具有鲁棒性</p></li><li><p>核大小最好为5，标准差最好为2，且都不同的超参数大小都有鲁棒性</p></li><li><p>LDS和FDS对不同偏态标签密度的鲁棒性好</p></li><li><p>另外发现了不平衡的分类方法在回归上应用不好的原因：首先，忽略了连续目标周围数据的相似性；其次，分类无法在连续空间内进行外插和内插，因此无法处理缺失数据</p></li></ul><p>其他博客介绍</p><ul><li><p><a href="https://blog.csdn.net/qq_43310834/article/details/119969513">https://blog.csdn.net/qq_43310834&#x2F;article&#x2F;details&#x2F;119969513</a></p></li><li><p><a href="https://blog.csdn.net/qq_43349542/article/details/120370049">https://blog.csdn.net/qq_43349542&#x2F;article&#x2F;details&#x2F;120370049</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自用</title>
      <link href="/2022/08/17/%E8%87%AA%E7%94%A8-zi-yong/"/>
      <url>/2022/08/17/%E8%87%AA%E7%94%A8-zi-yong/</url>
      
        <content type="html"><![CDATA[<p>轮播图 图片懒加载：<a href="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo%2Findex%2Flazyload_h.gif">https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo%2Findex%2Flazyload_h.gif</a><br>轮播图：-|||–|||-<a href="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/index/jolly.png-|||-#=====">https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/index/jolly.png-|||-#=====</a><br>-|||–|||-<a href="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/index/be_a_nice_man.png-|||-#">https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/index/be_a_nice_man.png-|||-#</a></p><p>歌单id 779071192</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Delving into Deep Imbalanced Regression翻译</title>
      <link href="/2022/08/16/Delving%20into%20Deep%20Imbalanced%20Regression%E7%BF%BB%E8%AF%91-delving-into-dir-translation/"/>
      <url>/2022/08/16/Delving%20into%20Deep%20Imbalanced%20Regression%E7%BF%BB%E8%AF%91-delving-into-dir-translation/</url>
      
        <content type="html"><![CDATA[<p>非对照翻译，有所简略。翻译不对，尽情谅解，可留言<br>因为halo渲染的原因，有些地方可能不对，请留言<br><a href="https://zhuanlan.zhihu.com/p/369627086">作者解释</a>  and  <a href="https://arxiv.org/abs/2102.09554">paper</a></p><p><a href="https://www.keepjolly.com/archives/dir-note">自己做的笔记</a><br><a name="U6BAc"></a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>&amp;emsp;&amp;emsp;Real-world data often exhibit imbalanced distributions, where certain target values have significantly fewer observations. Existing techniques for dealing with imbalanced data focus on targets with categorical indices, i.e., different classes. However, many tasks involve continuous targets, where hard boundaries between classes do not exist. We define Deep Imbalanced Regression (DIR) as learning from such imbalanced data with continuous targets, dealing with potential missing data for certain target values, and generalizing to the entire target range. Motivated by the intrinsic difference between categorical and continuous label space, we propose distribution smoothing for both labels and features, which explicitly acknowledges the effects of nearby targets, and calibrates both label and learned feature distributions. We curate and benchmark large-scale DIR datasets from common real-world tasks in computer vision, natural language processing, and healthcare domains. Extensive experiments verify the superior performance of our strategies. Our work fills the gap in benchmarks and techniques for practical imbalanced regression problems. Code and data are available at: <a href="https://github.com/YyzHarry/imbalanced-regression">https://github.com/YyzHarry/imbalanced-regression</a>.<br>&amp;emsp;&amp;emsp;现实世界的数据往往是不平衡分布，其中某些target值的观测数据很少。处理不平衡数据的现存方法都侧重于具有分类索引的target（已经标好数据的数据集？数据都标出了类别），如不同的类别。然而，很多任务涉及到连续目标，其中类之间不存在清晰边界。我们称深度不平衡回归（DIR）为从此类含连续目标的不平衡数据中学习，处理某些target值的潜在缺失值，并泛化到整个target范围。受分类和连续标签空间之间固有差异的激发，我们建议对标签和特征的进行平滑分布，这承认了临近目标的影响，并校准标签和学习到的特征分布。我们从计算机视觉、自然语言处理和医疗领域的常见现实世界任务中评估该大型 DIR 数据集。大量实验验证了我们策略的卓越性能。我们的工作填补了实际中的不平衡回归问题的基准数据集和技术方面的空白。</p><p><a name="cH3xw"></a></p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>&amp;emsp;&amp;emsp;Data imbalance is ubiquitous and inherent in the real world. Rather than preserving an ideal uniform distribution over each category, the data often exhibit <a href="https://www.statisticshowto.com/probability-and-statistics/skewed-distribution/">skewed distributions</a> with a long tail (<a href="https://arxiv.org/abs/1710.05381?context=cs.AI">Buda et al., 2018</a>; <a href="https://arxiv.org/abs/1904.05160">Liu et al., 2019</a>), where certain target values have significantly fewer observations. This phenomenon poses great challenges for deep recognition models, and has motivated many prior techniques for addressing data imbalance (<a href="https://arxiv.org/abs/1906.07413">Cao et al., 2019</a>; <a href="https://arxiv.org/abs/1901.05555">Cui et al., 2019</a>; <a href="https://arxiv.org/abs/1806.00194">Huang et al., 2019</a>; <a href="https://arxiv.org/abs/1904.05160">Liu et al., 2019</a>; <a href="https://arxiv.org/abs/2009.12991">Tang et al., 2020</a>).<br>&amp;emsp;&amp;emsp;在现实中，数据的不平衡是常见且固有的。与在每个类别上保持理想的均匀分布不同，数据经常表现出带有长尾的偏态分布，其中某些目标值的观测值十分少。该现象对深度识别模型提出了巨大的挑战，并激发许多现有技术去处理数据不平衡。</p><p>&amp;emsp;&amp;emsp;Existing solutions for learning from imbalanced data, however, focus on targets with categorical indices, i.e., the targets are different classes. However, many real-world tasks involve continuous and even infinite target values. For example, in vision applications, one needs to infer the age of different people based on their visual appearances, where age is a continuous target and can be highly imbalanced. Treating different ages as distinct classes is unlikely to yield the best results because it does not take advantage of the similarity between people with nearby ages. Similar issues happen in medical applications since many health metrics including heart rate, blood pressure, and oxygen saturation, are continuous and often have skewed distributions across patient populations.<br>&amp;emsp;&amp;emsp;然而，现有从不平衡数据中学习的方案侧重于带分类索引的目标，如目标是不同的类别（有多个目标还是目标有多个label值？应该是每个目标都标出了独立类别）。但，许多现实任务涉及连续且无限的目标值。如，在视觉应用中，需要根据他们的外貌来推断他们的年龄，其中年龄是连续值并且可能高度不平衡。把不同年龄视为独立类别不太可能产生最佳结果，因为它没有利用年龄相近的人的相似性。类似的问题也发生在医疗应用中，因为包括心率、血压和血氧饱和度在内的许多健康指标是连续的，并且在患者群体中通常是偏态分布。</p><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2022/08/20220816201758.png" alt="alt" title="Figure 1. Deep Imbalanced Regression (DIR) aims to learn from imbalanced data with continuous targets, tackle potential missing data for certain regions, and generalize to the entire target range.图一   DIR旨在从带连续目标的不平衡数据中学习，解决某些区域的潜在缺失数据并泛化到整个目标范围"></p><style type="text/css" rel="stylesheet">figure {   font-size: 13px; font-weight: normal; color: #8c8c8c; text-align: center;}</style><figure >Figure 1. Deep Imbalanced Regression (DIR) aims to learn from imbalanced data with continuous targets, tackle potential missing data for certain regions, and generalize to the entire target range.<p>图一   DIR旨在从带连续目标的不平衡数据中学习，解决某些区域的潜在缺失数据并泛化到整个目标范围</figure></p><p>&amp;emsp;&amp;emsp;In this work, we systematically investigate Deep Imbalanced Regression (DIR) arising in real-world settings (see Fig. 1). We define DIR as learning continuous targets from natural imbalanced data, dealing with potentially missing data for certain target values, and generalizing to a test set that is balanced over the entire range of continuous target values. This definition is analogous to the class imbalance problem (<a href="https://arxiv.org/abs/1904.05160">Liu et al., 2019</a>), but focuses on the continuous setting.<br>&amp;emsp;&amp;emsp;在这项工作中，我们系统地研究了在现实中出现的DIR。我们把DIR定义为从自然的不平衡数据中学习到连续的目标，然后处理某些目标值潜在缺失数据，并泛化到整个连续目标值范围内是平衡的测试集。这个定义类似于类不平衡问题，但侧重于连续。</p><p>&amp;emsp;&amp;emsp;DIR brings new challenges distinct from its classification counterpart. First, given continuous (potentially infinite) target values, the hard boundaries between classes no longer exist, causing ambiguity when directly applying traditional imbalanced classification methods such as re-sampling and re-weighting. Moreover, continuous labels inherently possess a meaningful distance between targets, which has implication for how we should interpret data imbalance. For example, say two target labels $t1$ and $t2$ have a small number of observations in training data. However, $t1$ is in a highly represented neighborhood (i.e., there are many samples in the range $\left [ t1- \bigtriangleup , t1+  \bigtriangleup  \right ]$), while $t2$ is in a weakly represented neighborhood. In this case,$t1$ does not suffer from the same level of imbalance as $t2$. Finally, unlike classification, certain target values may have no data at all, which motivates the need for target extrapolation &amp; interpolation.<br>&amp;emsp;&amp;emsp;DIR带来了不同于其它分类任务的新挑战。首先，给定了连续（可能无限的）目标值，类间的边界不再存在，从而直接使用传统的不平衡分类方法（如重采样和重加权）时会导致歧义。此外，连续标签在目标之间本身具有有意义的distance，这对我们如何解释数据不平衡有影响。如，假设两个目标标签$t1$和$t2$在训练集中只有小部分的观测值。然而$t1$在一个相当高的表示域内（即，在$\left [ t1- \bigtriangleup , t1+  \bigtriangleup  \right ]$ 内有许多样本，而$t2$在一个低的表示域内）在这种例子下，$t1$不会遭受与$t2$相同程度的不平衡。最后，不同于分类任务，某些目标值可能根本没有数据，这激发了对目标extrapolation 和 interpolation的需求。</p><p>&amp;emsp;&amp;emsp;In this paper, we propose two simple yet effective methods for addressing DIR: label distribution smoothing (LDS) and feature distribution smoothing (FDS). A key idea underlying both approaches is to leverage the similarity between nearby targets by employing a kernel distribution to perform explicit distribution smoothing in the label and feature spaces. Both techniques can be easily embedded into existing deep networks and allow optimization in an end-to-end fashion. We verify that our techniques not only successfully calibrate for the intrinsic underlying imbalance, but also provide large and consistent gains when combined with other methods. To support practical evaluation of imbalanced regression, we curate and benchmark large-scale DIR datasets for common real-world tasks in computer vision, natural language processing, and healthcare. They range from single-value prediction such as age, text similarity score, health condition score, to dense-value prediction such as depth. We further set up benchmarks for proper DIR performance evaluation.<br>&amp;emsp;&amp;emsp;在本文中，我们提出两个简单高效的方法来解决DIR：标签分布平滑和特征分布平滑。两个方法的关键思想是通过使用核分布在标签和特征空间中执行显式的分布平滑来利用临近目标间的相似性。每个方法都能轻易嵌入到现在的深度网络中并允许以端到端的方式进行优化。我们验证了我们的方法不仅成功地校准了固有的潜在不平衡，而且与其他方法结合时提供了巨大而一致的收益。为了支持不平衡回归的实际评估，我们为计算机视觉、自然语言处理和医疗中的常见现实任务中整理了和基准测试了大规模 DIR 数据集。这些数据集从单值预测（如年龄，文本相似度得分和健康状况得分）到密集值的预测（如深度）。我们进一步为合适的DIR性能评估建立了基准。</p><p>Our contributions are as follows: </p><ul><li>We formally define the DIR task as learning from imbalanced data with continuous targets, and generalizing to the entire target range. DIR provides thorough and unbiased evaluation of learning algorithms in practical settings. </li><li>We develop two simple, effective, and interpretable algorithms for DIR, LDS and FDS, which exploit the similarity between nearby targets in both label and feature space. </li><li>We curate benchmark DIR datasets in different domains: computer vision, natural language processing, and healthcare. We set up strong baselines as well as benchmarks for proper DIR performance evaluation. </li><li>Extensive experiments on large-scale DIR datasets verify the consistent and superior performance of our strategies.</li></ul><p>我们的贡献如下：</p><ul><li>我们将DIR任务定义为从带连续目标的不平衡数据中学习，并泛化到整个目标范围内。DIR在实际环境中对学习算法进行完全的公正的评估。</li><li>我们为DIR、LDS和FDS设计了两个简单高效且可解释的算法，算法利用了标签和特征空间中临近目标的相似性</li><li>我们在不同领域管理DIR基准数据集。我们为DIR性能评估建立了强大的基线和基准。</li><li>在大规模DIR数据集上进行的大量实验验证了我们方法的一致性和卓越的性能。<br><a name="iAF2C"></a></li></ul><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><p>&amp;emsp;&amp;emsp;<strong>Imbalanced Classification.</strong> Much prior work has focused on the imbalanced classification problem (also referred to as long-tailed recognition (<a href="https://arxiv.org/abs/1904.05160">Liu et al., 2019</a>)). Past solutions can be divided into data-based and model-based solutions: Data-based solutions either over-sample the minority class or under-sample the majority (<a href="https://www.jair.org/index.php/jair/article/view/10302">Chawla et al., 2002</a>; <a href="https://ieeexplore.ieee.org/document/6793456">Garc´ıa &amp; Herrera, 2009</a>; <a href="https://ieeexplore.ieee.org/document/4633969">He et al., 2008</a>). For example, SMOTE generates synthetic samples for minority classes by linearly interpolating samples in the same class (<a href="https://www.jair.org/index.php/jair/article/view/10302">Chawla et al., 2002</a>). Model-based solutions include re-weighting or adjusting the loss function to compensate for class imbalance (<a href="https://arxiv.org/abs/1906.07413">Cao et al., 2019</a>; <a href="https://arxiv.org/abs/1901.05555">Cui et al., 2019</a>; <a href="https://arxiv.org/abs/1804.10851">Dong et al., 2019</a>; <a href="https://ieeexplore.ieee.org/document/7780949">Huang et al., 2016</a>; <a href="https://arxiv.org/abs/1806.00194">2019</a>), and leveraging relevant learning paradigms, including transfer learning (<a href="https://arxiv.org/abs/1803.09014">Yin et al., 2019</a>), metric learning (<a href="https://arxiv.org/abs/1611.08976">Zhang et al., 2017</a>), meta-learning (<a href="https://arxiv.org/abs/1902.07379">Shu et al., 2019</a>), and two-stage training (<a href="https://arxiv.org/abs/1910.09217">Kang et al., 2020</a>). Recent studies have also discovered that semi-supervised learning and selfsupervised learning lead to better imbalanced classification results (<a href="https://arxiv.org/abs/2006.07529?amp=1">Yang &amp; Xu, 2020</a>). In contrast to these past work, we identify the limitations of applying class imbalance methods to regression problems, and introduce new techniques particularly suitable for learning continuous target values.<br>&amp;emsp;&amp;emsp;不平衡分类。大量的先前工作都集中于不平衡分类问题（也称为长尾识别问题）上。过去的解决方案可以分为基于数据和基于模型：基于数据的方案要么在少数类上过采样或在大多数上缺采样。如，SMOTE为少数类别生成人造样本通过在相同类别的样本中线性插值。基于模型的方案包括重加权或调整损失函数来弥补类别不平衡（yolo的大小目标的超参数），并利用相关的学习范式，包括迁移学习、度量学习、元学习和二阶段训练。最近研究也发现半监督学习和自监督学习会产生不平衡分类问题的好结果。与过去工作相比，我们发现在回归问题上应用类别不平衡方法的局限性，并引入特别适合学习连续目标值的新方法。</p><p>&amp;emsp;&amp;emsp;<strong>Imbalanced Regression.</strong> Regression over imbalanced data is not as well explored. Most of the work on this topic is a direct adaptation of the SMOTE algorithm to regression scenarios (Branco et al., 2017; 2018; Torgo et al., 2013). Synthetic samples are created for pre-defined rare target regions by either directly interpolating both inputs and targets (Torgo et al., 2013), or using Gaussian noise augmentation (Branco et al., 2017). A bagging-based ensemble method that incorporates multiple data pre-processing steps has also been introduced (Branco et al., 2018). However, there exist several intrinsic drawbacks for these methods. First, they fail to take the distance between targets into account, and rather heuristically divide the dataset into rare and frequent sets, then plug in classification-based methods. Moreover, modern data is of extremely high dimension (e.g., images and physiological signals); linear interpolation of two samples of such data does not lead to meaningful new synthetic samples. Our methods are intrinsically different from past work in their approach. They can be combined with existing methods to improve their performance, as we show in Sec. 4. Further, our approaches are tested on large-scale real-world datasets in computer vision, NLP, and healthcare.<br>&amp;emsp;&amp;emsp;不平衡回归。在不平衡数据上回归也没有很好的探索过。大多数的工作是SMOTE算法的直接调整到回归场景。通过直接在输入和目标上插值或使用高斯噪声增强技术，来为预定义的稀少目标区域（样本很少的地方）创造人造样本。还引入一个基于bagging的集成方法，它包含多个数据预处理步骤。但是，这些方法存在几个固有的缺陷。首先，它们没有考虑目标间的distance，而是启发式地把数据集分成rare集和frequent集，然后插入基于分类的方法。此外，极高维度的现代数据（如，图片和生理信号）对此类数据的两个样本进行线性插值不会产生有意义的新合成样本。我们的方法本质上同先前方法不同。它们可以结合现有方法来提高性能，如Sec.4所示。此外，我们的方法在视觉、NLP和医疗的大规模数据集上测试过。<br><a name="pchzD"></a></p><h2 id="3-Methods"><a href="#3-Methods" class="headerlink" title="3. Methods"></a>3. Methods</h2><p>&amp;emsp;&amp;emsp;<strong>Problem Setting.</strong>   $<code> \left\&#123;\left(x_i,y_i\right)\right\&#125;_&#123;i=1&#125;^N</code>$ be a training set, where$<code>x_i\in \mathbb&#123;R&#125; ^d </code>$ denotes the input and$y_i\in \mathbb{R}$ is the label, which is a continuous target. We introduce an additional structure for the label space $\mathcal{Y}$ , where we divide $\mathcal{Y}$ into $B$ <a href="https://datavizguru.com/tableau/groups-vs-sets-vs-bins-vs-parameters/">groups (bins)</a> with equal intervals, i.e., $\left [ y_0, y_1\right ), \left [ y_1, y_2\right ), \cdots  , \left [ y_{B-1}, y_B\right )$. Throughout the paper, we use $b \in \mathcal{B}$ to denote the group index of the target value, where $\mathcal{B} &#x3D; \left {  1, \dots , B\right } \subset \mathbb{Z}^+$ is the index space. In practice, the defined bins reflect a minimum resolution we care for grouping data in a regression task. For instance, in age estimation, we could define $\delta y \triangleq y_{b+1}-y_{b}&#x3D;1$, showing a minimum age difference of 1 is of interest. Finally, we denote $\mathrm {z} &#x3D;f\left ( x;\theta  \right )$as the feature for $\mathrm {x}$, where $f\left ( x;\theta  \right )$ is parameterized by a deep neural network model with parameter $\theta$. The final prediction $\hat{y}$ is given by a regression function $g(\cdot)$ that operates over $\mathbf{  \mathrm {z}}$.<br>&amp;emsp;&amp;emsp;问题设置。让 $\left { \left ( x_i, y_i \right )  \right }^N_{i&#x3D;1}$作为训练集，其中$x_i\in \mathbb{R} ^d$表示输入，$y_i\in \mathbb{R}$表示标签，是连续目标值。我们为标签空间$\mathcal{Y}$引入额外的结构，其中我们把$\mathcal{Y}$分成等间隔的B组（箱），即$\left [ y_0, y_1\right ), \left [ y_1, y_2\right ), \cdots  , \left [ y_{B-1}, y_B\right )$。在整个文章中，我们使用$b \in \mathcal{B}$表示目标值的组索引，其中 $\mathcal{B} &#x3D; \left {  1, \dots , B\right } \subset \mathbb{Z}^+$是索引空间。实际上，定义的bins反应了我们在回归任务中对数据分组时关心的最小分辨率。例如，在年龄评估上，我们可以定义$\delta y \triangleq y_{b+1}-y_{b}&#x3D;1$，表明最小年龄差为1是有用的。最终，我们把 $\mathrm {z} &#x3D;f\left ( x;\theta  \right )$表示x的特征，其中$f\left ( x;\theta  \right )$是通过具有参数$\theta$的深度神经网络参数化的。最终的预测 $\hat{y}$是通过 一个在$\mathbf{  \mathrm {z}}$上运行的回归函数$g(\cdot)$给出。<br><a name="jWbVx"></a></p><h3 id="3-1-Label-Distribution-Smoothing"><a href="#3-1-Label-Distribution-Smoothing" class="headerlink" title="3.1. Label Distribution Smoothing"></a>3.1. Label Distribution Smoothing</h3><p>&amp;emsp;&amp;emsp;We start by showing an example to demonstrate the difference between classification and regression when imbalance comes into the picture.<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2022/08/20220816201758-1.png" alt="image.png" title="Figure 2. Comparison on the test error distribution (bottom) using same training label distribution (top) on two different datasets: (a) CIFAR-100, a classification task with categorical label space. (b) IMDB-WIKI, a regression task with continuous label space.图二。在两个不同的数据集上使用相同的训练标签分布来比较测试error分布(bottom)：(a)CIFAR-100，具有分类的标签空间的分类任务。(b)IMDB-WIKI，具有连续标签空间的回归任务"></p><figure>Figure 2. Comparison on the test error distribution (bottom) using same training label distribution (top) on two different datasets: (a) CIFAR-100, a classification task with categorical label space. (b) IMDB-WIKI, a regression task with continuous label space.  <p>图二。在两个不同的数据集上使用相同的训练标签分布来比较测试error分布(bottom)：(a)CIFAR-100，具有分类的标签空间的分类任务。(b)IMDB-WIKI，具有连续标签空间的回归任务</figure></p><p>&amp;emsp;&amp;emsp;<strong>Motivating Example.</strong> We employ two datasets: (1) CIFAR100 (Krizhevsky et al., 2009), which is a 100-class classification dataset, and (2) the IMDB-WIKI dataset (Rothe et al., 2018), which is a large-scale image dataset for age estimation from visual appearance. The two datasets have intrinsically different label space: CIFAR-100 exhibits categorical label space where the target is class index, while IMDB-WIKI has a continuous label space where the target is age. We limit the age range to $0 \sim  99$ so that the two datasets have the same label range, and subsample them to simulate data imbalance, while ensuring they have exactly the same label density distribution (Fig. 2). We make both test sets balanced. We then train a plain ResNet-50 model on the two datasets, and plot their test error distributions.<br>&amp;emsp;&amp;emsp;我们使用两个数据集：CIFAR100，它是一个100类的分类数据集；IMDB-WIKI，它是从外貌来估计年龄的大规模图片数据集。这两个数据集具有完全不同的标签空间：CIFAR100的类别标签空间中目标值是类别索引，而IMDB-WIKI是目标值是年龄的连续样本空间我们限制年龄到0~99使得两个数据集有相同的标签范围，并且下采样来模拟数据不平衡，同时保持它们具有相同的标签密度分布（图2）。我们保持两个测试集平滑。然后在两个数据集上训练plain ResNet-50，并绘制出它们的测试误差分布。</p><p>&amp;emsp;&amp;emsp;We observe from Fig. 2(a) that the error distribution correlates with label density distribution. Specifically, the test error as a function of class index has a high negative Pearson correlation with the label density distribution (i.e., -0.76) in the categorical label space. The phenomenon is expected, as majority classes with more samples are better learned than minority classes. Interestingly however, as Fig. 2(b) shows, the error distribution is very different for IMDB-WIKI with continuous label space, even when the label density distribution is the same as CIFAR-100. In particular, the error distribution is much smoother and no longer correlates well with the label density distribution (-0.47).<br>&amp;emsp;&amp;emsp;在图2，我们观察到误差分布与标签密度分布相关。特别的，作为一个类别索引的函数，测试误差与分类标签空间的标签密度分布中有特别高的负Pearson相关性（即-0.76）。这种现象是预期的，因为多数类有更多的样本比少数类更易训练。但有趣的是，如图2(b)所示，误差分布在IMDB-WIKI十分不同，即使当标签密度空间与CIFAR-100相同。特别是误差分布更平滑并且不再跟标签密度分布相关（-0.47）。</p><p>&amp;emsp;&amp;emsp;The reason why this example is interesting is that all imbalanced learning methods, directly or indirectly, operate by compensating for the imbalance in the empirical label density distribution. This works well for class imbalance, but for continuous labels the empirical density does not accurately reflect the imbalance as seen by the neural network. Hence, compensating for data imbalance based on empirical label density is inaccurate for the continuous label space.<br>这个例子的原因是所有不平衡学习方法都直接或间接的通过改善经验标签密度分布的不平衡来操作。这对于类不平衡有效，但对于连续标签，经验密度不能准确反应通过神经网络看到的不平衡。因此，对于连续标签空间，基于经验标签密度来改善数据不平衡是不正确的</p><blockquote><p>&amp;emsp;&amp;emsp;An empirical distribution is <strong>one for which each possible event is assigned a probability derived from experimental observation</strong>. It is assumed that the events are independent and the sum of the probabilities is 1.也就是直接观测到的标签密度。</p></blockquote><p>&amp;emsp;&amp;emsp;<strong>LDS for Imbalanced Data Density Estimation.</strong> The above example shows that, in the continuous case, the empirical label distribution does not reflect the real label density distribution. This is because of the dependence between data samples at nearby labels (e.g., images of close ages). In fact, there is a significant literature in statistics on how to estimate the expected density in such cases (Parzen, 1962). Thus, Label Distribution Smoothing (LDS) advocates the use of kernel density estimation to learn the effective imbalance in datasets that corresponds to continuous targets.<br><a href="https://www.cnblogs.com/ljwgis/p/15471550.html">用于不平衡数据密度估计的LDS</a>。上述例子表明，在连续情况下，经验标签密度不能反映真实标签密度分布。这是因为相近标签的数据样本之间存在依赖性（如年龄相近的图片）。事实上，关于如何估计在这种情况下的预期密度，统计学有大量的统计文献。因此，LDS提倡使用核密度估计来学习数据集对应连续标签值的有效区域的不平衡。</p><p>&amp;emsp;&amp;emsp;LDS convolves a symmetric kernel with the empirical density distribution to extract a kernel-smoothed version that accounts for the overlap in information of data samples of nearby labels. A symmetric kernel is any kernel that satisfies: $\mathrm{k}\left(y, y^{\prime}\right)&#x3D;\mathrm{k}\left(y^{\prime}, y\right)$and$\nabla_{y} \mathrm{k}\left(y, y^{\prime}\right)+\nabla_{y^{\prime}} \mathrm{k}\left(y^{\prime}, y\right)&#x3D;0 ,  \forall y, y^{\prime} \in \mathcal{Y}$. Note that a Gaussian or a Laplacian kernel is a symmetric kernel, while $\mathrm{k}\left(y, y^{\prime}\right) &#x3D; yy^{\prime}$ is not. The symmetric kernel characterizes the similarity between target values $y^{\prime}$ and any $y$ w.r.t. their distance in the target space. Thus, LDS computes the effective label density distribution as:<br>&amp;emsp;&amp;emsp;LDS将对称核与经验密度分布卷积来提取核平滑版本，该版本负责相邻标签的数据样本的信息重叠。一个对称核只要满足$\mathrm{k}\left(y, y^{\prime}\right)&#x3D;\mathrm{k}\left(y^{\prime}, y\right)$和$\nabla_{y} \mathrm{k}\left(y, y^{\prime}\right)+\nabla_{y^{\prime}} \mathrm{k}\left(y^{\prime}, y\right)&#x3D;0 ,  \forall y, y^{\prime} \in \mathcal{Y}$就行。注意Gaussian或Laplaian核是对称核，但当$\mathrm{k}\left(y, y^{\prime}\right) &#x3D; yy^{\prime}$时就不是。对称核表示目标值y’和任何y关于(w.r.t&#x3D;with respect to)目标空间的距离。因此，LDS计算有效的标签密度分布公式为：</p><p>$$\tilde{p}\left(y^{\prime}\right) \triangleq \int_{\mathcal{Y}} \mathrm{k}\left(y, y^{\prime}\right) p(y) d y\qquad(1) $$<br>where $p(y)$ is the number of appearances of label of y in the training data, and $\tilde{p}(y^{\prime} )$ is the effective density of label$y^{\prime}$.<br>其中p(y)是在训练数据中y标签的出现次数，并且 $\tilde{p}(y^{\prime} )$ 是标签y’的有效密度<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2022/08/20220816201758-2.png" alt="image.png" title="Figure 3.  Label distribution smoothing (LDS) convolves a symmetric kernel with the empirical label density to estimate the effective label density distribution that accounts for the continuity of labels.                图3.标签分布平滑LDS，将对称核与经验标签密度进行卷积，以估计说明标签连续性的有效的标签密度分布。"></p><figure>Figure 3.  Label distribution smoothing (LDS) convolves a symmetric kernel with the empirical label density to estimate the effective label density distribution that accounts for the continuity of labels.                  图3.标签分布平滑LDS，将对称核与经验标签密度进行卷积，以估计说明标签连续性的有效的标签密度分布。</figure>  <p>&amp;emsp;&amp;emsp;Fig. 3 illustrates LDS and how it smooths the label density distribution. Further, it shows that the resulting label density computed by LDS correlates well with the error distribution (-0.83). This demonstrates that LDS captures the real imbalance that affects regression problems.<br>&amp;emsp;&amp;emsp;图3解释了LDS和它如何平滑标签密度分布。此外，它表明由LDS计算得到的标签密度与误差分布有很好的相关性(-0.83)。这说明了LDS捕获到了影响回归任务的真正不平衡。</p><p>&amp;emsp;&amp;emsp;Now that the effective label density is available, techniques for addressing class imbalance problems can be directly adapted to the DIR context. For example, a straightforward adaptation can be the cost-sensitive re-weighting method, where we re-weight the loss function by multiplying it by the inverse of the LDS estimated label density for each target. We show in Sec. 4 that LDS can be seamlessly incorporated with a wide range of techniques to boost DIR performance.<br>&amp;emsp;&amp;emsp;既然有效的标签密度是可用的，为了解决类不平衡问题的技术可以直接用于DIR环境。例如，一个简单的调整是关于成本敏感的方法，其中我们通过将损失函数乘上每个目标的LDS估计标签密度的倒数来重新加权损失函数。我们在Sec.4展示了LDS可以无缝结合大量的方法来提高DIR的性能。<br><a name="yzgyN"></a></p><h3 id="3-2-Feature-Distribution-Smoothing"><a href="#3-2-Feature-Distribution-Smoothing" class="headerlink" title="3.2. Feature Distribution Smoothing"></a>3.2. Feature Distribution Smoothing</h3><p>&amp;emsp;&amp;emsp;We are motivated by the intuition that continuity in the target space should create a corresponding continuity in the feature space. That is, if the model works properly and the data is balanced, one expects the feature statistics corresponding to nearby targets to be close to each other.<br>&amp;emsp;&amp;emsp;我们认为目标空间的连续性应该创造一个在特征空间相对应的的连续性。即，如果模型工作正常，数据平衡，则与临近目标对应的特征数据彼此接近。</p><p>&amp;emsp;&amp;emsp;<strong>Motivating Example.</strong> We use an illustrative example to highlight the impact of data imbalance on feature statistics in DIR. Again, we use a plain model trained on the images in the IMDB-WIKI dataset to infer a person’s age from visual appearance. We focus on the learned feature space, i.e., $\mathbf{z}$. We use a minimum bin size of 1, i.e., $y_b+1 − y_b &#x3D; 1$, and group features with the same target value in the same bin. We then compute the feature statistics (i.e., mean and variance) with respect to the data in each bin, which we denote as $\left{\boldsymbol{\mu}<em>{b}, \boldsymbol{\sigma}</em>{b}\right}<em>{b&#x3D;1}^{B}$. To visualize the similarity between feature statistics, we select an anchor bin $b_0$, and calculate the cosine similarity of the feature statistics between $b_0$ and all other bins. The results are summarized in Fig. 4 for $b_0 &#x3D; 30$. The figure also shows the regions with different data densities using the colors purple, yellow, and pink.<br>&amp;emsp;&amp;emsp;激励的例子。我们使用一个说明性的例子来强调数据不平衡在DIR中的特征statistics的影响。再一次，我们使用一个在IMDB-WIKI数据集内的图片训练的空白模型来从外貌推断年龄。我们侧重学习到的特征空间，即z。我们使用最小bin的大小为1，即$y_b+1 − y_b &#x3D; 1$，并将具有相同目标值的特征组放在相同bin中。然后计算每个bin中的数据的特征统计数据（即均值和方差），将其表示为$\left{\boldsymbol{\mu}</em>{b}, \boldsymbol{\sigma}<em>{b}\right}</em>{b&#x3D;1}^{B}$。为了可视化特征统计数据之间的相似性，我们选择一个anchor bin $b_0$，并计算$b_0$与所有其他bins的特征统计的余弦相似度。在图4总结了结果。该图还使用紫色、黄色和粉红色显示了具有不同数据密度的区域。</p><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2022/08/20220816201758-3.png" alt="image.png" title="Figure 4. Feature statistics similarity for age 30. Top: Cosine similarity of the feature mean at a particular age w.r.t. its value at the anchor age. Bottom: Cosine similarity of the feature variance at a particular age w.r.t. its value at the anchor age. The color of the background refers to the data density in a particular target range. The figure shows that nearby ages have close similarities; However, it also shows that there is unjustified similarity between images at ages 0 to 6 and age 30, due to data imbalance.图4. 30岁的特征统计值的相似度。上图：在特定年龄的特征均值相对于anchor年龄值的余弦相似度。下图：特定年龄的特征方差相对于anchor年龄的余弦相似度。背景颜色是指特定目标范围的数据密度。图片表明临近年龄有近似的相似度；但，它也表明在0-6岁/30岁的图片间有不合理的相似度，因为数据不平衡"></p><figure>Figure 4. Feature statistics similarity for age 30. Top: Cosine similarity of the feature mean at a particular age w.r.t. its value at the anchor age. Bottom: Cosine similarity of the feature variance at a particular age w.r.t. its value at the anchor age. The color of the background refers to the data density in a particular target range. The figure shows that nearby ages have close similarities; However, it also shows that there is unjustified similarity between images at ages 0 to 6 and age 30, due to data imbalance. <p>图4. 30岁的特征统计值的相似度。上图：在特定年龄的特征均值相对于anchor年龄值的余弦相似度。下图：特定年龄的特征方差相对于anchor年龄的余弦相似度。背景颜色是指特定目标范围的数据密度。图片表明临近年龄有近似的相似度；但，它也表明在0-6岁&#x2F;30岁的图片间有不合理的相似度，因为数据不平衡</figure></p><p>&amp;emsp;&amp;emsp;Fig. 4 shows that the feature statistics around $b_0 &#x3D; 30$ are highly similar to their values at$b_0 &#x3D; 30$. Specifically, the cosine similarity of the feature mean and feature variance for all bins between age 25 and 35 are within a few percent from their values at age 30 (the anchor age). Further, the similarity gets higher for tighter ranges around the anchor. Note that bin 30 falls in the high shot region. In fact, it is among the few bins that have the most samples. So, the figure confirms the intuition that when there is enough data, and for continuous targets, the feature statistics are similar to nearby bins. Interestingly, the figure also shows the problem with regions that have very few data samples, like the age range 0 to 6 years (shown in pink). Note that the mean and variance in this range show unexpectedly high similarity to age 30. In fact, it is shocking that the feature statistics at age 30 are more similar to age 1 than age 17. This unjustified similarity is due to data imbalance. Specifically, since there are not enough images for ages 0 to 6, this range thus inherits its priors from the range with the maximum amount of data, which is the range around age 30.<br>&amp;emsp;&amp;emsp;图4表明$b_0&#x3D;30$周围的特征值与它们在$b_0$处的值高度相似。具体来说，在25到35之间的所有bins的特征均值和方差的余弦相似度与它们在30岁(anchor age)相差几个百分点。此外，在anchor附近更窄的范围有更高的相似度。注意bin30落在高shot rigion(样本很多的区域)。事实上，它是少数几个有最多的样本的bins之一。所以，图片证明了当有足够的数据，对于连续目标值，在相近的bins有相似的特征值。有趣的是，该图也表明只有很少数据样本的区域的问题，如1-6岁(粉红色显示)。注意在这个区域的均值和方差与30岁的相似度出乎意料的高。事实上，30岁的特征数据居然跟1岁的相似度比17岁要高。这种不合理的相似度是因为数据不平衡。具体来说，由于1-6岁没有足够的图片，因此该范围从数据量最大的范围(即30岁附近)继承其先验值</p><blockquote><p>&amp;emsp;&amp;emsp;many-shot region (bins with over 100 training samples), medium-shot region (bins with 20∼100 training samples), and few-shot region (bins with under 20 training samples)</p></blockquote><p>&amp;emsp;&amp;emsp;<strong>FDS Algorithm.</strong> Inspired by these observations, we propose feature distribution smoothing (FDS), which performs distribution smoothing on the feature space, i.e., transfers the feature statistics between nearby target bins. This procedure aims to calibrate the potentially biased estimates of feature distribution, especially for underrepresented target values (e.g., medium- and few-shot groups) in training data. FDS is performed by first estimating the statistics of each bin. Without lomg src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2022/08/20220816201758-11.png" alt="image.png"><br>As Table 6 shows, compared to the vanilla model, LDS and FDS can both improve the results not only on regions that have data, but also achieve larger gains on those without data. Specifically, substantial improvements are established for both target interpolation and extrapolation, where interpolation enjoys larger boosts.<br>如表6所示，跟vanilla模型比较，LDS和FDS不仅在有数据的区域提高性能还能在没有数据的区域取得更大的收益。具体来说，在目标内插和外插都有实质上的提升，尤其在内插中。<br>We further visualize the absolute MAE gains of our method over vanilla model in Fig. 7. Our method provides a comprehensive treatment to the many, medium, few, as well as zero-shot regions, achieving remarkable performance gains.<br>我们进一步可视化我们方法的绝对MAE收益在图7中的vanilla模型上。我们的方法对多、中，少，零区域提供全面综合的处理，实现了巨大的收益。<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2022/08/20220816201758-12.png" alt="image.png" title="(a) Feature statistics similarity for age 0, without FDS"><br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2022/08/20220816201758-13.png" alt="image.png" title="(b) Feature statistics similarity for age 0, with FDS"><br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2022/08/20220816201758-14.png" alt="image.png" title="(c) Statistics change"></p><blockquote><p>  Figure 8. Analysis on how FDS works.(a) &amp; (b)Feature statistics similarity for anchor age 0, using model trained without and with FDS. © L1 distance between the running statistics$\left{\boldsymbol{\mu}<em>{b}, \boldsymbol{\Sigma}</em>{b}\right}$and the smoothed statistics$\left{\tilde{\boldsymbol{\mu}}<em>{b}, \widetilde{\boldsymbol{\Sigma}}</em>{b}\right}$during training.<br>图8：对FDS如何有效的分析。(a)和(b)anchor age 0的特征统计相似性，使用带FDS和不带FDS的训练模型。©运行统计数据$\left{\boldsymbol{\mu}<em>{b}、\boldsymbol{\Sigma}</em>{b}\right}$与平滑统计数据$\left{\tilde{\boldsymbol{\mu}}<em>{b}, \widetilde{\boldsymbol{\Sigma}}</em>{b}\right}$在训练期间的L1距离。</p></blockquote><p>  <strong>Understanding FDS.</strong> We investigate how FDS influences the feature statistics. In Fig. 8(a) and 8(b) we plot the similarity of the feature statistics for anchor age 0, using model trained without and with FDS. As the figure indicates, since age 0 lies in the few-shot region, the feature statistics can have a large bias, i.e., age 0 shares large similarity with region 40 ∼ 80 as in Fig. 8(a). In contrast, when FDS is added, the statistics are better calibrated, resulting in a high similarity only in its neighborhood, and a gradually decreasing similarity score as target value becomes larger. We further visualize the L1 distance between the running statistics$\left{\boldsymbol{\mu}<em>{b}, \boldsymbol{\Sigma}</em>{b}\right}$and the smoothed statistics$\left{\tilde{\boldsymbol{\mu}}<em>{b}, \widetilde{\boldsymbol{\Sigma}}</em>{b}\right}$during training in Fig. 8©. Interestingly, the average$L_1$distance becomes smaller and gradually diminishes as the training evolves, indicating that the model learns to generate features that are more accurate even without smoothing, and finally the smoothing module can be removed during inference. We provide more results for different anchor ages in Appendix E.7, where similar effects can be observed.<br>  理解FDS。我们研究了FDS如何影响特征统计值。在图8(a,b)中，画出了使用和没有使用FDS训练后的模型中anchor age 0的特征统计数据（mean、variance）的相似性。如图所示，由于0岁在少样本区间，它的特征统计值由很大的偏差，即图8(a)看出0岁与40-80岁的区域有很大的相似性。相比之下，当加入FDS后，统计数据被很好的校准了，使得仅在其周围具有高相似度，并且随着目标值变大，相似度随之下降。图8©可视化了运行统计数据和平滑统计数据间的L1距离。有趣的是，随着训练进行，L1距离变得更小并逐渐平稳下降，这表明了模型即使在没有平滑的情况下学会了生成更准确的特征，最终平滑模块可以在推理阶段移除。我们提供了更多的结果在附录E.7，可以看到相似的效果。</p><p>  <strong>Ablation: Kernel type for LDS &amp; FDS (Appendix <strong><a href="#ADrwB"><strong>E.1</strong></a></strong>).</strong> We study the effects of different kernel types for LDS and FDS when applying distribution smoothing. We select three different kernel types, i.e., Gaussian, Laplacian, and Triangular kernel, and evaluate their influences on both LDS and FDS. In general, all kernel types lead to notable gains (e.g., 3.7% ∼ 6.2% relative MSE gains on STS-B-DIR), with the Gaussian kernel often delivering the best results.<br>  消融实验：LDS和FDS核类型(附录E.1)。我们研究了应用分布平滑时不同核类型对LDS和FDS的效果。我们选择了三个不同核类型，即Gaussian，Laplicaian和Triangular，并且在LDS和FDS上评估它们的效果。通常所有核类型都会带来显著效果（如，在STS-B-DIR上的相对MSE收益是3.7%-6.2%），其中Gaussian核往往是最优结果。</p><p>  <strong>Ablation: Different regression loss functions (Appendix E.2).</strong> We investigate the influence of different training loss functions on LDS and FDS. We select three common losses used for regression tasks, i.e., $L_1$ loss, MSE loss, and the Huber loss (also referred to as smoothed $L_1$loss). We find that similar results are obtained for all losses, indicating that both LDS and FDS are robust to different loss functions.<br>  消融实验：不同的回归损失函数(附录E.2)。我们研究 了不同训练时的损失函数对LDS和FDS的影响。我们选择三个常见的用于回归任务的损失函数，即L1 loss，MSE loss和Huber loss（也称为平滑L1 loss）。我们发现对于所有损失函数都获得了相似的结果，这表明 LDS 和 FDS 对不同的损失函数都具有鲁棒性。</p><p>  <strong>Ablation: Hyper-parameter for LDS &amp; FDS (Appendix E.3).</strong> We investigate the effects of hyper-parameters on both LDS and FDS. As we mainly employ the Gaussian kernel for distribution smoothing, we extensively study different choices of the kernel size $l$ and standard deviation $σ$. Interestingly, we find LDS and FDS are surprisingly robust to different hyper-parameters in a given range, and obtain similar gains. For example, on STS-B-DIR with$l ∈ \left { 5,9,15 \right }$and$σ ∈ \left { 1,2,3 \right }$, overall MSE gains range from 3.3% to 6.2%, with$l = 5$and$σ = 2$exhibiting the best results.<br>  消融实验：LDS和FDS的超参数(附录E.3)。我们研究了超参数对 LDS 和 FDS 的影响。 由于我们主要使用高斯核进行分布平滑，我们广泛研究了核大小 l 和标准差 σ 的不同选择。 有趣的是，我们发现 LDS 和 FDS 对给定范围内的不同超参数具有惊人的鲁棒性，并且获得了相似的增益。 例如，在 $l ∈ \left { 5,9,15 \right }$and$σ ∈ \left { 1,2,3 \right }$ 的 STS-B-DIR 上，总体 MSE 增益范围 从 3.3% 到 6.2%，其中 $l = 5$ 和 $σ = 2$ 表现出最好的结果。</p><p>  <strong>Ablation: Robustness to diverse skewed label densities (Appendix E.4).</strong> We curate different imbalanced distributions for IMDB-WIKI-DIR by combining different number of disjoint skewed Gaussian distributions over the target space, with potential missing data in certain target regions, and evaluate the robustness of FDS and LDS to the distribution change. We verify that even under different imbalanced   label distributions, LDS and FDS consistently boost the performance across all regions compared to the vanilla model, with relative MAE gains ranging from 8.8% to 12.4%.<br>  消融实验：对不同skewed标签密度的鲁棒性(附录E.4)。我们通过将目标空间上不同数量的不相交skewed高斯分布与某些目标区域中的潜在缺失数据相结合，为 IMDB-WIKI-DIR 管理不同的不平衡分布，并评估 FDS 和 LDS 对分布变化的鲁棒性。 我们验证了即使在不同的不平衡标签分布下，与普通模型相比，LDS 和 FDS 也能持续提升所有区域的性能，相对 MAE 增益从 8.8% 到 12.4% 不等。</p><p>  <strong>Comparisons to imbalanced classification methods (Appendix E.6).</strong> Finally, to gain more insights on the intrinsic difference between imbalanced classification &amp; imbalanced regression problems, we directly apply existing imbalanced classification schemes on several appropriate DIR datasets, and show empirical comparisons with imbalanced regression approaches. We demonstrate in Appendix E.6 that LDS and FDS outperform imbalanced classification schemes by a large margin, where the errors for few-shot regions can be reduced by up to 50% to 60%. Interestingly, the results also show that imbalanced classification schemes often perform worse than even the vanilla regression model, which confirms that regression requires different approaches for data imbalance than simply applying classification methods. We note that imbalanced classification methods could fail on regression problems for several reasons. First, they ignore the similarity between data samples that are close w.r.t. the continuous target. Moreover, classification cannot extrapolate or interpolate in the continuous label space, therefore unable to deal with missing data in certain target regions.<br>  与不平衡分类方法的比较(附录E.5)。最后，为了更深入地了解不平衡分类和不平衡回归问题之间的内在差异，我们直接在几个适当的 DIR 数据集上应用现有的不平衡分类方案，并展示与不平衡回归方法的empirical 比较。我们在附录 E.6 中证明，LDS 和 FDS 大大优于那些不平衡分类方案，其中少样本区域的错误可以减少多达 50% 到 60%。有趣的是，结果还表明，不平衡的分类方案通常比普通回归模型表现更差，这证实回归需要不同的方法来解决数据不平衡问题，而不是简单地应用分类方法。我们注意到，不平衡的分类方案可能会因为几个原因而在回归问题上失败。首先，他们忽略了与连续目标接近的数据样本之间的相似性。此外，分类无法在连续标签空间中进行外推或内插，因此无法处理某些目标区域中的缺失数据。<br><a name="LsUbt"></a></p><h2 id="5-Conclusion">5. Conclusion</h2><p>  We introduce the DIR task that learns from natural imbalanced data with continuous targets, and generalizes to the entire target range. We propose two simple and effective algorithms for DIR that exploit the similarity between nearby targets in both label and feature spaces. Extensive results on five curated large-scale real-world DIR benchmarks confirm the superior performance of our methods. Our work fills the gap in benchmarks and techniques for practical DIR tasks.<br>  我们引入了 DIR 任务，该任务从具有连续目标的自然不平衡数据中学习，并推广到整个目标范围。 我们提出了两种简单有效的 DIR 算法，利用标签和特征空间中临近目标之间的相似性。 五个整理过的大规模真实世界 DIR 基准测试的广泛结果证实了我们方法的卓越性能。 我们的工作填补了实际 Deep Imbalanced Regression (DIR)  任务的基准和技术方面的空白。</p><hr><p><a name="GAKZb"></a></p><h2 id="Supplementary-Material">Supplementary Material</h2><p><a name="Nun91"></a></p><h3 id="A-Pseudo-Code-for-LDS-FDS">A. Pseudo Code for LDS &amp; FDS</h3><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2022/08/20220816201758-15.png" alt="image.png"><br><a name="cchrV"></a></p><h3 id="B-Details-of-DIR-Datasets">B. Details of DIR Datasets</h3><p>In this section, we provide the detailed information of the five curated DIR datasets we used in our experiments. Table 7 provides an overview of the five datasets.<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/2022/08/20220816201758-16.png" alt="image.png"><br><a name="ESOiR"></a></p><h3 id="C-Experimental-Settings">C. Experimental Settings</h3><p><a name="tQC4e"></a></p><h3 id="D-Additional-Results">D. Additional Results</h3><p>We provide complete evaluation results on the five DIR datasets, where more baselines and evaluation metrics are included in addition to the reported results in the main paper.<br><a name="E4UKC"></a></p><h3 id="E-Further-Analysis-and-Ablation-Studies">E. Further Analysis and Ablation Studies</h3><p><a name="ADrwB"></a></p><h4 id="E-1-Kernel-Type-for-LDS-FDS">E.1. Kernel Type for LDS &amp; FDS</h4><p><a name="xato0"></a></p><h4 id="E-2-Training-Loss-for-LDS-FDS">E.2. Training Loss for LDS &amp; FDS</h4><p><a name="d5MnK"></a></p><h4 id="E-3-Hyper-parameters-for-LDS-FDS">E.3. Hyper-parameters for LDS &amp; FDS</h4><p>。。。。。。。太多了 自行查阅吧</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>清收藏用</title>
      <link href="/2022/07/31/%E6%B8%85%E6%94%B6%E8%97%8F%E7%94%A8-clean-collection/"/>
      <url>/2022/07/31/%E6%B8%85%E6%94%B6%E8%97%8F%E7%94%A8-clean-collection/</url>
      
        <content type="html"><![CDATA[<h2 id="深度学习">深度学习</h2><ul><li><a href="https://blog.csdn.net/u013733326/article/details/79827273">吴恩达课后作业目录</a></li><li><a href="https://github.com/Relph1119/stanford-deep-learning-notes">深度学习作业 习题无答案</a></li><li><a href="https://zhuanlan.zhihu.com/p/95510114">深度学习作业 编程</a></li><li><a href="https://kyonhuang.top/Andrew-Ng-Deep-Learning-notes/#/">《深度学习》笔记</a></li><li>作业<ul><li><a href="https://github.com/AdalbertoCq/Deep-Learning-Specialization-Coursera">深度学习代码</a></li><li><a href="https://www.heywhale.com/mw/project/5e20243e2823a10036b542da">深度学习 习题 有答案</a></li></ul></li><li><a href="https://zh.d2l.ai">李沐动手学深度学习</a></li><li><a href="https://www.bilibili.com/medialist/play/1567748478">李沐深度学习</a></li><li><a href="https://www.zhihu.com/question/332726203">如何自学机器学习</a></li></ul><h2 id="前端">前端</h2><ul><li><a href="https://imgtu.com/">图床</a></li><li><a href="https://www.fastmock.site">在线api</a></li></ul><h2 id="资源下载">资源下载</h2><ul><li><a href="https://ziquyun.com/#">csdn下载</a></li><li><a href="https://bilibili.iiilab.com">b站下载</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 琐言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年琐言</title>
      <link href="/2022/06/13/2022%E5%B9%B4%E7%90%90%E8%A8%80-postgraduate-talk/"/>
      <url>/2022/06/13/2022%E5%B9%B4%E7%90%90%E8%A8%80-postgraduate-talk/</url>
      
        <content type="html"><![CDATA[<p>还是重开一个文章吧</p><h2 id="2022-7-31">2022/7/31</h2><p>这个周末看了两次电影，都是夫妻相互扶持，真是温馨啊。<br>留档(摘自<a href="movie.douban.com/review/5394950/">豆瓣文章</a>，侵删)：</p><blockquote><p>虽然不知道为什么上天会给我们安排这样的命运，但请相信一切挣扎和痛苦的过程都会有丰富的收获和财富。我们天生不是完美的，我们的人生道路也不会是完美的。从内心深处接受有缺陷的自我和人生，并不断自我进化，才是生命真正的意义。<br>看到宫崎葵的名字就知道，这一定是一部很温情很治愈的片子。甚至影片里还穿插了不少抑郁症患者特有的情况。情绪极其脆弱，无法正确看待自己，要么就失眠整夜整夜流泪，要么就整天睡个不停。头痛，恶心，呕吐。感觉自己什么事情都做不了，无法集中精力，甚至还有短期失忆的情况。还有时不时冒出的轻生的想法，例如盯着一把菜刀一个小时以上想应该怎样划自己胳膊；默默地一个人走上大楼的顶层愣愣地望着下面想该不该跳下去；偷偷地收集安眠药止疼药等想着积攒够了就一起吞下去。<br>呵呵，写着写着就把自己的症状一并写了进去。其实我自己得抑郁症已经很久了。事实上早在自己还是初中的时候，就已经开始不太正常了。只不过自己擅长装，父母也不是太上心，很多童年时代的痛苦缓缓地积压而从未消化，直到自己20多岁的时候，因为一件事情一个人，而一并爆发了。进过三次医院吞过两次药，之后过了很长一段时间的沉默期。不知道自己是谁，不知道能否继续活下去，不知道怎样活下去。<br>片中的丈夫，无疑是幸福的。他的身边一直有不离不弃的妻子的陪伴。其实这样的相依相随，是以前的我最最渴求的。我从始至终都是一个人。只不过，上天用了另外一种方式告诉我应该如何活下去。<br>我始终记得，在自己近乎昏迷状态下被送进医院之前，身为医生的母亲哭着对我的阿姨说：“不要送入我工作的医院。如果被人知道我女儿这样自杀，我的老脸往哪里放啊？唾沫都可以把我淹死啊！” 还有自己心爱的人对自己说：“你有抑郁症么？那我更不敢和你在一起了。如果你哪天抑郁了，把我杀了，把孩子杀了怎么办？！你为什么不去死呢？！”<br>那句话像寒冰一样插入了我的心。我反而从未有过冷静地思考了整个周末。<br>上天并不会因为你有抑郁症而特殊照顾你，让你少受生活的磨难。反而如果你自己因为抑郁症而无法振作去面对生活，你会受更多苦难。虽然说有抑郁症可能让自己在某些时候情绪和思想无法自控，那么就算用什么办法，哪怕是用刀割伤自己的手臂，让肉体的疼痛转移内心的痛苦和焦虑，也要让强迫自己平静下来。<br>刚刚和男朋友吵架分手的Lyne跑来和我哭诉说：“他是我男朋友，为什么不可以容忍一下我例假前的焦躁和不安呢？” 我说：“凭什么你男朋友就一定要承担你的不良情绪呢？没有人这么规定过吧？”同理，凭什么抑郁症的患者就要他周边的亲人不断地鼓励耐着性子陪伴呢？他们也很辛苦，他们也有他们各自生活的压力，为什么一定就要背负上你的负担呢？<br>往往亲人一旦表示出不耐烦，对抑郁症患者就会是无情的打击。正如被小晴说了一句的丈夫躲在浴缸里抽泣甚至轻生。不得不说，那段丈夫的绝望和悲伤，演员表现得很到位。 以前我就经常这样躲在浴缸里哭，放冷水冲头，躺在冰冷的地板上无法动弹。小晴最后还是跑到丈夫身边紧紧地抱住了他。没有人跑来抱住我，但是，我一个人还是挣扎着活了下来。<br>要积极地自我暗示，就算不可以不行没办法做到，也要积极地自我暗示。不自救者无人救之。这个世界上最终只有自己才可以救自己。活下来，不仅仅是呼吸着就算是活下来了。行尸走肉总有一天还是会回复老样子。只有有目标地积极地挣扎着，前进着，才是真正的活着。很喜欢丈夫最后的一句话，以自己现在的姿态骄傲积极地活着。<br>和一个好友说起自己的理想，被笑着说道：“你作为一个抑郁症患者，还想要去追求这么多？还想让自己这么辛苦？你不怕再一次地垮下来么？” 我对她说：“就是因为是抑郁症患者，所以才要以一种更为疯狂的状态活下来，才更要用尽自己全力去经历生活的磨难，才更需要一个强有力的信念和未来支撑自己。不然，躲在抑郁症的龟壳里，你永远不知道，自己可以如此强大，如此美丽。”<br>还有就是，抱着一颗感恩的心。无论是温柔陪伴自己的人，还是用言语深深刺痛自己的人，正是因为他们的存在，我才能从抑郁症中自我解放出来。</p></blockquote><h2 id="9-11">9/11</h2><p>学不动(懂)啊，一个星期才只能看一两篇论文，每天就学个一两小时。</p><h2 id="11-26">11/26</h2><p>学业上也学不动了，烦躁的心，复杂的文章。<br>开始整理目标检测综述！！！</p>]]></content>
      
      
      <categories>
          
          <category> 琐言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>picgo进阶玩法+腾讯云</title>
      <link href="/2022/05/31/picgo%E8%BF%9B%E9%98%B6%E7%8E%A9%E6%B3%95+%E8%85%BE%E8%AE%AF%E4%BA%91-picgo-jin-jie-wan-fa--teng-xun-yun/"/>
      <url>/2022/05/31/picgo%E8%BF%9B%E9%98%B6%E7%8E%A9%E6%B3%95+%E8%85%BE%E8%AE%AF%E4%BA%91-picgo-jin-jie-wan-fa--teng-xun-yun/</url>
      
        <content type="html"><![CDATA[<p>参考链接：</p><ul><li><a href="https://cloud.tencent.com/developer/article/1474450">借助数据万象（原万象优图），让 hexo 也用上 webp</a></li><li><a href="https://tool.chinaz.com/tools/base64.aspx">Base64编码解码</a></li><li><a href="https://www.google.com/search?q=picgo%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE%E6%8E%A5%E6%A0%BC%E5%BC%8F&amp;oq=picgo%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE%E6%8E%A5%E6%A0%BC%E5%BC%8F&amp;aqs=chrome..69i57j69i61l2.6215j0j4&amp;sourceid=chrome&amp;ie=UTF-8">自定义链接格式</a></li><li><a href="https://cloud.tencent.com/document/api/436/46782">添加盲水印</a></li><li><a href="https://tin6.com/post/output-webp-format-images-based-on-alibaba-oss/">阿里云+picgo+自定义链接</a></li><li><a href="https://cloud.tencent.com/document/product/460/58117">盲水印价格</a></li><li><a href="https://cloud.tencent.com/document/product/460/32832">数据万象常见问题</a></li></ul><p>因为想着今晚已经浪费好长时间了，索性把picgo上传图片优化一下。<br><a name="gp5WK"></a></p><h2 id="上传图片为webp格式并加盲水印">上传图片为webp格式并加盲水印</h2><p>自定义链接格式如下：$url?imageMogr2/format/webp|?watermark/3/type/3/text/XXXX</p><ul><li>|?watermark/3/type/3/text/XXXX：生成盲水印，另外盲水印目前的价格是添加盲水印：1元/千次 提取盲水印：1元/千次</li><li>XXXX记得通过上述的<a href="https://tool.chinaz.com/tools/base64.aspx">Base64编码解码</a>生成你的base64字符串</li><li>官方文档好像不可以https开头，目前用$url没有什么问题</li><li>微信小程序的多处理规则无效应该怎么办？<ul><li>解决方案如下：<ul><li>使用样式。</li><li>把操作符 “|” 替换成 “%7C”。</li></ul></li></ul></li></ul><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/2022/0520220531224449.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5" alt="image.png"><br><a name="I8wnJ"></a></p><h2 id="提取盲水印">提取盲水印</h2><p>因为需要别人拿我的照片，并且要上传到他的cos才能提取盲水印<br>这里放链接：<a href="https://cloud.tencent.com/developer/article/1416987">Link</a>、<a href="https://cloud.tencent.com/document/api/436/46782#.E6.8F.90.E5.8F.96.E7.9B.B2.E6.B0.B4.E5.8D.B0">Link2</a></p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> picgo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>picgo安装插件不成功</title>
      <link href="/2022/05/31/picgo%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%E4%B8%8D%E6%88%90%E5%8A%9F-picgo-install-plugin/"/>
      <url>/2022/05/31/picgo%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%E4%B8%8D%E6%88%90%E5%8A%9F-picgo-install-plugin/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cloud.tencent.com/developer/article/1834573">安装picgo</a><br>一开始发现picgo-plugin-super-prefix-master这个插件，故安装，因为从github上下下来，所以采取了本地上传插件进行安装，这一步坑死我了。<br><a name="s1Nqf"></a></p><h2 id="super-prefix安装">super-prefix安装</h2><p>在插件设置里输入<strong>super-prefix</strong>，搜索后即可安装成功，注意作者是gclove<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/2022/0520220531213739.png?imageMogr2/format/webp" alt="image.png"><br><a name="rw9zn"></a></p><h3 id="遇到的坑">遇到的坑</h3><p>我是直接在GitHub上<a href="https://github.com/gclove/picgo-plugin-super-prefix/archive/refs/heads/master.zip">download</a>下来，然后本地上传，非常不建议本地上传，有bug<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/2022/0520220531213739-1.png?imageMogr2/format/webp" alt="image.png"><br><a name="mt5Ag"></a></p><h3 id="修改package-json">修改package.json</h3><p>在这个路径C:\Users\xxxx\AppData\Roaming\picgo下找到package.json，首先将里面的本地上传的super-prefix删除(ctrl+f 查找即可)，如果没有也没事<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/2022/0520220531213739-2.png?imageMogr2/format/webp" alt="image.png"><br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/2022/0520220531213739-3.png?imageMogr2/format/webp" alt="image.png"><br><a name="xPSIg"></a></p><h3 id="删除node-modules中的-package-lock-json的字段值">删除node_modules中的.package-lock.json的字段值</h3><p>1.先从<a href="#s1Nqf">第一步</a>从搜索栏安装后<br>2.错误复现不了了，总之在文件最上面会有个…/…/destop/picgo-plugin-super-prefix的一串代码，一直删除**{  xxxxx},**为止,然后重启软件即可<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/2022/0520220531213739-4.png?imageMogr2/format/webp" alt="image.png"><br><a name="WI8eW"></a></p><h2 id="pic-migrate安装">pic-migrate安装</h2><p>安装照上面来即可，但是安装完成后记得配置它，文件名后缀任意即可<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/2022/0520220531213739-5.png?imageMogr2/format/webp" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 问题集锦 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YOLOv1初体验</title>
      <link href="/2022/05/27/YOLOv1%E5%88%9D%E4%BD%93%E9%AA%8C-yolov1-first-try/"/>
      <url>/2022/05/27/YOLOv1%E5%88%9D%E4%BD%93%E9%AA%8C-yolov1-first-try/</url>
      
        <content type="html"><![CDATA[<p>下载VOC2012数据集，这里用的是镜像：<a href="https://pjreddie.com/projects/pascal-voc-dataset-mirror/">镜像网址</a>、<a href="http://pjreddie.com/media/files/VOCtrainval_11-May-2012.tar">Train/Validation dataset</a>、<a href="http://pjreddie.com/media/files/VOC2012test.tar">test dataset</a><br>注意直接复制链接，浏览器不会接管下载，需要打开迅雷（最好有超级会员）<br>原本想复现的，师兄告诉我还是直接看v3好，故溜~<br>参考链接：</p><ul><li><a href="https://www.cnblogs.com/yifanrensheng/p/12871235.html#_label4_1">目标检测：YOLOV1</a></li><li><a href="https://blog.csdn.net/qq_37619128/article/details/122385654">YOLOv1损失函数</a></li><li><a href="https://www.jianshu.com/p/cad68ca85e27">YOLO v1深入理解</a> 可以看看评论区</li><li><a href="https://zhuanlan.zhihu.com/p/25045711">YOLO：实时快速目标检测</a> 可以看看评论区</li><li><a href="https://blog.csdn.net/Roaddd/article/details/114266308">【目标检测】单阶段算法–YOLOv1详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/70387154">【论文解读】Yolo三部曲解读——Yolov1</a> 可以看看评论区</li></ul><h2 id="YOLOv1简介">YOLOv1简介</h2><p>相比于 R-CNN 系列的方法，YOLO提供了另外一种思路，将 Object Detection 的问题转化成一个 Regression 问题。给定输入图像，直接在图像的多个位置上回归出目标的bounding box以及其分类类别。YOLO是一个可以<strong>一次性预测</strong>多个Box位置和类别的卷积神经网络，能够实现端到端的目标检测和识别，其最大的优势就是速度快。YOLO没有选择滑动窗口（silding window）或提取proposal的方式训练网络，而是直接选用整图训练模型。这样做的好处在于可以更好的区分目标和背景区域，相比之下，采用proposal训练方式的Fast-R-CNN常常把背景区域误检为特定目标。但是YOLO目标区域定位误差更大（特别是小目标）。<br>优点：</p><blockquote><p>First, YOLO is extremely fast. Since we frame detection as a regression problem we don’t need a complex pipeline.（这里的回归问题不是特别理解。回归的目的是预测数值型的目标值，输入图像经过一次网络，便能得到图像中所有物体的位置和其所属类别及相应的置信概率）<br>Second, YOLO reasons globally about the image when making predictions. Unlike sliding window and region proposal-based techniques, YOLO sees the entire image.<br>Third, YOLO learns generalizable representations of objects. When trained on natural images and tested on art- work, YOLO outperforms top detection methods like DPM and R-CNN by a wide margin.</p></blockquote><h2 id="image-png"><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/yolov1/1653536968541-23b5ea20-24dc-4fe6-ad35-f550474f62b2.png?imageMogr2/format/webp" alt="image.png"></h2><p>Our system models detection as a regression problem. It divides the image into an S × S grid and for each grid cell predicts B bounding boxes, confidence for those boxes, and C class probabilities. These predictions are encoded as an S × S × (B ∗ 5 + C) tensor.<br>实现方案：<a href="https://www.jianshu.com/p/cad68ca85e27">Link</a>，大致下面这个区域，因为都是原文摘抄，所以不全部复制了。</p><blockquote><p><strong>1）结构</strong><br>去掉候选区这个步骤以后，YOLO的结构非常简单，就是单纯的卷积、池化最后加了两层全连接。单看网络结构的话，和普通的CNN对象分类网络几乎没有本质的区别，最大的差异是最后输出层用线性函数做激活函数，因为需要预测bounding box的位置（数值型），而不仅仅是对象的概率。所以粗略来说，YOLO的整个结构就是输入图片经过神经网络的变换得到一个输出的张量，如下图所示。</p></blockquote><ul><li>另外文中将图片resize为448*448，一些图片会发生很大的变形，所以尽量训练数据和测试数据分布保持一致。</li><li>YOLO并没有预先设置2个bounding box的大小和形状，也没有对每个bounding box分别输出一个对象的预测。它的意思仅仅是对一个对象预测出2个bounding box，选择预测得相对比较准的那个。这里采用2个bounding box，有点不完全算监督算法，而是像进化算法。如果是监督算法，我们需要<strong>事先</strong>根据样本就能给出一个正确的bounding box作为回归的目标。但YOLO的2个bounding box事先并不知道会在什么位置，只有经过前向计算，网络会输出2个bounding box，这两个bounding box与样本中对象实际的bounding box计算IOU。这时才能确定，IOU值大的那个bounding box，作为负责预测该对象的bounding box。<br>训练开始阶段，网络预测的bounding box可能都是乱来的，但总是选择IOU相对好一些的那个，随着训练的进行，每个bounding box会逐渐擅长对某些情况的预测（可能是对象大小、宽高比、不同类型的对象等）。所以，这是一种进化或者非监督学习的思想。</li><li>responsible： We assign one predictor to be “responsible” for predicting an object based on which prediction has the highest current IOU with the ground truth. This leads to specialization between the bounding box predictors. Each predictor gets better at predicting certain sizes, aspect ratios, or classes of object, improving overall recall.</li><li>设网格数量为 S<em>S，每个网格产生B个边框，数据集包含C个不同的对象。这时，输出的长度为：$(C+B</em>(4+1))<em>S</em>S$</li></ul><h2 id="论文关键部分翻译：Unified-Detection">论文关键部分翻译：Unified Detection</h2><p>We unify the separate components of object detection into a single neural network. Our network uses features from the entire image to predict each bounding box. It also predicts all bounding boxes across all classes for an image simultaneously. This means our network reasons globally about the full image and all the objects in the image. The YOLO design enables end-to-end training and realtime speeds while maintaining high average precision.</p><p>我们将目标检测的不同组件整合到一个神经网络中。我们的网络使用整张图片的特征来预测每一个边界框。它还同时预测图像的所有类中的每一个边界框。这表示我们的网络全局推理整张图片和图片上的所有对象。YOLO的设计可以进行端到端训练和达到实时的速度并且保持相对高的准确度。<br>Our system divides the input image into an_ S _× <em>S</em> grid. If the center of an object falls into a grid cell, that grid cell is responsible for detecting that object.</p><p>我们的系统将输入图片分成S×S的网格。如果一个对象的中心点落在某个网格内，则这个网格负责预测这个对象。（计算出该Object的bounding box的中心位置，这个中心位置落在哪个grid，该grid对应的输出向量中该对象的类别概率是1（该gird负责预测该对象），所有其它grid对该Object的预测概率设为0（不负责预测该对象）<a href="https://www.jianshu.com/p/cad68ca85e27">参考网址</a>。另外最多能检测出S*S个物体，如果每个物体的中心点在每个网格内）<br>Each grid cell predicts <em>B</em> bounding boxes and confidence scores for those boxes. These confidence scores reflect how confident the model is that the box contains an object and also how accurate it thinks the box is that it predicts. Formally we define confidence as $\operatorname{Pr}(\text { Object }) * \mathrm{IOU}_{\text {pred }}^{\text {truth }}$. If no object exists in that cell, the confidence scores should be zero. Otherwise we want the confidence score to equal the intersection over union (IOU) between the predicted box and the ground truth.</p><p>每个网格预测B个bboxes和这些boxes的置信度。其中置信度反映了模型对这个box包含对象的信任度和模型认为这个box预测有无对象的准确度。我们定义置信度为有无对象的预测值（非0即1）* truth box和pred box的交并比。如果没有object在网格内，则置信度应为0. 否则我们将置信度等于预测框和真实框的交并比。</p><p>Each bounding box consists of 5 predictions: <em>x</em>, <em>y</em>, <em>w</em>, <em>h</em>,_ _and confidence. The (<em>x,</em> <em>y</em>) coordinates represent the center of the box relative to the bounds of the grid cell. The width and height are predicted relative to the whole image. Finally the confidence prediction represents the IOU between the predicted box and any ground truth box.</p><p>每个bbox包含5个预测值：x, y, w, h and 置信度。(x, y)表示bbox相对于网格单元格边界的中心坐标。预测的高宽相对于整张图片的高宽。最后，置信度预测表示pred and truth 的交并比</p><p>Each grid cell also predicts <em>C</em> conditional class probabilities, $\operatorname{Pr}\left(\text { Class }<em>{i} \mid \text { Object }\right)$. These probabilities are conditioned on the grid cell containing an object. We only predict one set of class probabilities per grid cell, regardless of the number of boxes</em> B_.</p><p>每个网格也预测C个条件类型概率，即存在对象时，属于某类别的概率。这些概率以网格内包含对象为条件。我们仅预测每个网格的一系列的类别概率，不管bbox的个数。（相当于每个网格只输出一个类型概率，而不会输出bbox的类别概率，bbox输出置信度）<br>At test time we multiply the conditional class probabilities and the individual box confidence predictions, $\begin{equation*} \operatorname{Pr}\left(\text { Class }<em>{i} \mid \text { Object }\right) * \operatorname{Pr}(\text { Object }) * \mathrm{IOU}</em>{\text {pred }}^{\text {truth }}=\operatorname{Pr}\left(\text { Class }<em>{i}\right) * \mathrm{IOU}</em>{\text {pred }}^{\text {truth }} \end{equation*}$<br>which gives us class-specific confidence scores for each box. These scores encode both the probability of that class appearing in the box and how well the predicted box fits the object.</p><p>在测试阶段我们将conditional class probabilities乘上每个bbox的置信度预测值，公式中i指的是类别个数，所以有$\operatorname{Pr}\left(\text { Class }<em>{1}\right) * \mathrm{IOU}</em>{\text {pred }}^{\text {truth }}、 \operatorname{Pr}\left(\text { Class }<em>{2}\right) * \mathrm{IOU}</em>{\text {pred }}^{\text {truth }}…\operatorname{Pr}\left(\text { Class }<em>{i}\right) * \mathrm{IOU}</em>{\text {pred }}^{\text {truth }}$，这样子使我们得到关于每个bbox的特定类的置信度。这些值也反映了bounding box是否含有Object和bounding box坐标的准确度。</p><p>最后在PASCAL VOC中 S=7，B=2，C=20，最终输出为7×7×30的标量（30=(4+1)*2+20, 4是xywh，1是置信度，2是bbox个数，20类别数）</p><h2 id="损失函数">损失函数</h2><p>图片来源：<a href="https://www.cnblogs.com/yifanrensheng/p/12871235.html#_label4_1">Link</a></p><h2 id="image-png-2"><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/yolov1/1653446878220-7d2da09d-efaa-4f2f-8bcf-30e14fdc5bfb.png?imageMogr2/format/webp" alt="image.png"></h2><h2 id="image-png-3"><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/yolov1/1653546402345-b302bc1a-36f6-439c-ac36-8f3e4e24b882.png?imageMogr2/format/webp" alt="image.png"></h2><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/yolov1/1653447175456-063291b7-cbdc-47b6-b461-90e3d88d7593.png?imageMogr2/format/webp" alt="image.png"><br>$1_{ij}^{obj}$表示第i个网格中的第j个bbox有对象<br>$1_{ij}^{noobj}$表示第i个网格中的第j个bbox无对象</p><ul><li>第一行是预测框的中心，只计算含有物体时的bbox(IOU大的那个)损失值，因为$1_{ij}^{obj}$无对象其值为0。</li><li>第二行是预测框的高宽，与第一行不同的是wh取了根号，如果不取根号，损失函数则偏向于调整大尺寸的预测框，因为修改小尺寸的话对loss有较大的影响，如h=1000，error=25；h=100，error=25的情况下，应该小框的误差要严重，因此loss要加大，但是不取平方根则1000-975 = 100-75， Sum-squared error also equally weights errors in large boxes and small boxes，加了根号则sqrt(1000)-sqrt(975) ≈0.4 &lt; sqrt(100)-sqrt(75) ≈1.33，此时小框误差就体现出来了。平方根函数的上升趋势是递减的，越来越平缓（评论最后一页：<a href="https://www.jianshu.com/p/cad68ca85e27">Link</a>）。</li><li>第三行是预测框包含对象时的置信度</li><li>第四行是预测框不包含对象时的置信度，这里解释挺多的，我也分辨不过来哪个是对的，故全复制过来了。<ul><li>第4行是不存在对象的bounding box的置信度误差。因为不存在对象的bounding box应该老老实实的说&quot;我这里没有对象&quot;，也就是输出尽量低的置信度。如果它不恰当的输出较高的置信度，会与真正&quot;负责&quot;该对象预测的那个bounding box产生混淆。其实就像对象分类一样，正确的对象概率最好是1，所有其它对象的概率最好是0。</li><li>如果一些栅格中没有object（一幅图中这种栅格很多），那么就会将这些栅格中的bounding box的confidence 置为0，相比于较少的有object的栅格，这些不包含物体的栅格对梯度更新的贡献会远大于包含物体的栅格对梯度更新的贡献，这会导致网络不稳定甚至发散。</li><li>不包含obj的置信度损失就是包含两部分，一部分是包含obj的grid cell中的两个BBox中不负责预测的那个BBox，另外一部分是不包含obj的grid cell的bbox。损失计算时，负责预测物体的bbox的便签值就是IOU的值，不负责预测物体的bbox的标签值就是0（包含上述所描述的两部分），预测值就是网络直接输出出来的，计算时就是两者相减后取平方。</li><li>后续我的理解，可以看到第二幅图，因为每个网格都会输出预测值，即使bbox的C较小，$(C_i-C^{hat}_i)=(0-0.2)^2<em>48</em>2$也会变得很大(48是包含对象时49-1，然后*bbox个数，其实还要+1，因为IOU小的那个也被淘汰了)，所以要乘个小数</li></ul></li><li>第五行是网格包含物体时的物体类别概率。</li></ul><h2 id="训练过程和推理interference过程">训练过程和推理interference过程</h2><h3 id="train">train</h3><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/yolov1/1653550530915-bf70a1d9-4f2c-4c8f-b0c5-530cc486582f.png?imageMogr2/format/webp" alt="image.png"><br>作者采用ImageNet 1000-class 数据集来预训练卷积层。预训练阶段，采用上图网络中的前20卷积层（包括池化层），外加average-pooling 层和全连接层。然后，将模型转换为检测模型使用DarkNet架构并用于interference阶段。作者向预训练模型中加入了4个卷积层和两层全连接层，提高了模型输入分辨率（224×224-&gt;448×448）。最后一层预测类别概率和bounding box坐标值。bounding box的宽和高通过输入图像宽和高归一化到0-1区间。最后一层采用linear activation，其它层使用 leaky rectified linear。作者采用sum-squared error为目标函数来优化，增加bounding box loss权重，减少置信度权重，实验中，设定为$λ_{coord} =5$,$λ_{noobj} = .5$。<br>作者还采用了dropout和 data augmentation来预防过拟合。dropout值为0.5；data augmentation包括：random scaling，translation，adjust exposure和saturation。</p><h3 id="inference">inference</h3><p>训练好的YOLO网络，输入一张图片，将输出一个 7<em>7</em>30 的张量（tensor）来表示图片中所有网格包含的对象（概率）以及该对象可能的2个位置（bounding box）和置信度。<br>因为一些大物体或者靠近多个网格的边界的物体会产生多个预测框，YOLO采用NMS（Non-maximal suppression，非极大值抑制）算法来减少。</p><h3 id="limitation">limitation</h3><ol><li>YOLO的每一个网格只预测两个boxes，一种类别。这导致模型对相邻目标预测准确率下降。因此，YOLO对成队列的目标（如 一群鸟）识别准确率较低。</li><li>YOLO是从数据中学习预测bounding boxes，因此，对新的或者不常见角度的目标无法识别。</li><li>YOLO的loss函数对small bounding boxes和large bounding boxes的error平等对待，影响了模型识别准确率。因为对于小的bounding boxes，small error影响更大。主要识别错误来源是不正确的定位框。</li></ol><h3 id="错误分析">错误分析</h3><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/yolov1/1653554508484-c0c71686-f569-4709-91cf-76565620cda4.png?imageMogr2/format/webp" alt="image.png"><br>预测结果包括以下几类：<br>正确：类别正确，IOU&gt;0.5<br>定位：类别正确，0.1&lt;IOU&lt;0.5<br>类似：类别相似，IOU&gt;0.1<br>其它：类别错误，IOU&gt;0.1<br>背景：IOU&lt;0.1</p><h2 id="文中的小技巧">文中的小技巧</h2><ol><li>回归offset代替直接回归坐标</li></ol><blockquote><p>We parametrize the bounding box x and y coordinates to be offsets of a particular grid cell location so they are also bounded between 0 and 1</p></blockquote><p><strong>(x, y)不直接回归中心点坐标数值，而是回归相对于格点左上角坐标的位移值。</strong> 例如，第一个格点中物体坐标为 (2.3, 3.6) ，另一个格点中的物体坐标为(4.2, 4.6)，这四个数值让神经网络暴力回归，有一定难度。所以这里的offset是指，既然格点已知，那么物体中心点的坐标一定在格点正方形里，相对于格点左上角的位移值一定在区间[0, 1)中。让神经网络去预测 (0.3, 0.6) 与 (0.2, 0.6) 会更加容易，在使用时，加上格点左上角坐标(2, 3)、(4, 4)即可。</p><h2 id=""></h2><p>为什么一个网格只检测一个目标：<a href="https://www.zdaiot.com/DeepLearningApplications/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E5%AE%9E%E6%97%B6%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%EF%BC%9AYOLO%E3%80%81YOLOv2%E4%BB%A5%E5%8F%8AYOLOv3/">实时目标检测</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形态学--腐蚀运算详细过程</title>
      <link href="/2022/05/10/%E5%BD%A2%E6%80%81%E5%AD%A6--%E8%85%90%E8%9A%80%E8%BF%90%E7%AE%97%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B-morphology-erosion/"/>
      <url>/2022/05/10/%E5%BD%A2%E6%80%81%E5%AD%A6--%E8%85%90%E8%9A%80%E8%BF%90%E7%AE%97%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B-morphology-erosion/</url>
      
        <content type="html"><![CDATA[<p>在网上翻看许多，都是只讲定义，不讲过程，故我根据一道题目来详细介绍如何进行腐蚀运算，膨胀运算与腐蚀运算差不多就不多加赘述了。<br>题目如下：<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/erode/1652099989022-aeabc97e-01aa-439e-8731-a6a82f1519f6.png?imageMogr2/format/webp" alt="image.png"><br>程序如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">A = np.array(</span><br><span class="line">    [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">     [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">     [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">     [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">     [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">     [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">     [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]], np.uint8)</span><br><span class="line">Ac = <span class="number">1</span> - A</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="built_in">print</span>(Ac)</span><br><span class="line"><span class="comment"># print(np.pad(Ac, (1, 1), mode=&#x27;constant&#x27;, constant_values=(1, 1)))</span></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">T1 = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]], np.uint8)</span><br><span class="line">T2 = np.array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]], np.uint8)</span><br><span class="line">img1 = cv2.erode(A, T1)</span><br><span class="line"><span class="comment"># 事实上这里是cv2.erode(Ac, T2, borderValue=1)</span></span><br><span class="line">img2 = cv2.erode(Ac, T2)</span><br><span class="line"><span class="built_in">print</span>(img1)</span><br><span class="line"><span class="built_in">print</span>(img2)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(img1 &amp; img2)</span><br></pre></td></tr></table></figure><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/erode/1652178834944-470bbccb-eeb8-45a6-866d-ad0f0bb5cb75.png?imageMogr2/format/webp" alt="image.png"></p><h2 id="产生img1">产生img1</h2><p>首先讲img1是如何出来的。（安利一个截图神器，<strong>snipaste</strong>）<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/erode/1652178700984-15502084-6486-4bdd-8d9d-e249cc5ed697.png?imageMogr2/format/webp" alt="image.png"><br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/erode/1652176451686-49ddb2db-2548-41de-85d0-4da0e36557e4.png?imageMogr2/format/webp" alt="image.png"><br>图片我个人感觉很清晰了，除了有点乱。顺序从红色字→绿色字→蓝色字→紫色字→白色字</p><blockquote><p>疑问解决：<br><a href="https://docs.opencv.org/4.x/db/df6/tutorial_erosion_dilatation.html">Eroding and Dilating</a><br><a href="http://opencv.jp/opencv-2.2_org/cpp/imgproc_image_filtering.html#cv-erode">cv2.erode参数解释</a><br>如果无指定，默认为结构元素中点</p></blockquote><h2 id="产生img2">产生img2</h2><p>接下来是img2，原理差不多，除了一开始遇到补集，看到好多1有点慌。<br><strong>注意：当遇到这种情况，opencv会为图像扩充边界，其值为1.</strong><br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/erode/1652183808346-615c12e5-15d4-4549-973c-41aede64701a.png?imageMogr2/format/webp" alt="image.png"><br>图中不同颜色的矩阵大部分值不变，是因为在每次比较都是比较原图，而不是修改后的图。</p><h2 id="求并集">求并集</h2><p>全为1才为1<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/erode/1652183929130-f20288b6-083c-47c2-b19b-758cb542ec58.png?imageMogr2/format/webp" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(leetcode) 一周六题.md</title>
      <link href="/2022/04/30/leetcode%E4%B8%80%E5%91%A8%E5%85%AD%E9%A2%98md-leetcode-one-week-six-ans/"/>
      <url>/2022/04/30/leetcode%E4%B8%80%E5%91%A8%E5%85%AD%E9%A2%98md-leetcode-one-week-six-ans/</url>
      
        <content type="html"><![CDATA[<p>至此一个月全部打卡，之后按专题来进行提高</p><h2 id="随机数索引"><a href="https://leetcode-cn.com/problems/random-pick-index/">随机数索引</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴力</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        self.nums = nums</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pick</span>(<span class="params">self, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="comment"># 新建字典 key:int value:list</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.nums):</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> dic:</span><br><span class="line">                dic[num].append(i)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            dic[num] = [i]</span><br><span class="line">        <span class="keyword">return</span> random.choice(dic[target])</span><br><span class="line"><span class="comment"># 水塘抽样</span></span><br><span class="line"><span class="comment"># https://zhuanlan.zhihu.com/p/29178293</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        self.nums = nums</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pick</span>(<span class="params">self, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnt, ans = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.nums):</span><br><span class="line">            <span class="keyword">if</span> num == target:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> random.randrange(cnt) == <span class="number">0</span>:</span><br><span class="line">                    ans = i</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"><span class="comment"># 随机抽k个</span></span><br><span class="line"><span class="comment"># 仅供参考</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ReservoirSampling</span>(<span class="params">nums, target, k</span>):</span><br><span class="line">    res = [<span class="number">0</span>]*k</span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        <span class="keyword">if</span> target == num:</span><br><span class="line">            res[idx] = i</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> idx == k:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    cnt = k</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(res[idx-<span class="number">1</span>], <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] == target:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            ran = random.randrange(cnt)</span><br><span class="line">            <span class="keyword">if</span> ran &lt; k:</span><br><span class="line">                res[ran] = i</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="三维形体投影面积"><a href="https://leetcode-cn.com/problems/projection-area-of-3d-shapes/">三维形体投影面积</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单题</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">projectionArea</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    x, y, z = <span class="number">0</span>, <span class="number">0</span>, grid[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> grid:</span><br><span class="line">        y += <span class="built_in">max</span>(row)</span><br><span class="line">        <span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(row):</span><br><span class="line">            <span class="keyword">if</span> item != <span class="number">0</span>:</span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> z[i] &lt; item:</span><br><span class="line">                z[i] = item</span><br><span class="line">    <span class="keyword">return</span> x + y + <span class="built_in">sum</span>(z)</span><br><span class="line"><span class="comment"># 一行</span></span><br><span class="line"><span class="comment"># zip(*grid) 按列输出</span></span><br><span class="line"><span class="comment"># *返回tuple **返回字典</span></span><br><span class="line"><span class="comment"># https://baijiahao.baidu.com/s?id=1719090099795374109</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">projectionArea</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="built_in">sum</span>(v &gt; <span class="number">0</span> <span class="keyword">for</span> v <span class="keyword">in</span> g) + <span class="built_in">max</span>(g) <span class="keyword">for</span> g <span class="keyword">in</span> grid) + <span class="built_in">sum</span>(<span class="built_in">max</span>(g) <span class="keyword">for</span> g <span class="keyword">in</span> <span class="built_in">zip</span>(*grid))</span><br></pre></td></tr></table></figure><h2 id="太平洋大西洋水流问题"><a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">太平洋大西洋水流问题</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pacificAtlantic</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        m, n = <span class="built_in">len</span>(heights), <span class="built_in">len</span>(heights[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">starts</span>):</span><br><span class="line">            visited = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x, y</span>):</span><br><span class="line">                <span class="keyword">if</span> (x, y) <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                visited.add((x, y))</span><br><span class="line">                <span class="keyword">for</span> nx, ny <span class="keyword">in</span> ((x, y - <span class="number">1</span>), (x, y + <span class="number">1</span>), (x - <span class="number">1</span>, y), (x + <span class="number">1</span>, y)):</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span> &lt;= nx &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= ny &lt; n <span class="keyword">and</span> heights[nx][ny] &gt;= heights[x][y]:</span><br><span class="line">                        dfs(nx, ny)</span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> starts:</span><br><span class="line">                dfs(x, y)</span><br><span class="line">            <span class="keyword">return</span> visited</span><br><span class="line">        <span class="comment"># 从上左遍历</span></span><br><span class="line">        pacific = [(<span class="number">0</span>, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)] + [(j, <span class="number">0</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="comment"># 从下右遍历</span></span><br><span class="line">        atlantic = [(m-<span class="number">1</span>, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)] + [(j, n-<span class="number">1</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m-<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">list</span>, search(pacific) &amp; search(atlantic)))</span><br></pre></td></tr></table></figure><h2 id="按奇偶排序数组"><a href="https://leetcode-cn.com/problems/sort-array-by-parity/">按奇偶排序数组</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 双指针</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sortArrayByParity</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    i, j = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">if</span> nums[i] % <span class="number">2</span>:</span><br><span class="line">            t = nums[i]</span><br><span class="line">            <span class="keyword">while</span> nums[j] % <span class="number">2</span> <span class="keyword">and</span> i &lt; j:</span><br><span class="line">               j -= <span class="number">1</span></span><br><span class="line">            nums[i] = nums[j]</span><br><span class="line">            nums[j] = t</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"><span class="comment"># 一行</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sortArrayByParity</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(nums, keys=<span class="keyword">lambda</span> x: x%<span class="number">2</span>!=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="建立四叉树"><a href="https://leetcode-cn.com/problems/construct-quad-tree/">建立四叉树</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">construct</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="string">&#x27;Node&#x27;</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">r0: <span class="built_in">int</span>, r1: <span class="built_in">int</span>, c0: <span class="built_in">int</span>,c1: <span class="built_in">int</span></span>) -&gt; <span class="string">&#x27;Node&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(r0, r1):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(c0, c1):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] != grid[r0][c0]:</span><br><span class="line">                    <span class="keyword">return</span> Node(<span class="literal">True</span>, </span><br><span class="line">                    <span class="literal">False</span>, </span><br><span class="line">                    dfs(r0, r0+r1&gt;&gt;<span class="number">1</span>, c0, c0+c1&gt;&gt;<span class="number">1</span>),</span><br><span class="line">                    dfs(r0, r0+r1&gt;&gt;<span class="number">1</span>, c0+c1&gt;&gt;<span class="number">1</span>, c1),</span><br><span class="line">                    dfs(r0+r1&gt;&gt;<span class="number">1</span>, r1, c0, c0+c1&gt;&gt;<span class="number">1</span>),</span><br><span class="line">                    dfs(r0+r1&gt;&gt;<span class="number">1</span>, r1, c0+c1&gt;&gt;<span class="number">1</span>, c1))</span><br><span class="line">        <span class="keyword">return</span> Node(grid[r0][c0], <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="built_in">len</span>(grid), <span class="number">0</span>, <span class="built_in">len</span>(grid[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure><h2 id="最小差值-I"><a href="https://leetcode-cn.com/problems/smallest-range-i/">最小差值 I</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">smallestRangeI</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">max</span>(nums)-<span class="built_in">min</span>(nums)-<span class="number">2</span>*k)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(leetcode) 一周七题.md</title>
      <link href="/2022/04/24/leetcode%E4%B8%80%E5%91%A8%E4%B8%83%E9%A2%98md-leetcode-week-1/"/>
      <url>/2022/04/24/leetcode%E4%B8%80%E5%91%A8%E4%B8%83%E9%A2%98md-leetcode-week-1/</url>
      
        <content type="html"><![CDATA[<h2 id="最常见的单词"><a href="https://leetcode-cn.com/problems/most-common-word/">最常见的单词</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自己写的水代码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mostCommonWord</span>(<span class="params">paragraph, banned</span>):</span><br><span class="line">    s, ss = <span class="string">&#x27;&#x27;</span>, []</span><br><span class="line">    <span class="comment"># 将字符串转成小写字母</span></span><br><span class="line">    paragraph = paragraph.lower()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(banned)):</span><br><span class="line">        banned[i] = banned[i].lower()</span><br><span class="line">    <span class="comment"># 判断是否是最后一个字符，最后一个字符没有空格或其他符号</span></span><br><span class="line">    flag = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> paragraph:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;a&#x27;</span> &lt;= i &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line">            s += i</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 将bob,中&#x27;,&#x27;造成的&#x27;&#x27;删除</span></span><br><span class="line">        <span class="keyword">if</span> s:</span><br><span class="line">            ss.append(s)</span><br><span class="line">        s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 最后一个字符串加入数组</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        ss.append(s)</span><br><span class="line">    c = Counter(ss)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(banned) + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 获取最大值</span></span><br><span class="line">        ans = <span class="built_in">max</span>(c.keys(), key=c.get)</span><br><span class="line">        <span class="keyword">if</span> ans <span class="keyword">in</span> banned:</span><br><span class="line">            <span class="keyword">del</span> c[ans]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"><span class="comment"># 官解</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mostCommonWord</span>(<span class="params">paragraph, banned</span>):</span><br><span class="line">    ban = <span class="built_in">set</span>(banned)</span><br><span class="line">    freq = Counter()</span><br><span class="line">    word, n = <span class="string">&quot;&quot;</span>, <span class="built_in">len</span>(paragraph)</span><br><span class="line">    <span class="comment"># 获取字符串模板，&#x27;Bob like Joe&#x27;=&gt;[Bob, like, Joe]</span></span><br><span class="line">    <span class="comment"># n+1 排除了单词结尾的情况</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># i&lt;n 使得paragraph[i]不会越界</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; n <span class="keyword">and</span> paragraph[i].isalpha():</span><br><span class="line">            word += paragraph[i].lower()</span><br><span class="line">        <span class="keyword">elif</span> word:</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> ban:</span><br><span class="line">                freq[word] += <span class="number">1</span></span><br><span class="line">            word = <span class="string">&quot;&quot;</span></span><br><span class="line">    maxFreq = <span class="built_in">max</span>(freq.values())</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">next</span>(word <span class="keyword">for</span> word, f <span class="keyword">in</span> freq.items() <span class="keyword">if</span> f == maxFreq)</span><br><span class="line"><span class="comment"># 一行</span></span><br><span class="line"><span class="comment"># https://leetcode-cn.com/problems/most-common-word/solution/by-jam007-3la9/</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mostCommonWord</span>(<span class="params">self, paragraph: <span class="built_in">str</span>, banned: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> Counter(w <span class="keyword">for</span> w <span class="keyword">in</span> re.findall(<span class="string">r&#x27;\w+&#x27;</span>, paragraph.lower()) <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">set</span>(banned)).most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="字典序排数"><a href="https://leetcode-cn.com/problems/lexicographical-numbers/">字典序排数</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 官解</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lexicalOrder</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    ans = [<span class="number">0</span>] * n</span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        ans[i] = num</span><br><span class="line">        <span class="keyword">if</span> num * <span class="number">10</span> &lt;= n:  <span class="comment"># 保存1 100 1000</span></span><br><span class="line">            num *= <span class="number">10</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># num % 10 = 9是判断尾数是否到头，因为再加1则变为10，到头则使num变为9</span></span><br><span class="line">            <span class="comment"># num + 1 &gt; n：+1是为了后面的num+=1，并且判断num是不是超过了n，超过则使num//10</span></span><br><span class="line">            <span class="keyword">while</span> num % <span class="number">10</span> == <span class="number">9</span> <span class="keyword">or</span> num + <span class="number">1</span> &gt; n:</span><br><span class="line">                num //= <span class="number">10</span>  <span class="comment"># 使num复原</span></span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"><span class="comment"># dfs</span></span><br><span class="line"><span class="comment"># https://leetcode-cn.com/problems/lexicographical-numbers/solution/by-ac_oier-ktn7/</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lexicalOrder</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">num, limit</span>):</span><br><span class="line">        <span class="keyword">if</span> num &gt; limit: <span class="keyword">return</span></span><br><span class="line">        ans.append(num)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            dfs(num * <span class="number">10</span> + i, limit)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        dfs(i, n)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"><span class="comment"># 库函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lexicalOrder</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(<span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>),key=<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure><h2 id="字符的最短距离"><a href="https://leetcode-cn.com/problems/shortest-distance-to-a-character/">字符的最短距离</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 官解的-n、2*n 秒啊</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shortestToChar</span>(<span class="params">s: <span class="built_in">str</span>, c: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    ans = [<span class="number">0</span>] * <span class="built_in">len</span>(s)</span><br><span class="line">    idx = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] == c:</span><br><span class="line">            idx = i</span><br><span class="line">        <span class="keyword">if</span> idx &gt;= <span class="number">0</span>:</span><br><span class="line">            ans[i] = <span class="built_in">abs</span>(i-idx)</span><br><span class="line">    <span class="built_in">print</span>(ans)</span><br><span class="line">    idx = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)-<span class="number">1</span>,-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> s[i] == c:</span><br><span class="line">            idx = i</span><br><span class="line">        <span class="keyword">if</span> ans[i] == <span class="number">0</span>:</span><br><span class="line">            ans[i] = <span class="built_in">abs</span>(i-idx)</span><br><span class="line">        <span class="keyword">if</span> idx &gt;= <span class="number">0</span>:</span><br><span class="line">            ans[i] = <span class="built_in">min</span>(ans[i], <span class="built_in">abs</span>(i-idx))</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"><span class="comment"># 官解</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shortestToChar</span>(<span class="params">s: <span class="built_in">str</span>, c: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    ans = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="comment"># 使i-idx 变为最大</span></span><br><span class="line">    idx = -n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> s[i] == c:</span><br><span class="line">            idx = i</span><br><span class="line">        ans[i] = i - idx</span><br><span class="line">    <span class="built_in">print</span>(ans)</span><br><span class="line">    <span class="comment"># 同理</span></span><br><span class="line">    idx = <span class="number">2</span> * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> s[i] == c:</span><br><span class="line">            idx = i</span><br><span class="line">        ans[i] = <span class="built_in">min</span>(ans[i], idx - i)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"><span class="comment"># bfs</span></span><br><span class="line"><span class="comment"># https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/-by-yu-niang-niang-4qgd/</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shortestToChar</span>(<span class="params">s: <span class="built_in">str</span>, c: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    q = queue.Queue()</span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    ans = [-<span class="number">1</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i, ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">        <span class="keyword">if</span> ch == c:</span><br><span class="line">            ans[i] = <span class="number">0</span></span><br><span class="line">            q.put(i)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">        idx = q.get()</span><br><span class="line">        <span class="comment"># idx != 0 使其不越界</span></span><br><span class="line">        <span class="keyword">if</span> idx != <span class="number">0</span> <span class="keyword">and</span> ans[idx-<span class="number">1</span>] == -<span class="number">1</span>:</span><br><span class="line">            q.put(idx-<span class="number">1</span>)</span><br><span class="line">            ans[idx-<span class="number">1</span>] = ans[idx] - ans[idx-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># idx+1 &lt; n 使其不越界</span></span><br><span class="line">        <span class="keyword">if</span> idx+<span class="number">1</span> &lt; n <span class="keyword">and</span> ans[idx+<span class="number">1</span>] == -<span class="number">1</span>:</span><br><span class="line">            q.put(idx+<span class="number">1</span>)</span><br><span class="line">            ans[idx+<span class="number">1</span>] = ans[idx] - ans[idx+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="文件的最长绝对路径"><a href="https://leetcode-cn.com/problems/longest-absolute-file-path/">文件的最长绝对路径</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27; 解题思路 本题为求解文件夹路径的最大值，其中会添加 /</span></span><br><span class="line"><span class="string">1. 用 depth_length_map 保留每层路径的长度， input.split(&#x27;\n&#x27;) 切分为每行分析每行长度与文件</span></span><br><span class="line"><span class="string">2. line.count(&#x27;\t&#x27;) 的个数来判断是第几层</span></span><br><span class="line"><span class="string">3. line.count(&#x27;.&#x27;) 的个数判断是否有文件，有文件获取当前最长路径值</span></span><br><span class="line"><span class="string">4. 每层都要添加depth个 / ， 长度需要修改</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 很妙的解法</span></span><br><span class="line"><span class="comment"># https://leetcode-cn.com/problems/longest-absolute-file-path/solution/wen-jian-de-zui-chang-jue-dui-lu-jing-by-fi0r/1516846</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lengthLongestPath</span>(<span class="params"><span class="built_in">input</span>: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="comment"># -1层为了根目录</span></span><br><span class="line">    depth_length = &#123;-<span class="number">1</span>: <span class="number">0</span>&#125;</span><br><span class="line">    s = <span class="built_in">input</span>.split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> s:</span><br><span class="line">        depth = word.count(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="comment"># 覆盖之前的文件长度，计算完.ext前面的长度后就无用了。</span></span><br><span class="line">        <span class="comment"># +上一层的文件夹长度+当前长度-字符&#x27;\t&#x27;</span></span><br><span class="line">        depth_length[depth] = depth_length[depth - <span class="number">1</span>] + <span class="built_in">len</span>(word) - depth</span><br><span class="line">        <span class="comment"># 当遇到.ext文件计算长度</span></span><br><span class="line">        <span class="keyword">if</span> word.count(<span class="string">&#x27;.&#x27;</span>):</span><br><span class="line">            <span class="comment"># +depth是为了每层都要添加depth个 /</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, depth_length[depth] + depth)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># 可以输出字符串</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lengthLongestPath</span>(<span class="params"><span class="built_in">input</span>: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    ans, i, n = <span class="string">&#x27;&#x27;</span>, <span class="number">0</span>, <span class="built_in">len</span>(<span class="built_in">input</span>)</span><br><span class="line">    <span class="built_in">map</span> = &#123;&#125;</span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        <span class="comment"># 每次重置文件夹深度</span></span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 计算深度</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> <span class="built_in">input</span>[i] == <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">            level += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 计算当前字符（不包括&#x27;\n&#x27;&#x27;\t&#x27;）</span></span><br><span class="line">        j = i</span><br><span class="line">        isDir = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> <span class="built_in">input</span>[j] != <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">input</span>[j] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                isDir = <span class="literal">False</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 截取当前字符串</span></span><br><span class="line">        cur = <span class="built_in">input</span>[i:j]</span><br><span class="line">        <span class="comment"># 获取以前的路径</span></span><br><span class="line">        prev = <span class="built_in">map</span>.get(level - <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 拼接路径</span></span><br><span class="line">        path = cur <span class="keyword">if</span> prev <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> prev + <span class="string">&#x27;/&#x27;</span> + cur</span><br><span class="line">        <span class="keyword">if</span> isDir:</span><br><span class="line">            <span class="built_in">map</span>[level] = path</span><br><span class="line">        <span class="comment"># elif 防止非文件、文件夹</span></span><br><span class="line">        <span class="keyword">elif</span> ans == <span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> <span class="built_in">len</span>(path) &gt; <span class="built_in">len</span>(ans):</span><br><span class="line">            ans = path</span><br><span class="line">        i = j + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> <span class="built_in">len</span>(ans) == <span class="number">0</span> <span class="keyword">else</span> <span class="built_in">len</span>(ans)</span><br></pre></td></tr></table></figure><h2 id="山羊拉丁文"><a href="https://leetcode-cn.com/problems/goat-latin/">山羊拉丁文</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 太离谱了，除了变量命名不一样，他的运行比我快</span></span><br><span class="line"><span class="comment"># 复制成他的，速度快了，莫非是代码格式化的问题</span></span><br><span class="line"><span class="comment"># 36ms</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">toGoatLatin</span>(<span class="params">self, sentence: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        l = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;U&#x27;</span>]</span><br><span class="line">        words = sentence.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i, word <span class="keyword">in</span> <span class="built_in">enumerate</span>(words):</span><br><span class="line">            <span class="keyword">if</span> word[<span class="number">0</span>] <span class="keyword">in</span> l:</span><br><span class="line">                words[i] = word + <span class="string">&#x27;ma&#x27;</span> + <span class="string">&#x27;a&#x27;</span>*(i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                words[i] = word[<span class="number">1</span>:] + word[<span class="number">0</span>] + <span class="string">&#x27;ma&#x27;</span> + <span class="string">&#x27;a&#x27;</span> * (i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(words)</span><br><span class="line"><span class="comment"># 20ms</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">toGoatLatin</span>(<span class="params">self, sentence: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        l=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;U&#x27;</span>]</span><br><span class="line">        words=sentence.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i,word <span class="keyword">in</span> <span class="built_in">enumerate</span>(words):</span><br><span class="line">            <span class="keyword">if</span> word[<span class="number">0</span>] <span class="keyword">in</span> l:</span><br><span class="line">                words[i]=word+<span class="string">&#x27;ma&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*(i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                words[i]=word[<span class="number">1</span>:]+word[<span class="number">0</span>]+<span class="string">&#x27;ma&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*(i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(words)</span><br></pre></td></tr></table></figure><h2 id="旋转函数"><a href="https://leetcode-cn.com/problems/rotate-function/">旋转函数</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 想不出来</span></span><br><span class="line"><span class="comment"># 来自宫水三叶</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maxRotateFunction</span>(<span class="params">nums</span>):</span><br><span class="line">    num, n = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">    s = [<span class="number">0</span>] * (<span class="number">2</span> * n + <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">2</span> * n + <span class="number">1</span>):</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + nums[(i - <span class="number">1</span>) % n]</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        ans += nums[i] * i</span><br><span class="line">    cur = ans</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>, <span class="number">2</span> * n):</span><br><span class="line">        cur += nums[(i - <span class="number">1</span>) % n] * (n - <span class="number">1</span>)</span><br><span class="line">        cur -= s[i-<span class="number">1</span>] - s[i-n]</span><br><span class="line">        <span class="keyword">if</span> cur &gt; ans:</span><br><span class="line">            ans = cur</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"><span class="comment"># 官解</span></span><br><span class="line"><span class="comment"># F(0)与F(1)相差一个numSum, 并且(n-1)*nums[n-1]变为0 所以-n*nums[n-1]</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maxRotateFunction</span>(<span class="params">nums</span>):</span><br><span class="line">    numSum = <span class="built_in">sum</span>(nums)</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    f = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        f += nums[i]*i</span><br><span class="line">    res = f</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 每一次求新f，其旧f最后一个必为0</span></span><br><span class="line">        f = f + numSum - n*nums[n-i-<span class="number">1</span>]</span><br><span class="line">        res = <span class="built_in">max</span>(f, res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># 一行</span></span><br><span class="line"><span class="comment"># 摘自提交记录</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maxRotateFunction</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    n, s = <span class="built_in">len</span>(nums), <span class="built_in">sum</span>(nums)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(accumulate(<span class="built_in">reversed</span>(nums), <span class="keyword">lambda</span> a,b: a+s-n*b, initial=<span class="built_in">sum</span>(i * nums[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n))))</span><br><span class="line"><span class="comment"># 双百？</span></span><br><span class="line"><span class="comment"># https://leetcode-cn.com/problems/rotate-function/solution/by-jam007-wyqt/</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maxRotateFunction</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    res = cur = <span class="built_in">sum</span>(idx * num <span class="keyword">for</span> idx,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums))</span><br><span class="line">    total = <span class="built_in">sum</span>(nums)</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">while</span> nums:</span><br><span class="line">        cur += total - nums.pop() * n</span><br><span class="line">        res = cur <span class="keyword">if</span> cur &gt; res <span class="keyword">else</span> res</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="安装栅栏"><a href="https://leetcode-cn.com/problems/erect-the-fence/">安装栅栏</a></h2><p>困难题 pass</p><h2 id="二进制间距"><a href="https://leetcode-cn.com/problems/binary-gap/">二进制间距</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 好耶 ac</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binaryGap</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    s = <span class="built_in">bin</span>(n)</span><br><span class="line">    s = s[<span class="number">2</span>:]</span><br><span class="line">    right = left = s.find(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        <span class="keyword">if</span> s[left] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> ans &lt; left - right:</span><br><span class="line">                ans = left - right</span><br><span class="line">            right = left</span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"><span class="comment"># 官解</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binaryGap</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    last, ans, i = -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> last != -<span class="number">1</span>:</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, i - last)</span><br><span class="line">            last = i</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信头像透明or半透明</title>
      <link href="/2022/04/16/%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F%E9%80%8F%E6%98%8Eor%E5%8D%8A%E9%80%8F%E6%98%8E-wei-xin-tou-xiang-tou-ming-or-ban-tou-ming/"/>
      <url>/2022/04/16/%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F%E9%80%8F%E6%98%8Eor%E5%8D%8A%E9%80%8F%E6%98%8E-wei-xin-tou-xiang-tou-ming-or-ban-tou-ming/</url>
      
        <content type="html"><![CDATA[<h2 id="下载软件">下载软件</h2><p>准备工作：下载<a href="https://www.yeshen.com/cn/download/fullPackage?formal">夜神模拟器</a>、下载“<a href="https://f-droid.org/packages/jackpal.androidterm/">安卓终端模拟器</a>”<a href="https://f-droid.org/repo/jackpal.androidterm_72.apk">apk</a>文件、下载“<a href="https://www.wandoujia.com/">豌豆荚</a>”apk文件<br>将透明图片或者半透明图片移入夜神模拟器，（途中可能需要文件管理器的权限，直接允许即可）</p><h2 id="安装apk文件">安装apk文件</h2><p>将apk文件拖入夜神模拟器中，安装<strong>安卓终端模拟器</strong>、<strong>豌豆荚</strong>。</p><blockquote><p>注意，夜神模拟器需要安卓5.0版本的，7.0没试过，可以尝试一下</p></blockquote><h2 id="下载微信">下载微信</h2><p>豌豆荚的历史版本在微信的下载页面最下面，如果是mumu模拟器可能无法显示，需要点击安装/下载才会显示<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/profile/1650114121426-2353b685-a9cb-4f7a-8b3e-3259ad52f746.png" alt="image.png"><br>在豌豆荚中下载8.06版本的<strong>微信</strong>，（只要能安装并且登录的就行，如果你是安卓5.0版本的，不能安装最新版微信）<br>安装好微信后，登录并且新设备需要接受短信（登陆的时候用鼠标点击输入框，不要用tab键或其他，可能输入没反应）</p><h2 id="进行移花接木">进行移花接木</h2><p>打开安卓终端模拟器<br>输入“su”回车，再输入“pm uninstall -k <a href="http://com.tencent.mm">com.tencent.mm</a>”回车，如果无响应，新建一个窗口，或者点击那个灰色竖条<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/profile/1650113645387-b4816c1d-aa98-4a76-82e6-0b49e94eac3f.png" alt="image.png"><br>在win+r后输入</p><blockquote><p><strong>adb shell pm uninstall -k <a href="http://com.tencent.mm">com.tencent.mm</a>.</strong></p></blockquote><p>点击确定<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/profile/1650113715862-a9ab8df0-474d-448c-b919-798950b46930.png" alt="image.png"><br>此时微信已经卸载，并且已经保存登录状态</p><h2 id="下载旧版本微信">下载旧版本微信</h2><p>在豌豆荚下载7.0.9版本的微信，安装完后点击打开即可进行切换头像，将你放入的头像用触摸板两指放大或者ctrl+鼠标滚轮放大，放着上下移动都可以，多试试就能出来透明头像<br>tips：</p><ul><li>如果是黑字透明底，更换头像的时候无法显示。</li><li>非透明建议改成其他颜色，并且区域小一点，否则放大容易超出头像框</li><li>iphone手机免疫一切透明</li></ul><p>参考链接：<br><a href="https://zhuanlan.zhihu.com/p/473839446">https://zhuanlan.zhihu.com/p/473839446</a><br>另一个办法，比较繁琐，成功率较低：<a href="https://zhuanlan.zhihu.com/p/445720417">https://zhuanlan.zhihu.com/p/445720417</a></p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(leetcode) 四日四题</title>
      <link href="/2022/04/16/leetcode%E5%9B%9B%E6%97%A5%E5%9B%9B%E9%A2%98-leetcode-four-day-four-ans/"/>
      <url>/2022/04/16/leetcode%E5%9B%9B%E6%97%A5%E5%9B%9B%E9%A2%98-leetcode-four-day-four-ans/</url>
      
        <content type="html"><![CDATA[<h2 id="O-1-时间插入、删除和获取随机元素"><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1/">O(1) 时间插入、删除和获取随机元素</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴力</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.<span class="built_in">list</span> = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.<span class="built_in">list</span>:</span><br><span class="line">            self.<span class="built_in">list</span>.append(val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.<span class="built_in">list</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.<span class="built_in">list</span>.remove(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getRandom</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> choice(self.<span class="built_in">list</span>)</span><br><span class="line"><span class="comment"># list + 哈希表</span></span><br><span class="line"><span class="comment"># 执行用时：620 ms</span></span><br><span class="line"><span class="comment"># 内存消耗：49.4 MB</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.nums = []</span><br><span class="line">        self.indices = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># len(nums) 下标从0开始</span></span><br><span class="line">        self.indices[val] = <span class="built_in">len</span>(self.nums)</span><br><span class="line">        self.nums.append(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 将val放在list末尾后，防止移动</span></span><br><span class="line">        idx = self.indices[val]</span><br><span class="line">        self.nums[idx] = self.nums[-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 先修改indices再删除nums的元素，防止index out of range</span></span><br><span class="line">        self.indices[self.nums[idx]] = idx</span><br><span class="line">        self.nums.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getRandom</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> choice(self.nums)</span><br><span class="line"><span class="comment"># 使用set 效率与上面差不多</span></span><br><span class="line"><span class="comment"># 执行用时: 532 ms</span></span><br><span class="line"><span class="comment"># 内存消耗: 49.5 MB</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.nums = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.nums.add(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.nums.remove(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getRandom</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> choice(<span class="built_in">list</span>(self.nums))</span><br></pre></td></tr></table></figure><h2 id="最富有客户的资产总量"><a href="https://leetcode-cn.com/problems/richest-customer-wealth/">最富有客户的资产总量</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码长</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maximumWealth</span>(<span class="params">self, accounts: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    m = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> accounts:</span><br><span class="line">        s = <span class="built_in">sum</span>(i)</span><br><span class="line">        <span class="keyword">if</span> s &gt; m:</span><br><span class="line">            m = s</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"><span class="comment"># 代码短</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maximumWealth</span>(<span class="params">self, accounts: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># max()返回最大行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="built_in">max</span>(accounts, key=<span class="built_in">sum</span>))</span><br><span class="line">    <span class="comment"># map()返回每行求和值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">map</span>(<span class="built_in">sum</span>, accounts))</span><br></pre></td></tr></table></figure><h2 id="迷你语法分析器"><a href="https://leetcode-cn.com/problems/mini-parser/">迷你语法分析器</a></h2><p>看接口原型：<a href="https://leetcode-cn.com/problems/mini-parser/solution/by-ac_oier-zuy6/1507877">Link</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一行解决 双百效率摘自评论区</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; NestedInteger:</span><br><span class="line">    <span class="keyword">return</span> json.loads(s)</span><br><span class="line"><span class="comment"># 不想写了 取自题解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; NestedInteger:</span><br><span class="line">        <span class="comment"># 纯数字</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] != <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> NestedInteger(<span class="built_in">int</span>(s))</span><br><span class="line">        stack, curVal, sign = [], <span class="number">0</span>, <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">match</span> c:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                    <span class="comment"># 递归嵌套</span></span><br><span class="line">                    stack.append(NestedInteger())</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    <span class="comment"># 数字符号</span></span><br><span class="line">                    sign = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;,&#x27;</span>:</span><br><span class="line">                    <span class="comment"># 只有上一个字符是数字才加入了新的数字，否则可能是 &quot;],&quot;</span></span><br><span class="line">                    <span class="keyword">if</span> s[i - <span class="number">1</span>].isdigit():</span><br><span class="line">                        stack[-<span class="number">1</span>].add(NestedInteger(-curVal <span class="keyword">if</span> sign <span class="keyword">else</span> curVal))</span><br><span class="line">                    curVal, sign = <span class="number">0</span>, <span class="literal">False</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                    <span class="comment"># 只有上一个字符是数字才加入了新的数字，否则可能是 &quot;[]&quot;</span></span><br><span class="line">                    <span class="keyword">if</span> s[i - <span class="number">1</span>].isdigit():</span><br><span class="line">                        stack[-<span class="number">1</span>].add(NestedInteger(-curVal <span class="keyword">if</span> sign <span class="keyword">else</span> curVal))</span><br><span class="line">                    <span class="comment"># 弹出栈，并将当前的对象加入嵌套的列表中</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">1</span>:</span><br><span class="line">                        cur = stack.pop()</span><br><span class="line">                        stack[-<span class="number">1</span>].add(cur)</span><br><span class="line">                    curVal, sign = <span class="number">0</span>, <span class="literal">False</span></span><br><span class="line">                <span class="keyword">case</span> _:</span><br><span class="line">                    <span class="comment"># 数字计算</span></span><br><span class="line">                    curVal = curVal * <span class="number">10</span> + <span class="built_in">int</span>(c)</span><br><span class="line">        <span class="keyword">return</span> stack.pop()</span><br></pre></td></tr></table></figure><h2 id="最大回文数乘积"><a href="https://leetcode-cn.com/problems/largest-palindrome-product/">最大回文数乘积</a></h2><p>学习回文数构造</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 官解</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">largestPalindrome</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">9</span>  <span class="comment"># 9无法回文，但是个位数最大</span></span><br><span class="line">    upper = <span class="built_in">pow</span>(<span class="number">10</span>, n) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> left <span class="keyword">in</span> <span class="built_in">range</span>(upper, upper // <span class="number">10</span>, -<span class="number">1</span>):  <span class="comment"># upper//10</span></span><br><span class="line">        p, x = left, left</span><br><span class="line">        <span class="keyword">while</span> x:  <span class="comment"># 判断回文数</span></span><br><span class="line">            <span class="comment"># 当p=98</span></span><br><span class="line">            <span class="comment"># 98*10+98%10 = 980+8</span></span><br><span class="line">            <span class="comment"># 988*10+9%10 =  9880+9</span></span><br><span class="line">            <span class="comment"># 9889</span></span><br><span class="line">            p = p * <span class="number">10</span> + x % <span class="number">10</span>  <span class="comment"># 拼接回文数</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        x = upper</span><br><span class="line">        <span class="comment"># 使x满足要求 99*99=9801&lt;9999</span></span><br><span class="line">        <span class="comment"># 并且x从最大值开始，则x*x也为当前最大值，不满足条件时，比x小的值也无法等于p</span></span><br><span class="line">        <span class="keyword">while</span> x * x &gt;= p:</span><br><span class="line">            <span class="keyword">if</span> p % x == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> p % <span class="number">1337</span></span><br><span class="line">            x -= <span class="number">1</span></span><br><span class="line"><span class="comment"># 判断回文数，未优化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">x, n</span>):  <span class="comment"># n指定位数</span></span><br><span class="line">    <span class="comment"># https://blog.csdn.net/u012509485/article/details/79586770</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span>:  <span class="comment"># 不知道位数，判断x的位数</span></span><br><span class="line">        n = <span class="built_in">int</span>(math.log10(x)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">elif</span> x == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        n = <span class="built_in">int</span>(math.log10(-x)+<span class="number">1</span>)</span><br><span class="line">    x = <span class="built_in">str</span>(x)</span><br><span class="line">    left = <span class="built_in">len</span>(x) - <span class="number">1</span></span><br><span class="line">    right = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        <span class="keyword">if</span> x[left] != x[right]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        left -= <span class="number">1</span></span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(leetcode) 四日四题</title>
      <link href="/2022/04/13/leetcode%E5%9B%9B%E6%97%A5%E5%9B%9B%E9%A2%98-leetcode-si-ri-si-ti/"/>
      <url>/2022/04/13/leetcode%E5%9B%9B%E6%97%A5%E5%9B%9B%E9%A2%98-leetcode-si-ri-si-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="到达终点"><a href="https://leetcode-cn.com/problems/reaching-points/">到达终点</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 摘自评论</span></span><br><span class="line"><span class="comment"># https://leetcode-cn.com/problems/reaching-points/comments/85185</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reachingPoints</span>(<span class="params">self, sx, sy, tx, ty</span>):</span><br><span class="line">    <span class="keyword">while</span> tx &gt; <span class="number">0</span> <span class="keyword">and</span> ty &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> tx == sx <span class="keyword">and</span> ty == sy:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> tx &gt; ty:</span><br><span class="line">            <span class="comment"># tx - sx是目标与起始值在x的差距，我们需要一次减去n * ty达到快速逼近sx的目的</span></span><br><span class="line">            <span class="comment"># 差距除于ty可以得到差距里包含多少个ty即n*ty</span></span><br><span class="line">            <span class="comment"># 我太笨了</span></span><br><span class="line">            tx -= ty * <span class="built_in">max</span>((tx-sx)/ty, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ty -= tx * <span class="built_in">max</span>((ty-sy)/tx, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="唯一摩尔斯密码词"><a href="https://leetcode-cn.com/problems/unique-morse-code-words/">唯一摩尔斯密码词</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">uniqueMorseRepresentations</span>(<span class="params">self, words</span>):</span><br><span class="line">    Mose =[<span class="string">&quot;.-&quot;</span>,<span class="string">&quot;-...&quot;</span>,<span class="string">&quot;-.-.&quot;</span>,<span class="string">&quot;-..&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;..-.&quot;</span>,<span class="string">&quot;--.&quot;</span>,<span class="string">&quot;....&quot;</span>,<span class="string">&quot;..&quot;</span>,</span><br><span class="line">              <span class="string">&quot;.---&quot;</span>,<span class="string">&quot;-.-&quot;</span>,<span class="string">&quot;.-..&quot;</span>,<span class="string">&quot;--&quot;</span>,<span class="string">&quot;-.&quot;</span>,<span class="string">&quot;---&quot;</span>,<span class="string">&quot;.--.&quot;</span>,<span class="string">&quot;--.-&quot;</span>,<span class="string">&quot;.-.&quot;</span>,<span class="string">&quot;...&quot;</span>,</span><br><span class="line">              <span class="string">&quot;-&quot;</span>,<span class="string">&quot;..-&quot;</span>,<span class="string">&quot;...-&quot;</span>,<span class="string">&quot;.--&quot;</span>,<span class="string">&quot;-..-&quot;</span>,<span class="string">&quot;-.--&quot;</span>,<span class="string">&quot;--..&quot;</span>]</span><br><span class="line"></span><br><span class="line">    translate = []</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">        strs = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            idx = <span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            strs += Mose[idx]</span><br><span class="line">        translate.append(strs)</span><br><span class="line">    count = Counter(translate)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(count)</span><br><span class="line"><span class="comment"># 利用set元素不重复</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniqueMorseRepresentations</span>(<span class="params">self, words</span>):</span><br><span class="line">        mos =[<span class="string">&quot;.-&quot;</span>,<span class="string">&quot;-...&quot;</span>,<span class="string">&quot;-.-.&quot;</span>,<span class="string">&quot;-..&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;..-.&quot;</span>,<span class="string">&quot;--.&quot;</span>,<span class="string">&quot;....&quot;</span>,<span class="string">&quot;..&quot;</span>,</span><br><span class="line">              <span class="string">&quot;.---&quot;</span>,<span class="string">&quot;-.-&quot;</span>,<span class="string">&quot;.-..&quot;</span>,<span class="string">&quot;--&quot;</span>,<span class="string">&quot;-.&quot;</span>,<span class="string">&quot;---&quot;</span>,<span class="string">&quot;.--.&quot;</span>,<span class="string">&quot;--.-&quot;</span>,<span class="string">&quot;.-.&quot;</span>,<span class="string">&quot;...&quot;</span>,</span><br><span class="line">              <span class="string">&quot;-&quot;</span>,<span class="string">&quot;..-&quot;</span>,<span class="string">&quot;...-&quot;</span>,<span class="string">&quot;.--&quot;</span>,<span class="string">&quot;-..-&quot;</span>,<span class="string">&quot;-.--&quot;</span>,<span class="string">&quot;--..&quot;</span>]</span><br><span class="line">        ans = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">              t = <span class="string">&quot;&quot;</span>.join([mos[<span class="built_in">ord</span>(letter)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] <span class="keyword">for</span> letter <span class="keyword">in</span> w])</span><br><span class="line">              ans.add(t)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(ans)</span><br></pre></td></tr></table></figure><h2 id="统计各位数字都不同的数字个数"><a href="https://leetcode-cn.com/problems/count-numbers-with-unique-digits/">统计各位数字都不同的数字个数</a></h2><p><a href="https://leetcode-cn.com/problems/count-numbers-with-unique-digits/solution/tong-ji-ge-wei-shu-zi-du-bu-tong-de-shu-iqbfn/1498651">Link</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">n=0，数字有&#123;0&#125; 1个。</span><br><span class="line">n=1，数字有&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;  10个。</span><br><span class="line">n=2，数字包括两部分之和，一部分为n=1的所有10个答案，另一部分为长度为2的新增数字。长度为2的新增数字可以在n=1的所有9个数字基础上进行拼接（0不能算）。例如：</span><br><span class="line">从n=1的数字列表&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;中随便取出一个除0以外的数字（因为0不能作为起始数字！），我们取2好了。通过在2的尾巴处拼接一位数字可以得到新的合法数字有：</span><br><span class="line">&#123;20，21，23，24，25，26，27，28，29&#125;，</span><br><span class="line">可以看到，除了不能在尾巴处拼接一个2，0-9种一共有9个数字可以拿来拼接在尾巴处。新增答案为9个。同理，对于n=1数字列表&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;中的其他任意非0数也可以进行拼接操作，一共可以新增9*9个答案。</span><br><span class="line">最终，n=2的合法数字，n=1时的答案 + 长度为2的数字个数（9*9个）= 10 + 81 = 91。</span><br><span class="line">n=3时同理，只不过此时可以用拼接的数字减少为了8个，即前两位已经确定不一样，则第三位只能从10个数字选剩下8个</span><br><span class="line">此时答案为10 + 9 * 9 + 9 * 9 * 8 = 739。</span><br><span class="line">n=4时同理，只不过此时可以用拼接的数字减少为了7个，此时答案为10 + 9 * 9 + 9 * 9 * 8 + 9 * 9 * 8 * 7 = 5275。</span><br><span class="line">通过归纳不难得到，假设 dp[i] 即 n = i时的答案，则动态转移方程为：</span><br><span class="line">dp[i] = dp[i-1] + (dp[i-1] - dp[i-2])*(10-(i-1))</span><br><span class="line">转移的初始条件为</span><br><span class="line">dp[0] = 1</span><br><span class="line">dp[1] = 10</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 符合解释版</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    public <span class="built_in">int</span> countNumbersWithUniqueDigits(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span>[] dp = new <span class="built_in">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="comment"># dp[i-1] - dp[i-2]只留下9*9*...这一部分</span></span><br><span class="line">            <span class="comment"># 10-(i-1) 判断10个数中剩下几位可以不重复</span></span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + (dp[i-<span class="number">1</span>] - dp[i-<span class="number">2</span>])*(<span class="number">10</span>-(i-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 官方题解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNumbersWithUniqueDigits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">        res, cur = <span class="number">10</span>, <span class="number">9</span></span><br><span class="line">        <span class="comment"># 当n=2时，只需要9*9，循环一次</span></span><br><span class="line">        <span class="comment"># 当n=3时，只需要9*9+9*9*8，循环两次即n-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">            cur *= <span class="number">9</span> - i</span><br><span class="line">            res += cur</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># 进阶做法</span></span><br><span class="line"><span class="comment"># https://leetcode-cn.com/problems/count-numbers-with-unique-digits/solution/by-ac_oier-6tfl/</span></span><br></pre></td></tr></table></figure><h2 id="写字符串需要的行数"><a href="https://leetcode-cn.com/problems/number-of-lines-to-write-string/">写字符串需要的行数</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单题重拳出击</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">numberOfLines</span>(<span class="params">self, widths, s</span>):</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    rows = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        cnt += widths[<span class="built_in">ord</span>(s[i])-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)]</span><br><span class="line">        <span class="comment"># 因为遇到这个案例</span></span><br><span class="line">        <span class="comment"># [3, 4, 10, 4, 8, 7, 3, 3, 4, 9, 8, 2, 9, 6, 2, 8, 4, 9, 9, 10, 2, 4, 9, 10, 8, 2]</span></span><br><span class="line">        <span class="comment"># &quot;mqblbtpvicqhbrejb&quot;</span></span><br><span class="line">        <span class="comment"># 实际上加不加无所谓</span></span><br><span class="line">        <span class="keyword">if</span> cnt == <span class="number">100</span> <span class="keyword">and</span> i == <span class="built_in">len</span>(s)-<span class="number">1</span>: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> cnt &gt; <span class="number">100</span>:</span><br><span class="line">            rows += <span class="number">1</span></span><br><span class="line">            cnt = widths[<span class="built_in">ord</span>(s[i])-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)]</span><br><span class="line">    <span class="keyword">return</span> [rows+<span class="number">1</span>, cnt]</span><br><span class="line"><span class="comment"># 正解</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">numberOfLines</span>(<span class="params">widths, s</span>):</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    rows = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        cnt += widths[<span class="built_in">ord</span>(s[i])-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)]</span><br><span class="line">        <span class="keyword">if</span> cnt &gt; <span class="number">100</span>:</span><br><span class="line">            rows += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 大于100说明这个字符已经超出，需要放到下一行</span></span><br><span class="line">            cnt = widths[<span class="built_in">ord</span>(s[i])-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)]</span><br><span class="line">    <span class="keyword">return</span> [rows+<span class="number">1</span>, cnt]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(leetcode) 四日四题</title>
      <link href="/2022/04/12/leetcode%E5%9B%9B%E6%97%A5%E5%9B%9B%E9%A2%98-leetcode-four-day-four-answer-1/"/>
      <url>/2022/04/12/leetcode%E5%9B%9B%E6%97%A5%E5%9B%9B%E9%A2%98-leetcode-four-day-four-answer-1/</url>
      
        <content type="html"><![CDATA[<h2 id="二进制表示中质数个计算置位"><a href="https://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation/">二进制表示中质数个计算置位</a></h2><p><a href="https://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation/solution/er-jin-zhi-biao-shi-zhong-zhi-shu-ge-ji-jy35g/1486534">Link</a><br>1，计算整数x的二进制表示有多少个1： x&amp;=x-1可以消除x最低位的1，while循环计数，直到x=0即可。<br>2，只保留整数x最低位的1： x&amp;-x ，暨鼎鼎大名的lowbit</p><blockquote><blockquote><p>1 相当于除2，&lt;&lt;1相当与乘2，因为一位相当于2^1</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴力，但忘记素数怎么求</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">x</span>):</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> x != <span class="number">0</span>:</span><br><span class="line">        x -= x &amp; -x  <span class="comment"># x &amp; -x</span></span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> isPrime(cnt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isPrime</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(x**<span class="number">0.5</span>)+<span class="number">1</span>):  <span class="comment"># 优化循环次数</span></span><br><span class="line">        <span class="keyword">if</span> x % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countPrimeSetBits</span>(<span class="params">left, right</span>):</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> check(i):</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"><span class="comment"># python库</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countPrimeSetBits</span>(<span class="params">left, right</span>):</span><br><span class="line">    prime = (<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>)  <span class="comment"># 因为right最大不超过20位</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="built_in">bin</span>(i).count(<span class="string">&#x27;1&#x27;</span>) <span class="keyword">in</span> prime <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>))</span><br><span class="line"><span class="comment"># 10100010100010101100存储上述素数</span></span><br><span class="line"><span class="comment"># 当x中1的个数与该数求&amp;不为0，则说明1的个数在上述素数组合内</span></span><br><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countPrimeSetBits</span>(<span class="params">left, right</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(((<span class="number">1</span> &lt;&lt; x.bit_count()) &amp; <span class="number">665772</span>) != <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="旋转字符串"><a href="https://leetcode-cn.com/problems/rotate-string/">旋转字符串</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotateString</span>(<span class="params">self, s, goal</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            newS = s[<span class="number">1</span>] + s[<span class="number">2</span>:<span class="built_in">len</span>(s)] + s[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> newS == goal:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            s = newS</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="comment"># 首尾相连包括所有可能</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotateString</span>(<span class="params">self, s: <span class="built_in">str</span>, goal: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s) == <span class="built_in">len</span>(goal) <span class="keyword">and</span> goal <span class="keyword">in</span> s + s</span><br></pre></td></tr></table></figure><h2 id="N-叉树的层序遍历"><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">N 叉树的层序遍历</a></h2><p>模板题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    ans = <span class="built_in">list</span>()</span><br><span class="line">    q = deque([root])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        cnt = <span class="built_in">len</span>(q)</span><br><span class="line">        level = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(cnt):</span><br><span class="line">            cur = q.popleft()</span><br><span class="line">            level.append(cur.val)</span><br><span class="line">            <span class="keyword">for</span> child <span class="keyword">in</span> cur.children:</span><br><span class="line">                q.append(child)</span><br><span class="line">        ans.append(level)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="最小高度树"><a href="https://leetcode-cn.com/problems/minimum-height-trees/">最小高度树</a></h2><p>难 暂放</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(leetcode) 三日三题</title>
      <link href="/2022/04/10/leetcode%20%E4%B8%89%E6%97%A5%E4%B8%89%E9%A2%98-leetcode-three-day-three-code-1/"/>
      <url>/2022/04/10/leetcode%20%E4%B8%89%E6%97%A5%E4%B8%89%E9%A2%98-leetcode-three-day-three-code-1/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://leetcode-cn.com/problems/array-of-doubled-pairs/">二倍数对数组</a></h1><p>思路就是 使得每一个奇数位置的值均是前一个位置的值的两倍，即凑成 n/2 对元素形如 (x, 2 * x) 的数对。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用python的Counter，计算每一个值的个数</span></span><br><span class="line"><span class="comment"># 只需要通过arr[2 * i + 1] = 2 * arr[2 * i] 是否符合即可</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">canReorderDoubled</span>(<span class="params">arr</span>):</span><br><span class="line">    cnt = Counter(arr)</span><br><span class="line">    <span class="keyword">if</span> cnt[<span class="number">0</span>] % <span class="number">2</span>:  <span class="comment"># 如果0为奇数，则必不可能满足</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sorted</span>(cnt, key=<span class="built_in">abs</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">sorted</span>(cnt, key=<span class="built_in">abs</span>):</span><br><span class="line">        <span class="keyword">if</span> cnt[i] &gt; cnt[<span class="number">2</span> * i]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        cnt[<span class="number">2</span>*i] -= cnt[i]  <span class="comment"># 将(小，大)中的大数删除，防止cnt[2*大]没有值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="comment"># 用两个队列</span></span><br><span class="line"><span class="comment"># https://leetcode-cn.com/problems/array-of-doubled-pairs/solution/fen-jie-wei-liang-ge-dui-lie-by-mooc-3/</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">canReorderDoubled</span>(<span class="params">arr</span>):</span><br><span class="line">    q1 = []</span><br><span class="line">    q2 = []</span><br><span class="line">    arr = <span class="built_in">sorted</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(q1) <span class="keyword">and</span> <span class="number">2</span>*i == q1[<span class="number">0</span>]:</span><br><span class="line">                q1.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                q1.append(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(q2) <span class="keyword">and</span> i == <span class="number">2</span>*q2[<span class="number">0</span>]:</span><br><span class="line">                q2.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                q2.append(i)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(q1) <span class="keyword">and</span> <span class="keyword">not</span> <span class="built_in">len</span>(q2):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="寻找比目标字母大的最小字母"><a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/">寻找比目标字母大的最小字母</a></h2><p>简单题重拳出击，二分法忘了😓</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nextGreatestLetter</span>(<span class="params">self, letters, target</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> letters:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">ord</span>(i)-<span class="built_in">ord</span>(target) &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> letters[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 二分</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nextGreatestLetter</span>(<span class="params">letters, target</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(letters)</span><br><span class="line">    l, r = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        <span class="built_in">print</span>(l, r, l + r &gt;&gt; <span class="number">1</span>, (l + r) // <span class="number">2</span>,  <span class="built_in">bin</span>(l + r))</span><br><span class="line">        mid = l + r &gt;&gt; <span class="number">1</span>  <span class="comment"># l + r &gt;&gt; 1 &lt;=&gt; (l + r) // 2 运算符优先级</span></span><br><span class="line">        <span class="keyword">if</span> letters[mid] &gt; target:</span><br><span class="line">            r = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> letters[r] <span class="keyword">if</span> letters[r] &gt; target <span class="keyword">else</span> letters[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 一行</span></span><br><span class="line"><span class="comment"># https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/comments/1482439</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nextGreatestLetter</span>(<span class="params">self, letters: <span class="type">List</span>[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> letters[bisect.bisect(letters, target) % <span class="built_in">len</span>(letters)]</span><br></pre></td></tr></table></figure><h2 id="区域和检索-数组可修改"><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/">区域和检索 - 数组可修改</a></h2><p>前缀和概念：<a href="https://zhuanlan.zhihu.com/p/107778275">Link</a>、<a href="https://juejin.cn/post/6944913393627168798">Link2</a></p><blockquote><p>int n = nums.length;<br>int[] preSum = new int[n + 1];  // 前缀和数组<br>preSum[0] = 0;<br>for (int i = 0; i &lt; n; i++)<br>preSum[i + 1] = preSum[i] + nums[i];</p></blockquote><h3 id="树形数组">树形数组</h3><p>先记住最精髓的一句话：<strong>树状数组本质是二进制规律的应用</strong><br>假设现在有一个线性数组A,为了便于理解A的范围从1–8。<br>并构造一个数组C，范围也是1–8<br>接下来将C构造为那么一个树结构：<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/leetcode/1649161994149-226aa556-cf96-4b39-9afb-09b4bead3311.png" alt="image.png"><br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/leetcode/1649162012125-38b98bb6-d4c2-4a42-8db2-947a33982cfb.png" alt="image.png"><br>观察这棵树结构，可以发现叶子结点的二进制的最后一位为1。接下来的结点为倒数第二位为1…<br>现在，我们对这棵树结构赋予其涵义：</p><blockquote><p>二进制<br>1=(001)      C[1]=A[1];<br>2=(010)      C[2]=A[1]+A[2];<br>3=(011)      C[3]=A[3];<br>4=(100)      C[4]=A[1]+A[2]+A[3]+A[4];<br>5=(101)      C[5]=A[5];<br>6=(110)      C[6]=A[5]+A[6];<br>7=(111)      C[7]=A[7];<br>8=(1000)     C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8];</p><p>这么说吧，这棵树的规律就是找出相应结点的二进制最后一位的1并该位后面的0也截出(后面会讲的lowBit函数)。<br>如5(101),最后一个1截出为1，那么它只有一个结点，那么他就是叶子结点。<br>如6(110),最后一个1截出为10，那么它这棵子树上有两个结点</p><p>非常重要：而某元素的父结点为该结点6(110)加上此结点的二进制截出最后一位的1(即010)(后面会讲的lowBit函数)。<br>如6(110)+2(010)=8(1000)</p></blockquote><h3 id="树形数组的单点元素修改和查询区间和规律">树形数组的单点元素修改和查询区间和规律</h3><p>1.lowBit函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowBit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先需要知道lowBit函数的含义：可以用来获取某个二进制数的LowBit(即截出最后一个1及其后面的bit)<br>2.单点元素修改<br>结合上图：</p><blockquote><p>当更新A[1]时(设新的A[1]比原来增加了d),需要自下向上更新C[1],C[2],C[4],C[8]<br>写为二进制：C[(001)],C[(010)],C[(100)],C[(1000)]</p><p>lowBit(1)=001   1+lowBit(1)=2(010)     C[2]+=d<br>lowBit(2)=010   2+lowBit(2)=4(100)     C[4]+=d<br>lowBit(4)=100   4+lowBit(4)=8(1000)    C[8]+=d</p><p>总结规律：即找到1所在结点，然后用lowBit函数依次自下而上更新其所有父结点</p></blockquote><p>3.求区间和</p><blockquote><p>以求5-7之间的区间和为例，设区间和presum:</p><p>先求1-7之间的和，即7的前缀和。</p><p>7(111)                              presum+=C[7]<br>lowBit(7)=001    7-lowBit(7)=6(110)    presum+=C[6]<br>lowBit(6)=010    6-lowBit(6)=4(100)    presum+=C[4]<br>lowBit(4)=100    4-lowBit(4)=0(000)</p><p>总结规律：找到7所在结点，用lowBit函数不断消去最后一个1，并进行累加</p><p>再求1-5之间的和。</p><p>5(101)                        presum+=C[5]<br>lowBit(5)=001    5-lowBit(5)=4(100)    presum+=C[4]<br>lowBit(4)=100    4-lowBit(4)=0(000)</p><p>最后将两个前缀和相减就得到区间和了。</p></blockquote><p><strong>python版代码在下面</strong><br>作者：fenjue<br>链接：<a href="https://leetcode-cn.com/problems/range-sum-query-mutable/solution/by-fenjue-ewfb/">https://leetcode-cn.com/problems/range-sum-query-mutable/solution/by-fenjue-ewfb/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分块处理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums</span>):</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        size = <span class="built_in">int</span>(n ** <span class="number">0.5</span>)</span><br><span class="line">        sums = [<span class="number">0</span>] * ((n + size - <span class="number">1</span>) // size)  <span class="comment"># 向上取整，记住就好了</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            sums[i // size] += num</span><br><span class="line">        self.sums = sums</span><br><span class="line">        self.size = size</span><br><span class="line">        self.nums = nums</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, index, val</span>):</span><br><span class="line">        <span class="comment"># 更新sums[块号]的值</span></span><br><span class="line">        self.sums[index // self.size] += val - self.nums[index]</span><br><span class="line">        self.nums[index] = val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRange</span>(<span class="params">self, left, right</span>):</span><br><span class="line">        m = self.size</span><br><span class="line">        b1, b2 = left // m, right // m</span><br><span class="line">        <span class="keyword">if</span> b1 == b2:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span>(self.nums[left:right + <span class="number">1</span>])</span><br><span class="line">        <span class="comment"># b1:[left: size-1] + sum(b2-b1) + b2: [0: right+1]</span></span><br><span class="line">        <span class="comment"># b1的size-1 为前面块个数之和 即(b1+1)*m 因为块下标从0开始</span></span><br><span class="line">        <span class="comment"># b2的b2*m 为前面块个数之和-1 即b2*m</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(self.nums[left: (b1 + <span class="number">1</span>) * m]) + \</span><br><span class="line">               <span class="built_in">sum</span>(self.sums[b1 + <span class="number">1</span>: b2]) + <span class="built_in">sum</span>(self.nums[b2 * m: right + <span class="number">1</span>])</span><br><span class="line">obj = NumArray([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line">param_2 = obj.sumRange(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(param_2)</span><br><span class="line">obj.update(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">param_2 = obj.sumRange(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="number">3</span> ** <span class="number">0.5</span>))</span><br><span class="line"><span class="built_in">print</span>(param_2, obj.nums)</span><br><span class="line"><span class="comment"># 树形数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># i += lowBit(i) 取出父节点</span></span><br><span class="line">    <span class="comment"># i -= lowBit(i) 取出子节点</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums</span>):</span><br><span class="line">        self.A = nums</span><br><span class="line">        self.C = [<span class="number">0</span>] * (<span class="built_in">len</span>(nums) + <span class="number">1</span>)</span><br><span class="line">        self.n = <span class="built_in">len</span>(self.A)</span><br><span class="line">        self.m = <span class="built_in">len</span>(self.C)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, self.m):</span><br><span class="line">            self.C[i] += self.A[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> i + self.lowbit(i) &lt; self.m:</span><br><span class="line">                self.C[i + self.lowbit(i)] += self.C[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, index, val</span>):</span><br><span class="line">        d = val - self.A[index]</span><br><span class="line">        <span class="comment"># A的下标从0开始，C的下标从1开始，所以index+1</span></span><br><span class="line">        i = index+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; self.m:</span><br><span class="line">            self.C[i] += d</span><br><span class="line">            i += self.lowbit(i)</span><br><span class="line">        <span class="comment"># for i in range(index + 1, self.m): # 不能这样子写for</span></span><br><span class="line">        <span class="comment">#     self.C[i] += d</span></span><br><span class="line">        <span class="comment">#     i += self.lowbit(i)</span></span><br><span class="line">        self.A[index] = val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRange</span>(<span class="params">self, left, right</span>):</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        i = right + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">1</span>:</span><br><span class="line">            r += self.C[i]</span><br><span class="line">            i -= self.lowbit(i)</span><br><span class="line">        i = left</span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            l += self.C[i]</span><br><span class="line">            i -= self.lowbit(i)</span><br><span class="line">        <span class="keyword">return</span> r - l</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowbit</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x</span><br></pre></td></tr></table></figure><blockquote><p>针对不同的题目，我们有不同的方案可以选择（假设我们有一个数组）：</p><p>数组不变，求区间和：「前缀和」、「树状数组」、「线段树」<br>多次修改某个数（单点），求区间和：「树状数组」、「线段树」<br>多次修改某个区间，输出最终结果：「差分」<br>多次修改某个区间，求区间和：「线段树」、「树状数组」（看修改区间范围大小）<br>多次将某个区间变成同一个数，求区间和：「线段树」、「树状数组」（看修改区间范围大小）</p></blockquote><blockquote><p>总结一下，我们应该按这样的优先级进行考虑：</p><ol><li>简单求区间和，用「前缀和」</li><li>多次将某个区间变成同一个数，用「线段树」</li><li>其他情况，用「树状数组」</li></ol></blockquote><p>作者：AC_OIer<br>链接：<a href="https://leetcode-cn.com/problems/range-sum-query-mutable/solution/guan-yu-ge-lei-qu-jian-he-wen-ti-ru-he-x-41hv/">https://leetcode-cn.com/problems/range-sum-query-mutable/solution/guan-yu-ge-lei-qu-jian-he-wen-ti-ru-he-x-41hv/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(leetcode) 三日三题</title>
      <link href="/2022/04/05/leetcode%E4%B8%89%E6%97%A5%E4%B8%89%E9%A2%98-leetcode-three-day-three-code/"/>
      <url>/2022/04/05/leetcode%E4%B8%89%E6%97%A5%E4%B8%89%E9%A2%98-leetcode-three-day-three-code/</url>
      
        <content type="html"><![CDATA[<p>因为第三题有点难 迟一天发送😂</p><h1><a href="https://leetcode-cn.com/problems/array-of-doubled-pairs/">二倍数对数组</a></h1><p>思路就是 使得每一个奇数位置的值均是前一个位置的值的两倍，即凑成 n/2 对元素形如 (x, 2 * x) 的数对。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用python的Counter，计算每一个值的个数</span></span><br><span class="line"><span class="comment"># 只需要通过arr[2 * i + 1] = 2 * arr[2 * i] 是否符合即可</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">canReorderDoubled</span>(<span class="params">arr</span>):</span><br><span class="line">    cnt = Counter(arr)</span><br><span class="line">    <span class="keyword">if</span> cnt[<span class="number">0</span>] % <span class="number">2</span>:  <span class="comment"># 如果0为奇数，则必不可能满足</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sorted</span>(cnt, key=<span class="built_in">abs</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">sorted</span>(cnt, key=<span class="built_in">abs</span>):</span><br><span class="line">        <span class="keyword">if</span> cnt[i] &gt; cnt[<span class="number">2</span> * i]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        cnt[<span class="number">2</span>*i] -= cnt[i]  <span class="comment"># 将(小，大)中的大数删除，防止cnt[2*大]没有值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="comment"># 用两个队列</span></span><br><span class="line"><span class="comment"># https://leetcode-cn.com/problems/array-of-doubled-pairs/solution/fen-jie-wei-liang-ge-dui-lie-by-mooc-3/</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">canReorderDoubled</span>(<span class="params">arr</span>):</span><br><span class="line">    q1 = []</span><br><span class="line">    q2 = []</span><br><span class="line">    arr = <span class="built_in">sorted</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(q1) <span class="keyword">and</span> <span class="number">2</span>*i == q1[<span class="number">0</span>]:</span><br><span class="line">                q1.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                q1.append(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(q2) <span class="keyword">and</span> i == <span class="number">2</span>*q2[<span class="number">0</span>]:</span><br><span class="line">                q2.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                q2.append(i)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(q1) <span class="keyword">and</span> <span class="keyword">not</span> <span class="built_in">len</span>(q2):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="寻找比目标字母大的最小字母"><a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/">寻找比目标字母大的最小字母</a></h2><p>简单题重拳出击，二分法忘了😓</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nextGreatestLetter</span>(<span class="params">self, letters, target</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> letters:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">ord</span>(i)-<span class="built_in">ord</span>(target) &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> letters[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 二分</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nextGreatestLetter</span>(<span class="params">letters, target</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(letters)</span><br><span class="line">    l, r = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        <span class="built_in">print</span>(l, r, l + r &gt;&gt; <span class="number">1</span>, (l + r) // <span class="number">2</span>,  <span class="built_in">bin</span>(l + r))</span><br><span class="line">        mid = l + r &gt;&gt; <span class="number">1</span>  <span class="comment"># l + r &gt;&gt; 1 &lt;=&gt; (l + r) // 2 运算符优先级</span></span><br><span class="line">        <span class="keyword">if</span> letters[mid] &gt; target:</span><br><span class="line">            r = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> letters[r] <span class="keyword">if</span> letters[r] &gt; target <span class="keyword">else</span> letters[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 一行</span></span><br><span class="line"><span class="comment"># https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/comments/1482439</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nextGreatestLetter</span>(<span class="params">self, letters: <span class="type">List</span>[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> letters[bisect.bisect(letters, target) % <span class="built_in">len</span>(letters)]</span><br></pre></td></tr></table></figure><h2 id="区域和检索-数组可修改"><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/">区域和检索 - 数组可修改</a></h2><p>前缀和概念：<a href="https://zhuanlan.zhihu.com/p/107778275">Link</a>、<a href="https://juejin.cn/post/6944913393627168798">Link2</a></p><blockquote><p>int n = nums.length;<br>int[] preSum = new int[n + 1];  // 前缀和数组<br>preSum[0] = 0;<br>for (int i = 0; i &lt; n; i++)<br>preSum[i + 1] = preSum[i] + nums[i];</p></blockquote><h3 id="树形数组">树形数组</h3><p>先记住最精髓的一句话：<strong>树状数组本质是二进制规律的应用</strong><br>假设现在有一个线性数组A,为了便于理解A的范围从1–8。<br>并构造一个数组C，范围也是1–8<br>接下来将C构造为那么一个树结构：<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/leetcode/1649161994149-226aa556-cf96-4b39-9afb-09b4bead3311.png" alt="image.png"><br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/leetcode/1649162012125-38b98bb6-d4c2-4a42-8db2-947a33982cfb.png" alt="image.png"><br>观察这棵树结构，可以发现叶子结点的二进制的最后一位为1。接下来的结点为倒数第二位为1…<br>现在，我们对这棵树结构赋予其涵义：</p><blockquote><p>二进制<br>1=(001)      C[1]=A[1];<br>2=(010)      C[2]=A[1]+A[2];<br>3=(011)      C[3]=A[3];<br>4=(100)      C[4]=A[1]+A[2]+A[3]+A[4];<br>5=(101)      C[5]=A[5];<br>6=(110)      C[6]=A[5]+A[6];<br>7=(111)      C[7]=A[7];<br>8=(1000)     C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8];</p><p>这么说吧，这棵树的规律就是找出相应结点的二进制最后一位的1并该位后面的0也截出(后面会讲的lowBit函数)。<br>如5(101),最后一个1截出为1，那么它只有一个结点，那么他就是叶子结点。<br>如6(110),最后一个1截出为10，那么它这棵子树上有两个结点</p><p>非常重要：而某元素的父结点为该结点6(110)加上此结点的二进制截出最后一位的1(即010)(后面会讲的lowBit函数)。<br>如6(110)+2(010)=8(1000)</p></blockquote><h3 id="树形数组的单点元素修改和查询区间和规律">树形数组的单点元素修改和查询区间和规律</h3><p>1.lowBit函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowBit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先需要知道lowBit函数的含义：可以用来获取某个二进制数的LowBit(即截出最后一个1及其后面的bit)<br>2.单点元素修改<br>结合上图：</p><blockquote><p>当更新A[1]时(设新的A[1]比原来增加了d),需要自下向上更新C[1],C[2],C[4],C[8]<br>写为二进制：C[(001)],C[(010)],C[(100)],C[(1000)]</p><p>lowBit(1)=001   1+lowBit(1)=2(010)     C[2]+=d<br>lowBit(2)=010   2+lowBit(2)=4(100)     C[4]+=d<br>lowBit(4)=100   4+lowBit(4)=8(1000)    C[8]+=d</p><p>总结规律：即找到1所在结点，然后用lowBit函数依次自下而上更新其所有父结点</p></blockquote><p>3.求区间和</p><blockquote><p>以求5-7之间的区间和为例，设区间和presum:</p><p>先求1-7之间的和，即7的前缀和。</p><p>7(111)                              presum+=C[7]<br>lowBit(7)=001    7-lowBit(7)=6(110)    presum+=C[6]<br>lowBit(6)=010    6-lowBit(6)=4(100)    presum+=C[4]<br>lowBit(4)=100    4-lowBit(4)=0(000)</p><p>总结规律：找到7所在结点，用lowBit函数不断消去最后一个1，并进行累加</p><p>再求1-5之间的和。</p><p>5(101)                        presum+=C[5]<br>lowBit(5)=001 | 5-lowBit(5)=4(100)     |presum+=C[4]<br>lowBit(4)=100 | 4-lowBit(4)=0(000)</p><p>最后将两个前缀和相减就得到区间和了。</p></blockquote><p><strong>python版代码在下面</strong><br>作者：fenjue<br>链接：<a href="https://leetcode-cn.com/problems/range-sum-query-mutable/solution/by-fenjue-ewfb/">https://leetcode-cn.com/problems/range-sum-query-mutable/solution/by-fenjue-ewfb/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分块处理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums</span>):</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        size = <span class="built_in">int</span>(n ** <span class="number">0.5</span>)</span><br><span class="line">        sums = [<span class="number">0</span>] * ((n + size - <span class="number">1</span>) // size)  <span class="comment"># 向上取整，记住就好了</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            sums[i // size] += num</span><br><span class="line">        self.sums = sums</span><br><span class="line">        self.size = size</span><br><span class="line">        self.nums = nums</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, index, val</span>):</span><br><span class="line">        <span class="comment"># 更新sums[块号]的值</span></span><br><span class="line">        self.sums[index // self.size] += val - self.nums[index]</span><br><span class="line">        self.nums[index] = val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRange</span>(<span class="params">self, left, right</span>):</span><br><span class="line">        m = self.size</span><br><span class="line">        b1, b2 = left // m, right // m</span><br><span class="line">        <span class="keyword">if</span> b1 == b2:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span>(self.nums[left:right + <span class="number">1</span>])</span><br><span class="line">        <span class="comment"># b1:[left: size-1] + sum(b2-b1) + b2: [0: right+1]</span></span><br><span class="line">        <span class="comment"># b1的size-1 为前面块个数之和 即(b1+1)*m 因为块下标从0开始</span></span><br><span class="line">        <span class="comment"># b2的b2*m 为前面块个数之和-1 即b2*m</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(self.nums[left: (b1 + <span class="number">1</span>) * m]) + \</span><br><span class="line">               <span class="built_in">sum</span>(self.sums[b1 + <span class="number">1</span>: b2]) + <span class="built_in">sum</span>(self.nums[b2 * m: right + <span class="number">1</span>])</span><br><span class="line">obj = NumArray([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line">param_2 = obj.sumRange(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(param_2)</span><br><span class="line">obj.update(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">param_2 = obj.sumRange(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="number">3</span> ** <span class="number">0.5</span>))</span><br><span class="line"><span class="built_in">print</span>(param_2, obj.nums)</span><br><span class="line"><span class="comment"># 树形数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># i += lowBit(i) 取出父节点</span></span><br><span class="line">    <span class="comment"># i -= lowBit(i) 取出子节点</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums</span>):</span><br><span class="line">        self.A = nums</span><br><span class="line">        self.C = [<span class="number">0</span>] * (<span class="built_in">len</span>(nums) + <span class="number">1</span>)</span><br><span class="line">        self.n = <span class="built_in">len</span>(self.A)</span><br><span class="line">        self.m = <span class="built_in">len</span>(self.C)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, self.m):</span><br><span class="line">            self.C[i] += self.A[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> i + self.lowbit(i) &lt; self.m:</span><br><span class="line">                self.C[i + self.lowbit(i)] += self.C[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, index, val</span>):</span><br><span class="line">        d = val - self.A[index]</span><br><span class="line">        <span class="comment"># A的下标从0开始，C的下标从1开始，所以index+1</span></span><br><span class="line">        i = index+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; self.m:</span><br><span class="line">            self.C[i] += d</span><br><span class="line">            i += self.lowbit(i)</span><br><span class="line">        <span class="comment"># for i in range(index + 1, self.m): # 不能这样子写for</span></span><br><span class="line">        <span class="comment">#     self.C[i] += d</span></span><br><span class="line">        <span class="comment">#     i += self.lowbit(i)</span></span><br><span class="line">        self.A[index] = val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRange</span>(<span class="params">self, left, right</span>):</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        i = right + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">1</span>:</span><br><span class="line">            r += self.C[i]</span><br><span class="line">            i -= self.lowbit(i)</span><br><span class="line">        i = left</span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            l += self.C[i]</span><br><span class="line">            i -= self.lowbit(i)</span><br><span class="line">        <span class="keyword">return</span> r - l</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowbit</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x</span><br></pre></td></tr></table></figure><blockquote><p>针对不同的题目，我们有不同的方案可以选择（假设我们有一个数组）：</p><p>数组不变，求区间和：「前缀和」、「树状数组」、「线段树」<br>多次修改某个数（单点），求区间和：「树状数组」、「线段树」<br>多次修改某个区间，输出最终结果：「差分」<br>多次修改某个区间，求区间和：「线段树」、「树状数组」（看修改区间范围大小）<br>多次将某个区间变成同一个数，求区间和：「线段树」、「树状数组」（看修改区间范围大小）</p></blockquote><blockquote><p>总结一下，我们应该按这样的优先级进行考虑：</p><ol><li>简单求区间和，用「前缀和」</li><li>多次将某个区间变成同一个数，用「线段树」</li><li>其他情况，用「树状数组」</li></ol></blockquote><p>作者：AC_OIer<br>链接：<a href="https://leetcode-cn.com/problems/range-sum-query-mutable/solution/guan-yu-ge-lei-qu-jian-he-wen-ti-ru-he-x-41hv/">https://leetcode-cn.com/problems/range-sum-query-mutable/solution/guan-yu-ge-lei-qu-jian-he-wen-ti-ru-he-x-41hv/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows相关软件</title>
      <link href="/2022/04/04/Windows%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6-windows-software/"/>
      <url>/2022/04/04/Windows%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6-windows-software/</url>
      
        <content type="html"><![CDATA[<h1>HEU KMS Activator 用于Windows激活</h1><p><strong>原文<a href="https://meledee.com/2020/12/3724.html">Link</a>，纯粹为了记录，与原文一致</strong><br>我常给自己或者亲朋好友的电脑重装系统，基于稳定性和系统运行速度等因素考量，一般都会选择安装Windows 10 Enterprise LTSC 2019。之前曾使用过国外网友s1ave77制作的Windows 10数字权利激活工具——HWIDGEN，遗憾的是该软件不支持以数字许可证永久激活LTSC 2019，仅能用KMS离线激活，让系统有效期延长到2038年。</p><blockquote><p>小知识：<br>数字许可证（在 Windows 10 版本 1511 中称为数字授权）是 Windows 10 的一种激活方法，该方法不需要输入产品密钥。激活后会自动把当前电脑硬件信息上传到微软服务器中，以后重装系统时会自动与微软服务器中存储的激活信息相比对，信息相符即自动激活该设备，免去了用户记忆和输入产品密钥的麻烦。<br>在同一台电脑上主要硬件（CPU和主板等）不变化的情况下，每次重新安装系统时无需再次输入密钥，系统会在自动连接到微软服务器进行激活。如果你在电脑登录了Microsoft帐户，那么数字许可证还会自动关联你的账户，即使你更换电脑，只要登录账户就可以激活相同版本的系统。</p></blockquote><p>那么，有没有一款能支持以数字许可证永久激活LTSC 2019，而且不捆绑恶意软件，不篡改浏览器主页或静默下载安装广告软件等不法行为的的系统激活工具？答案当然有，这款软件叫HEU KMS Activator！HEU KMS Activator的优势在于纯粹的本地搭建服务器几乎无需联网，同时不含有任何广告或后门程序不篡改系统设置等。该工具原理主要是在本地搭建KMS服务器通过GVLK密钥激活。<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/windows/1649071057800-418776ec-22e9-4fe9-8a6d-774a49de3898.png" alt="image.png"><br>这款激活软件之前颇有名气，其作者“知彼而知己”近期已更新到v20版本，这次更新采用了全新的UI设计，告别繁琐的操作，主页面的“橘黄色按钮”为智能激活按钮，将根据当前的Windows系统和Office，智能判断最佳的激活方式。诸如以下的问题，根本无需担心，只需一键按照激活按钮，HEU KMS Activator将自动提供最佳的解决方案——<br><em>已永久激活的Windows或Office会不会破坏？</em><br><em>安装了多个版本的Office怎么激活？</em><br><em>Retail版Office会不会转化成VL版</em><br><em>会不会数字权利激活？</em><br><em>Windows7能不能激活？</em><br><em>怎么安装KMS的自动续期功能？</em><br><em>…</em><br>HEU KMS Activator支持激活<strong>Windows Vista/7/8/10/Server 2008/2008R2</strong>等微软系统，<strong>新增Windows 10 LTSC 2019数字激活</strong>。另外，也支持激活批量授权<strong>Office 2019及以下版本</strong>。</p><hr><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/windows/1649071057818-df2a8857-5ec9-4e0b-ac4d-5871d866c2e7.png" alt="image.png"><br>亲测使用HEU KMS Activator，以数字许可证方式成功永久激活LTSC 2019</p><hr><h2 id="HEU-KMS-Activator-当前最新版本下载："><strong>HEU KMS Activator 当前最新版本下载：</strong></h2><p><a href="https://url01.ctfile.com/f/12669301-537630116-a4c518">HEU KMS Activator最新版本下载地址</a>** （访问密码：2278）**<br><strong>文件: HEU_KMS_Activator_v24.6.1.exe</strong><br><strong>SHA1: 6375D61442698AA57FFD56DA26CE09661504AC8C</strong><br>本次更新，修复了一些已知的Bug。全面支持Office 2021以及Windows Server 2022和Win10 IoT Enterprise 2021 LTSC。并且如果Microsoft 365已订阅激活，则自动跳过。<br><strong><em>[2022.01.17] v24.6.1 更新说明：</em></strong><br>1.修复ARM64架构下激活失败的Bug。<br>2.修复Office UWP激活后仍有盗版提示的弹窗。</p><hr><p>根据2013年1月30日《计算机软件保护条例》的第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬。正版与盗版这两个说法为法律上的概念，凡是没有取得官方授权的均都属于盗版。本软件作为激活原理研究、交流使用，不得用于商业用途，且下载后请在24小时内删除。如需要使用Windows/Office等，请前往正规渠道，购买微软官方正版软件。<br>由于软件的特殊性，经常会被一些杀毒软件误报，本软件保证绝对纯净。使用前请检验软件SHA1值(见更新日志)，准确无误后请放心使用。使用HEU KMS Activator进行激活后和正版的功能没有任何区别。根据网友的建议和反馈进行不定期更新。</p>]]></content>
      
      
      <categories>
          
          <category> 软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(leetcode) 三日三题</title>
      <link href="/2022/03/30/leetcode%20%E4%B8%89%E6%97%A5%E4%B8%89%E9%A2%98-leetcodethree-day-three-code/"/>
      <url>/2022/03/30/leetcode%20%E4%B8%89%E6%97%A5%E4%B8%89%E9%A2%98-leetcodethree-day-three-code/</url>
      
        <content type="html"><![CDATA[<h2 id="找出缺失的观测数据"><a href="https://leetcode-cn.com/problems/find-missing-observations/">找出缺失的观测数据</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我的题解</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">missingRolls</span>(<span class="params">rolls, mean, n</span>):</span><br><span class="line">    loss_sum = mean * (n + <span class="built_in">len</span>(rolls)) - <span class="built_in">sum</span>(rolls)</span><br><span class="line">    loss_l = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> n &lt;= loss_sum &lt;= <span class="number">6</span>*n:</span><br><span class="line">        <span class="keyword">return</span> loss_l</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># 没找出规律，瞎猫碰上死耗子</span></span><br><span class="line">        num = loss_sum // n</span><br><span class="line">        loss_l.append(num)</span><br><span class="line">        loss_sum -= num</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> loss_l</span><br><span class="line"><span class="comment"># 官方题解</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">missingRolls</span>(<span class="params">rolls, mean, n</span>):</span><br><span class="line">    missingSum = mean * (n + <span class="built_in">len</span>(rolls)) - <span class="built_in">sum</span>(rolls)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> n &lt;= missingSum &lt;= n * <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="comment"># divmod(x, y) return the tuple (x//y, x%y)</span></span><br><span class="line">    quotient, remainder = <span class="built_in">divmod</span>(missingSum, n) </span><br><span class="line">    <span class="keyword">return</span> [quotient + <span class="number">1</span>] * remainder + [quotient] * (n - remainder)</span><br><span class="line"><span class="comment"># 作者：himymBen</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">missingRolls</span>(<span class="params">rolls: <span class="type">List</span>[<span class="built_in">int</span>], mean: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> [s // n + <span class="number">1</span>] * (s % n) + [s // n] * (n - s % n) </span><br><span class="line">                <span class="keyword">if</span> n &lt;= (s := mean * (<span class="built_in">len</span>(rolls) + n) - <span class="built_in">sum</span>(rolls)) &lt;= <span class="number">6</span> * n <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure><h2 id="交替位二进制数"><a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/">交替位二进制数</a></h2><p>原本以为超时，没想到直接ac了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hasAlternatingBits</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        sam = n % <span class="number">2</span></span><br><span class="line">        n //= <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> sam == n %<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="comment"># 打表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hasAlternatingBits</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> n <span class="keyword">in</span> &#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">21</span>, <span class="number">42</span>, <span class="number">85</span>, <span class="number">170</span>, <span class="number">341</span>, <span class="number">682</span>, <span class="number">1365</span>, <span class="number">2730</span>, <span class="number">5461</span>, <span class="number">10922</span>,</span><br><span class="line">        <span class="number">21845</span>, <span class="number">43690</span>, <span class="number">87381</span>, <span class="number">174762</span>, <span class="number">349525</span>, <span class="number">699050</span>, <span class="number">1398101</span>, <span class="number">2796202</span>, <span class="number">5592405</span>,</span><br><span class="line">        <span class="number">11184810</span>, <span class="number">22369621</span>, <span class="number">44739242</span>, <span class="number">89478485</span>, <span class="number">178956970</span>, <span class="number">357913941</span>, <span class="number">715827882</span>,</span><br><span class="line">        <span class="number">1431655765</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment"># 异或</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hasAlternatingBits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    a = n ^ (n &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> a &amp; (a + <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line"><span class="comment"># https://leetcode-cn.com/problems/binary-number-with-alternating-bits/comments/35738</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"> 分析：</span></span><br><span class="line"><span class="string"> 如果n是交替的01，对于它右移一位后得到的m，</span></span><br><span class="line"><span class="string"> 存在n跟m在二进制下必然是0和1对应的（对位）。异或运算必定都是1；</span></span><br><span class="line"><span class="string"> 举个栗子：5=101 5&gt;&gt;1=10,5^(5&gt;&gt;1)=111 (这是伪代码)</span></span><br><span class="line"><span class="string">  101</span></span><br><span class="line"><span class="string">   10  =111</span></span><br><span class="line"><span class="string"> 其他情况都不会满足这个特征。所以temp=n^(n&gt;&gt;1)必定满足temp=2^N-1=2^3-1=7;</span></span><br><span class="line"><span class="string"> 而temp+1后是N+1位二进制数2^(N+1)=8=1000。</span></span><br><span class="line"><span class="string"> 所以temp&amp;(temp+1)==0；</span></span><br><span class="line"><span class="string"> 如果满足这个等式就是就是交替位二进制数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># python内置函数 bin()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hasAlternatingBits</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> (<span class="string">&#x27;11&#x27;</span> <span class="keyword">in</span> <span class="built_in">bin</span>(n) <span class="keyword">or</span> <span class="string">&#x27;00&#x27;</span> <span class="keyword">in</span> <span class="built_in">bin</span>(n))</span><br></pre></td></tr></table></figure><h2 id="考试的最大困扰度"><a href="https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam/">考试的最大困扰度</a></h2><p>思路：<a href="https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam/solution/-by-mochi-ds-onfv/">Link</a><br>滑动窗口思想：监视k窗口内的值，如果二者数量都超过k，表示无论修改哪个值都必定不满足条件，且当前连续串长度是最后一次不超过k的长度，且最大窗口是连续串的长度，当最大窗口确定下来后，因为不满足，所以根据这个最大窗口进行左移比较是否窗口内有新的值可以满足。<br>视频解析：<a href="https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam/solution/shua-ti-ka-pei-guan-hua-dong-chuang-kou-te8b0/">Link</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 动态规划</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maxConsecutiveAnswers</span>(<span class="params">self, answerKey, k</span>):</span><br><span class="line">    f1, f2 = [], []</span><br><span class="line">    ans1, ans2, cnt1, cnt2 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(answerKey)):</span><br><span class="line">        <span class="keyword">if</span> answerKey[i] == <span class="string">&#x27;T&#x27;</span>:</span><br><span class="line">            f1.append(i)  <span class="comment"># 记录&#x27;T&#x27;的位置</span></span><br><span class="line">            cnt1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            f2.append(i)  <span class="comment"># 记录&#x27;F&#x27;的位置</span></span><br><span class="line">            cnt2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> cnt1 &lt;= k:</span><br><span class="line">            ans1 = i + <span class="number">1</span>  <span class="comment"># 从左到右前i+1个值，因为修改了k个使其全部相等</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># cnt1+1后走这条路</span></span><br><span class="line">            ans1 = <span class="built_in">max</span>(ans1, i-f1[cnt1-k-<span class="number">1</span>])  <span class="comment"># cnt1-k-1使f从最左边开始</span></span><br><span class="line">        <span class="keyword">if</span> cnt2 &lt;= k:</span><br><span class="line">            ans2 = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans2 = <span class="built_in">max</span>(ans2, i-f2[cnt2-k-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(ans1, ans2)</span><br><span class="line"><span class="comment"># 滑动窗口优化版</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maxConsecutiveAnswers</span>(<span class="params">self, answerKey, k</span>):</span><br><span class="line">    ans, cnt, left = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(answerKey)):</span><br><span class="line">        <span class="keyword">if</span> answerKey[i] == <span class="string">&#x27;T&#x27;</span>:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> cnt &gt; k <span class="keyword">and</span> i - left - cnt + <span class="number">1</span> &gt; k:  <span class="comment"># F的cnt由i-left-cnt+1可得</span></span><br><span class="line">                                                <span class="comment"># 右标-左标-&#x27;T&#x27;的cnt+&#x27;F&#x27;本身</span></span><br><span class="line">            <span class="keyword">if</span> answerKey[left] == <span class="string">&#x27;T&#x27;</span>:</span><br><span class="line">                cnt -= <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        ans = i - left + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"><span class="comment"># 记录用，函数嵌套递归</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maxConsecutiveAnswers</span>(<span class="params">self, answerKey: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxConsecutiveChar</span>(<span class="params">ch: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans, left, <span class="built_in">sum</span> = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(answerKey)):</span><br><span class="line">            <span class="built_in">sum</span> += answerKey[right] != ch</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">sum</span> &gt; k:</span><br><span class="line">                <span class="built_in">sum</span> -= answerKey[left] != ch</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, right - left + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(maxConsecutiveChar(<span class="string">&#x27;T&#x27;</span>), maxConsecutiveChar(<span class="string">&#x27;F&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(leetcode) 三日三题</title>
      <link href="/2022/03/26/leetcode%E4%B8%89%E6%97%A5%E4%B8%89%E9%A2%98-leetcode-one-question-per-day/"/>
      <url>/2022/03/26/leetcode%E4%B8%89%E6%97%A5%E4%B8%89%E9%A2%98-leetcode-one-question-per-day/</url>
      
        <content type="html"><![CDATA[<p>作为第一篇力扣每日一题，要好好坚持，广大网友给我监督！！</p><h2 id="图片平滑器"><a href="https://leetcode-cn.com/problems/image-smoother/">图片平滑器</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 速度有点拉跨</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">imageSmoother</span>(<span class="params">self, img</span>):</span><br><span class="line">    <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">    <span class="keyword">import</span> copy</span><br><span class="line">    <span class="comment"># 利用pad填充原矩阵，并且防止原矩阵有0，故填充-1</span></span><br><span class="line">    padList = np.pad(img, ((<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">1</span>)), <span class="string">&#x27;constant&#x27;</span>, constant_values=-<span class="number">1</span>)  </span><br><span class="line">    <span class="comment"># 不用深拷贝会报错</span></span><br><span class="line">    <span class="comment"># https://leetcode-cn.com/problems/image-smoother/comments/1461270</span></span><br><span class="line">    newImg = copy.deepcopy(img) </span><br><span class="line">    <span class="comment"># 获取img的行列</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(img), <span class="built_in">len</span>(img[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 深拷贝，防止后续修改padList</span></span><br><span class="line">            zeroList = copy.deepcopy(padList[i: i + <span class="number">3</span>, j:j + <span class="number">3</span>])</span><br><span class="line">            <span class="comment"># 计算9个元素中哪些元素是原数组，即非 -1 就是原元素</span></span><br><span class="line">            count = <span class="number">9</span> - np.<span class="built_in">sum</span>(zeroList == -<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 遮罩层，重新置为0方便sum求和</span></span><br><span class="line">            <span class="comment"># 或者得到-1的个数重新加回去，减小内存开销</span></span><br><span class="line">            mask = (zeroList == -<span class="number">1</span>)</span><br><span class="line">            zeroList[mask] = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 计算值</span></span><br><span class="line">            newImg[i][j] = np.<span class="built_in">sum</span>(zeroList) // count</span><br><span class="line">            <span class="keyword">return</span> newImg</span><br><span class="line"><span class="comment"># 修改版</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">imageSmoother</span>(<span class="params">self, img</span>):</span><br><span class="line">    <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">    padList = np.pad(img, ((<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">1</span>)), <span class="string">&#x27;constant&#x27;</span>, constant_values=-<span class="number">1</span>)</span><br><span class="line">    newImg = img</span><br><span class="line">    m, n = <span class="built_in">len</span>(img), <span class="built_in">len</span>(img[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            zeroList = padList[i: i + <span class="number">3</span>, j:j + <span class="number">3</span>]</span><br><span class="line">            count = np.<span class="built_in">sum</span>(zeroList &gt; -<span class="number">1</span>)</span><br><span class="line">            mask = (zeroList &gt; -<span class="number">1</span>)</span><br><span class="line">            newImg[i][j] = np.<span class="built_in">sum</span>(zeroList[mask])//count</span><br><span class="line">    <span class="keyword">return</span> newImg</span><br></pre></td></tr></table></figure><h3 id="大佬题解">大佬题解</h3><p><a href="https://leetcode-cn.com/problems/image-smoother/solution/100-zhao-dao-shang-xia-xian-yu-zuo-you-xian-by-ooo/">Link</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">m, n = <span class="built_in">len</span>(img), <span class="built_in">len</span>(img[<span class="number">0</span>])</span><br><span class="line">newImg = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(m * n):</span><br><span class="line">    <span class="comment"># 除以n非m</span></span><br><span class="line">    cur_r = idx // n  <span class="comment"># r行</span></span><br><span class="line">    cur_c = idx % n  <span class="comment"># c列</span></span><br><span class="line">    x1, y1 = cur_r, cur_c</span><br><span class="line">    x2, y2 = cur_r, cur_c</span><br><span class="line">    sum1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> cur_r - <span class="number">1</span> &gt;= <span class="number">0</span>:  <span class="comment"># 上限 (-1, 0)    往上走不行</span></span><br><span class="line">        x1 = cur_r - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> cur_r + <span class="number">1</span> &lt; m:  <span class="comment"># 下限 (m+1, 0)   往下走不行</span></span><br><span class="line">        x2 = cur_r + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> cur_c - <span class="number">1</span> &gt;= <span class="number">0</span>:  <span class="comment"># 左限 (0, -1)    往左走不行</span></span><br><span class="line">        y1 = cur_c - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> cur_c + <span class="number">1</span> &lt; n:  <span class="comment"># 右限 (0, n+1)   往右走不行</span></span><br><span class="line">        y2 = cur_c + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x1, x2 + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(y1, y2 + <span class="number">1</span>):</span><br><span class="line">            sum1 += img[i][j]</span><br><span class="line">    count = (y2 - y1 + <span class="number">1</span>) * (x2 - x1 + <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(sum1)</span><br><span class="line">    newImg[cur_r][cur_c] = sum1 // count</span><br><span class="line"><span class="keyword">return</span> newImg</span><br></pre></td></tr></table></figure><h3 id="python性能好版">python性能好版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list版 占13.9mb</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">imageSmoother</span>(<span class="params">self, img</span>):</span><br><span class="line">    res = []</span><br><span class="line">    l1, l2 = <span class="built_in">len</span>(img), <span class="built_in">len</span>(img[<span class="number">0</span>])</span><br><span class="line">    expand = np.pad(img, ((<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">1</span>)), <span class="string">&#x27;constant&#x27;</span>, constant_values=-<span class="number">1</span>)</span><br><span class="line">    expand = expand.tolist()</span><br><span class="line">    res = [[<span class="number">0</span>] * l2 <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(l1)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l1):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(l2):</span><br><span class="line">            nine = [expand[i][j], expand[i][j + <span class="number">1</span>], expand[i][j + <span class="number">2</span>], expand[i + <span class="number">1</span>][j], expand[i + <span class="number">1</span>][j + <span class="number">1</span>],</span><br><span class="line">                    expand[i + <span class="number">1</span>][j + <span class="number">2</span>], expand[i + <span class="number">2</span>][j], expand[i + <span class="number">2</span>][j + <span class="number">1</span>], expand[i + <span class="number">2</span>][j + <span class="number">2</span>]]</span><br><span class="line">            num = nine.count(-<span class="number">1</span>)</span><br><span class="line">            res[i][j] = (<span class="built_in">sum</span>(nine) + num) // (<span class="number">9</span> - num)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># numpy版 占25.3mb</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">imageSmoother</span>(<span class="params">self, img</span>):</span><br><span class="line">    <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">    l1, l2 = <span class="built_in">len</span>(img), <span class="built_in">len</span>(img[<span class="number">0</span>])</span><br><span class="line">    expand = np.pad(img, ((<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">1</span>)), <span class="string">&#x27;constant&#x27;</span>, constant_values=-<span class="number">1</span>)</span><br><span class="line">    expand = expand.tolist()</span><br><span class="line">    res = [[<span class="number">0</span>] * l2 <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(l1)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l1):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(l2):</span><br><span class="line">            nine = [expand[i][j], expand[i][j + <span class="number">1</span>], expand[i][j + <span class="number">2</span>], expand[i + <span class="number">1</span>][j], expand[i + <span class="number">1</span>][j + <span class="number">1</span>],</span><br><span class="line">                    expand[i + <span class="number">1</span>][j + <span class="number">2</span>], expand[i + <span class="number">2</span>][j], expand[i + <span class="number">2</span>][j + <span class="number">1</span>], expand[i + <span class="number">2</span>][j + <span class="number">2</span>]]</span><br><span class="line">            num = nine.count(-<span class="number">1</span>)</span><br><span class="line">            res[i][j] = (<span class="built_in">sum</span>(nine) + num) // (<span class="number">9</span> - num)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>numpy操作可能比list操作占内存大</li><li>注意python的浅拷贝！！</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] </span><br><span class="line">copyImg = img</span><br><span class="line">copyImg[<span class="number">0</span>] = <span class="number">2</span> <span class="comment"># 则img也同步修改</span></span><br><span class="line"><span class="comment"># 新建一个m*n列表</span></span><br><span class="line">newImg = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br></pre></td></tr></table></figure><p>回顾一遍</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">4 6 6 4</span></span><br><span class="line"><span class="string">6 9 9 6 </span></span><br><span class="line"><span class="string">6 9 9 6 </span></span><br><span class="line"><span class="string">4 6 6 4</span></span><br><span class="line"><span class="string">考虑46的情况可知x1y1,x2y2的坐标</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tryImageAgain</span>(<span class="params">img</span>):</span><br><span class="line">    m = <span class="built_in">len</span>(img)</span><br><span class="line">    n = <span class="built_in">len</span>(img[<span class="number">0</span>])</span><br><span class="line">    ans = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            x1, x2 = i, i</span><br><span class="line">            y1, y2 = j, j</span><br><span class="line">            <span class="comment"># 计算满足条件的x1y1x2y2的值</span></span><br><span class="line">            <span class="comment"># 如果计算违反条件的值，需要考虑的变量多</span></span><br><span class="line">            <span class="comment"># 如i-1&lt;0时，表明当前在第一行，如果是[0][0]需要修改x2y2，如果是[0][1]需要修改x1y1x2y2，</span></span><br><span class="line">            <span class="comment"># 如果在左上角，则x1y1不用变，考虑后两个if</span></span><br><span class="line">            <span class="keyword">if</span> i-<span class="number">1</span> &gt;= <span class="number">0</span>: x1 = i-<span class="number">1</span>  <span class="comment"># 如果[i][j]在第一行之后行，则左上标为[i-1][j]</span></span><br><span class="line">            <span class="keyword">if</span> j-<span class="number">1</span> &gt;= <span class="number">0</span>: y1 = j-<span class="number">1</span>  <span class="comment"># 如果[i][j]在第一列之后列，则左上标为[i][j-1] 在第二行第二列则[i-1][j-1]</span></span><br><span class="line">            <span class="comment"># 如果在右下角，则x2y2不用变，考虑前两个if</span></span><br><span class="line">            <span class="keyword">if</span> i+<span class="number">1</span> &lt; m: x2 = i+<span class="number">1</span>  <span class="comment"># 如果[i][j]在第m行之前行，则右下标为[i+1][j]</span></span><br><span class="line">            <span class="keyword">if</span> j+<span class="number">1</span> &lt; n: y2 = j+<span class="number">1</span>  <span class="comment"># 如果[i][j]在第n列之前列，则右下标为[i][j+1]</span></span><br><span class="line">            <span class="comment"># 妙啊</span></span><br><span class="line">            s = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(x1, x2+<span class="number">1</span>):</span><br><span class="line">                s += <span class="built_in">sum</span>(img[x][y1:y2+<span class="number">1</span>])</span><br><span class="line">            div = (y2-y1+<span class="number">1</span>)*(x2-x1+<span class="number">1</span>)</span><br><span class="line">            ans[i][j] = s // div</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="阶乘后的零"><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/">阶乘后的零</a></h2><p>本质就是求质因数，考数学题，<s>太难了</s><br>n! = 1 * 2 * 3 * 4 * (1 * 5) * … * (2 * 5) * … * (3 * 5) *… * n<br>因为<strong>每隔 5 个数出现一个 5，所以计算n!中出现了多少个 5，我们只需要用 n/5 就可以算出来</strong>。即n=5，1；n=10，2.<br>n! = … * (1 * 5) * … * (1 * 5 * 5) * … * (2 * 5 * 5) * … * (3 * 5 * 5) * … * n<br>每隔 25 个数字，出现的是两个 5，所以除了每隔 5 个数算作一个 5，每隔 25 个数，还需要多算一个 5。<br>也就是我们需要再加上 n / 25 个 5。<br>同理我们还会发现每隔 5 * 5 * 5 = 125 个数字，会出现 3 个 5，所以我们还需要再加上 n / 125 。<br>最后，规律就是**每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5… 以此类推。**即 n / 5 + n / 25 + n / 125 …<br>又因为呈现递进关系，每次 ÷5 更新n的值，使其一直处于n/5的状态。<br><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/jie-cheng-hou-de-ling-by-leetcode-soluti-1egk/1462453">例子</a>：<br>第一次：5，10，15，…，130，至少包含1个5的数为26个<br>第二次：25，50，75，100，125，至少包含2个5的数有这5个<br>第三次：125，它至少包含3个5（其实也只包含3个5）<br>思路：<a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/xiang-xi-tong-su-de-si-lu-fen-xi-by-windliang-3/">Link</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">trailingZeroes</span>(<span class="params">n</span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    p = <span class="number">5</span>  <span class="comment"># 用p代替5，即可以推广到n!中p因子的个数</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        <span class="comment"># p += n/5  # 直观解法</span></span><br><span class="line">        <span class="comment"># n/=5  # 使其维持n/p的格式，求n!中只含一个p的个数</span></span><br><span class="line">                <span class="comment"># 否则需要计算n/p+n/2*p+n/3*p...</span></span><br><span class="line">        n //= p </span><br><span class="line">        count += n  </span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归解法，来自力扣宫水三叶</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trailingZeroes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> n // <span class="number">5</span> + self.trailingZeroes(n // <span class="number">5</span>) <span class="keyword">if</span> n <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 官解朴素版</span></span><br><span class="line"><span class="comment"># n!中质因子 5 的个数等于 [1,n] 的每个数的质因子 5 的个数之和，</span></span><br><span class="line"><span class="comment"># 我们可以通过遍历 [1,n] 的所有 5 的倍数求出。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trailingZeroes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>, n + <span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">        <span class="keyword">while</span> i % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">            i //= <span class="number">5</span></span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="棒球比赛"><a href="https://leetcode-cn.com/problems/baseball-game/">棒球比赛</a></h2><p>唯一注意的点就是python一些语法，如<code>del 列表元素</code>、<code>sum(列表)</code>、match case只在python3.10支持即switch case、将字符串转整形</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calPoints</span>(<span class="params">ops</span>):</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> ops[i] == <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            <span class="keyword">del</span> ops[i-<span class="number">1</span>:i+<span class="number">1</span>]</span><br><span class="line">            i -= <span class="number">2</span></span><br><span class="line">        <span class="keyword">elif</span> ops[i] == <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            ops[i] = <span class="built_in">int</span>(ops[i-<span class="number">1</span>]) * <span class="number">2</span></span><br><span class="line">        <span class="keyword">elif</span> ops[i] == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            ops[i] = <span class="built_in">int</span>(ops[i - <span class="number">1</span>]) + <span class="built_in">int</span>(ops[i - <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ops[i] = <span class="built_in">int</span>(ops[i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(ops):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(ops)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Halo博客搭建---一个属于自己的网站</title>
      <link href="/2022/03/19/Halo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA---%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%AB%99-halo-blog-build-a-website-of-your-own/"/>
      <url>/2022/03/19/Halo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA---%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%AB%99-halo-blog-build-a-website-of-your-own/</url>
      
        <content type="html"><![CDATA[<p>概要：本博客使用Halo搭建，域名通过name.com进行购买，使用cloudflare进行cdn代理，服务器是阿里云的，对象存储用的是腾讯云的按量付费50g。</p><h2 id="购买域名">购买域名</h2><p>首先，当然是买个域名啦，可以选择国内网址，但是要备案，好处就是国内比较便宜，备案也较为轻松，也可以选国外网址，不需要备案，而且更加随心所欲一点。</p><h3 id="域名网址">域名网址</h3><p>我这里用的是name.com买的网址。这是我的<a href="https://www.name.com/zh-cn/referral/4777a0">分享链接</a>，（购买会便宜36，当然我也有点小利润）</p><ol><li>先输入你心仪的域名，<a href="http://xn--keepjolly-k99p.com">如keepjolly.com</a>，他就会告诉你这个域名是否被购买，以及其他后缀的域名。.com后缀会稍微贵一些，其他域名会便宜点</li></ol><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/halo/1647478544371-b15bcc98-d75f-4518-b060-81b0e49a4489.png" alt="image.png"></p><ol start="2"><li>点击加入购物车，然后点上面的购物车图标，（<s>如果点击结账，就会跳转到下面的界面，然后点击购物车）</s></li></ol><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/halo/1647478668852-d7030955-903f-4fec-a4d2-1acbe13a5cf2.png" alt="image.png"><br>这是点击结账的页面。<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/halo/1647478849173-0d1cebce-d2f6-4012-8b9e-d85a3dd64842.png" alt="image.png"></p><ol start="3"><li>选择你要购买几年，如果有信心运营下去的话，建议多买几年，首先买一年试试水吧</li></ol><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/halo/1647479212000-92c67d24-48fe-420a-a3ef-fabb6bf6785b.png" alt="image.png"><br>促销码可以Google一下，我当初便宜了一年的Advanced Security + Privacy</p><blockquote><p><a href="https://www.pigji.com/970.html"><strong>促销码</strong></a>**：**PRIVACYPLEASE 减去那个附加项、RENEW 续费便宜15%<br>联合使用的话，先renew，然后在域名管理页再续费privacy，（目前还没试过）</p></blockquote><p>然后就可以付款了。</p><ol start="5"><li>付款可以选择支付宝，然后就不截图了。</li></ol><ul><li>买后之后（因为我是买后再写博文，所以没有买后的跳转页面，我这里直接放上域名管理页面）</li></ul><ol start="6"><li>这是域名管理页面，一般都是自动勾选上的，自动续订需要绑信用卡，下面的域名服务器等下要替换成cloudflare。</li></ol><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/halo/1647479816157-6c619eb3-6ac5-481d-9b20-01e8008d90c0.png" alt="image.png"></p><ol start="8"><li>域名购买就到这里结束了</li></ol><h2 id="给域名套上cdn">给域名套上cdn</h2><p>因为我的是国外域名，所以弄了个国外的cdn，如果是在国内购买域名，建议选国内的cdn（另外也有可能买服务器或者域名会送cdn服务）。（另外有大佬也说，套国外的cdn对国内会影响访问速度，而且也不需要ddos防御，毕竟小网站，但最后反正也免费，索性就配置一下）。</p><h3 id="注册cloudflare">注册cloudflare</h3><p>这里就不说了，这都不会建议别套cdn了😂。这个cdn网站还有中文</p><h3 id="添加要加速的网站">添加要加速的网站</h3><p>就是添加站点把你的网址输入进去即可。<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/halo/1647678898220-72a625f4-fe2e-4b61-8283-7aa7a529a922.png" alt="image.png"><br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/halo/1647678926632-fc7efa34-73c8-4b13-a493-44fb7d8d9f5b.png" alt="image.png"></p><h3 id="选择付费计划">选择付费计划</h3><p>白嫖怪当然选择免费计划啦，主要就是防止ddos攻击。<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/halo/1647678991846-3de9b528-b0d0-442d-8baf-56bbf709784a.png" alt="image.png"><br>如果是国外的域名购买网站如<strong>namesilo</strong>、<strong>godaddy</strong>，<a href="https://zhuanlan.zhihu.com/p/82909515">Link here</a><br>这里展示一下name、和阿里云的。</p><h3 id="查看dns记录">查看dns记录</h3><p>建议也用上面那个<a href="https://zhuanlan.zhihu.com/p/82909515">链接</a>，这里我因为点了返回，直接进入下一步了。</p><h3 id="完成名称服务器设置">完成名称服务器设置</h3><p>复制cloudflare的名称服务器，一共两条<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/halo/1647679682736-dcf7e621-ad70-43a8-836e-8cd77d8ca9a1.png" alt="image.png"></p><h4 id="name-com"><a href="http://name.com">name.com</a></h4><p>选择最下面的管理域名服务器</p><h3 id=""><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/halo/1647479816157-6c619eb3-6ac5-481d-9b20-01e8008d90c0.png" alt=""></h3><p>添加刚刚复制的那两条，添加完成后，cloudflare就能托管你的网站了<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/halo/1647679555669-05837aa9-f21d-47ba-a048-37bca41fe6d0.png" alt="image.png"></p><h4 id="aliyun-com"><a href="http://aliyun.com">aliyun.com</a></h4><p>首先当然是登录啦，登陆成功后点击第一步的“我的阿里云”。然后如果你买了域名的话，在第二步应该能看见你的域名“控制台”，点进去。<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/halo/1647679994486-135aa6df-07e6-4841-9378-34045cbe627b.png" alt="image.png"><br>然后在域名列表里，点击你的网址，（国内记得备案哦，备案就不介绍了，网上查一查吧）<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/halo/1647680196991-8e454160-3098-49af-a2ee-7442090604e3.png" alt="image.png"><br>点击“修改DNS”<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/halo/1647680333113-1d31d213-4aa2-4363-8e2f-d756437c988c.png" alt="image.png"><br>复制cloudflare 的名称服务器，cv就完事了<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/halo/1647680378484-860a8dab-4a40-4ce6-8175-afe678410d40.png" alt="image.png"></p><h3 id="cloudflare快速入门指南">cloudflare快速入门指南</h3><p><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/halo/1647681427107-a50d0a29-5875-4f05-9321-7a11301cc24c.png" alt="image.png"><br>全选是就行了，最后就是这样子。<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/halo/1647681454195-05f18d32-f98b-4ec7-bf7e-f8f8a0c677f8.png" alt="image.png"></p><h3 id="其他设置">其他设置</h3><p>参考上面的<a href="https://zhuanlan.zhihu.com/p/82909515">link</a>（快速入门指南以及包括了大部分了）。另外，如果需要进行端到端加密的话，<a href="https://developers.cloudflare.com/ssl/get-started/">官网</a>是这样子介绍的，我因为有段时间没弄这篇博客，有点忘记怎么弄了。这里就给个<a href="https://www.keepjolly.com/archives/openssl-install-and-get-sslcert">本机生成SSL证书</a>，（好像大概率用的是宝塔自动产生的SSL证书），但是具体怎么套入，<em>看看官网，或者我帮你试试</em>。另外自己的域名购买网站记得加上SSL证书，这里也不说了，应该把本机生成的放进去就好了，或者宝塔里的，（时间有点久，不知道怎么操作了，抱歉）。另外看到阿里云有付费的SSL证书，Google后，其实免费的对于个人博客来说就够了。</p><h4 id="阿里云的SSL证书签发">阿里云的SSL证书签发</h4><p>点击开启SSL证书<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/halo/1647689548378-792215e1-893a-4eba-b633-1d4509323520.png" alt="image.png"><br>买免费的就行了<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/halo/1647689583445-23346d75-42af-43ec-bfbb-98cabf4b4724.png" alt="image.png"><br>点证书申请，然后输入你的域名，然后下一步<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/halo/1647689690408-355ef6bb-c990-4560-9eec-370a866a25cf.png" alt="image.png"><br>然后在cloudflare的DNS记录里新建txt，对应cv就行了。<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/halo/1647689819411-a415d0f3-17d4-4b0d-8832-f2dccfd9380a.png" alt="image.png"></p><h2 id="购买服务器">购买服务器</h2><p>这里选的是<a href="https://www.aliyun.com/daily-act/ecs/activity_selection?userCode=d2oiabj6">阿里云</a>的，如果需要国外的，点更多商品。下面的点开后，我选的是ECS突发性能型 t6 - 新加坡，下面是我的配置，因为没有新用户，很贵。<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/halo/1647690726368-f4597509-3045-434b-bd9a-b55fc7df890e.png" alt="image.png"></p><h2 id="搭建博客">搭建博客</h2><p>这里推荐一个up，<a href="https://www.bilibili.com/video/BV1JN411Q7Na?p=4">BV1JN411Q7Na</a>（<a href="https://www.wjcms.net/archives/%E4%BB%8E%E9%9B%B6%E7%BA%BF%E4%B8%8A%E9%83%A8%E7%BD%B2halo%E5%8D%9A%E5%AE%A2%E5%8C%85%E5%90%ABhalo%E5%8D%9A%E5%AE%A2%E8%AE%BE%E7%BD%AE%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE">文字版</a>建议两者结合），我时隔已久，而且已经是装完的状态了，所以无法展示了。按照他的来可以搭建出来Halo的博客，但后来我记得部署完halo后，halo页面无法显示，可能按照清缓存，重启服务器，等待一会儿就行了。<br>啊啊啊，原本想从0开始搭建出自己的博客来着，属于是推着推着就忘了好多。如果有需要，我可以帮你尝试一下建博客（不保证行不行，因为我也是看网上教程来的）。</p><h2 id="对象存储">对象存储</h2><p>国外买国外的存储桶，记得开防盗链，然后用<a href="https://github.com/PicGo/PicGo-Core">picgo</a>管理，插件是<a href="https://github.com/PicGo/picgo-plugin-pic-migrater/blob/master/README_CN.md">picgo-plugin-pic-migrater</a>它可以将语雀导出的markdown里的图片自动上传到存储桶，并新建一个.md文件，如果导入图片不显示，可能是你的链接没有https://。</p><h2 id="博客主题">博客主题</h2><p><a href="https://qinhua.github.io/halo-theme-joe2.0/#/">joe2.0</a></p><h2 id="搜索引擎检索">搜索引擎检索</h2><p>这里只在<a href="https://www.bing.com/webmasters/home">必应</a>（可以直接从你的Google里导入，但还是得把你网站地图放进去<a href="https://www.xn--6qqv7i2xdt95b/sitemap.xml">https://www.你的域名/sitemap.xml</a> ）、<a href="https://search.google.com/">Google</a>、<a href="https://ziyuan.baidu.com/dashboard">百度</a>上弄了，<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo%2Fblog%2Fhalo%2Fgoogle-search.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷歌浏览器无法播放音乐</title>
      <link href="/2022/03/16/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE%E9%9F%B3%E4%B9%90-gu-ge-liu-lan-qi-wu-fa-bo-fang-yin-le/"/>
      <url>/2022/03/16/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE%E9%9F%B3%E4%B9%90-gu-ge-liu-lan-qi-wu-fa-bo-fang-yin-le/</url>
      
        <content type="html"><![CDATA[<p>如题，最近遇到b站的音频播放页不能播放音乐，一些音乐组件也不能播放，如Aplayer，然后发现谷歌浏览器加载了一个扩展程序 Disable HTML5 Autoplay，通过设置成特定模式解决了。不要用全局模式，否则容易出问题。<br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo/blog/cannot-music.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 问题集锦 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装Java(jdk)及jdk版本探讨</title>
      <link href="/2022/03/13/%E5%AE%89%E8%A3%85Java(jdk)%E5%8F%8Ajdk%E7%89%88%E6%9C%AC%E6%8E%A2%E8%AE%A8-java-install-and-version-talk/"/>
      <url>/2022/03/13/%E5%AE%89%E8%A3%85Java(jdk)%E5%8F%8Ajdk%E7%89%88%E6%9C%AC%E6%8E%A2%E8%AE%A8-java-install-and-version-talk/</url>
      
        <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000039862163">JAVA安装</a> 首推<br><a href="https://juejin.cn/post/6844903937095499789">JAVA安装</a><br>不知道你们注意到安装完java后会出现两个jre文件，特地去Google一下：<a href="https://blog.csdn.net/weixin_45948234/article/details/111474003">网址</a><br>放在jdk文件里的jre文件夹是专用jre，它是用于开发java程序用<br>而与jdk同文件夹下的jre文件是公用jre，它是为了运行操作系统中的程序。</p><table><tr><td><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo%2Fblog%2Fjava_version%2Fimage.png" width = "154" height = "86" /></td><td><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo%2Fblog%2Fjava_version%2Fimage%20(1).png" width = "154" height = "86"/></td></tr></table> 注意平时所说的“java自动更新”不是所安装的JDK版本的更新，它指的是这个公用JRE运行时环境的更新，这个更新让你的计算机能够使用最新版本正常的运行一些网站或则Web应用等等当中的java程序<hr><p>安装教程随处可见，这里重点讲一下java的版本号的区别（虽说也是能Google到，但还是留个档）<br><a href="https://www.jianshu.com/p/661dcc6e73ee">参考博客</a>1、<a href="https://www.modb.pro/db/85249">参考博客</a>2、<a href="https://candy.blog.csdn.net/article/details/110434437">参考博客</a>3</p><h2 id="1-Java与JDK的区别与关系">(1) Java与JDK的区别与关系</h2><p>Java等价于JDK。</p><h2 id="2-JDK8与JDK1-8的区别与关系">(2) JDK8与JDK1.8的区别与关系</h2><p>JDK8或者JDK1.8也是同一个东西。</p><h2 id="3-JDK与J2SE的区别与关系">(3) JDK与J2SE的区别与关系</h2><p>Java（即JDK）有3个版本：J2SE(Java Platform，Standard Edition)、J2EE(Java Platform，Enterprise Edition)、J2ME(Java Platform，Micro Edition)，所以J2SE是3个版本中的其中一个，即标准版本。</p><h2 id="4-java-jdk-XXXX-i586与jdk-XXXX-x64区别">(4) java jdk-XXXX-i586与jdk-XXXX-x64区别?</h2><p>i586是32位系统、x64是64位系统</p><h2 id="5-java-jdk-XXXX-aarch64与jdk-XXXX-x64区别-Linux">(5) java jdk-XXXX-aarch64与jdk-XXXX-x64区别?(Linux)</h2><p>x86_64就是我们常用的台式机的体系架构，是基于冯诺依曼体系架构的。x86_64 Linux可以理解为在普通台式机上安装的Linux操作系统。<br>AArch64是一种ARMv8架构，也是一种计算机的体系架构。AArch64 Linux可以理解为在ARMv8架构的计算机上安装的Linux操作系统。<br>使用$ arch可查看Linux版本 图片来自：<a href="https://candy.blog.csdn.net/article/details/110434437">网址</a><br><img src="https://halo-1310118673.cos.ap-singapore.myqcloud.com/halo%2Fblog%2Fjava_version%2Fimage%20(2).png" alt="image.png"></p><p>注意JDK8u202以下是免费的，往上就要商业付费，个人使用不需要</p><p>图片并排显示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">pic1.jpg</span> <span class="attr">border</span>=<span class="string">0</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">pic2.jpg</span> <span class="attr">border</span>=<span class="string">0</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件安装 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenSSL安装配置及配置SSL证书</title>
      <link href="/2022/03/13/OpenSSL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6-openssl-install-and-get-sslcert/"/>
      <url>/2022/03/13/OpenSSL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6-openssl-install-and-get-sslcert/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/u012502355/article/details/109746722">OpenSSL安装</a> 首推<br><a href="https://blog.aofall.com/archives/4.html">生成SSL证书</a><br><a href="https://blog.csdn.net/WeLoveSunFlower/article/details/84951818">忘了这个网站干啥用的</a><br>注意安装OpenSSL的时候 下面的代码特别慢 我大概用了半小时以上才装完</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmake</span><br><span class="line">nmake test </span><br><span class="line">nmake install</span><br></pre></td></tr></table></figure><p>nmake test 可弄可不弄</p>]]></content>
      
      
      <categories>
          
          <category> 软件安装 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>测试文章</title>
      <link href="/2022/03/12/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0-%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
      <url>/2022/03/12/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0-%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>引用区域</p></blockquote><h4 id="四级标题">四级标题</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python 使用pathlib解决同名不同后缀(扩展名)的文件的转移</title>
      <link href="/2022/03/11/python%20%E4%BD%BF%E7%94%A8pathlib%E8%A7%A3%E5%86%B3%E5%90%8C%E5%90%8D%E4%B8%8D%E5%90%8C%E5%90%8E%E7%BC%80(%E6%89%A9%E5%B1%95%E5%90%8D)%E7%9A%84%E6%96%87%E4%BB%B6%E7%9A%84%E8%BD%AC%E7%A7%BB-pythontransferfileswiththesamename/"/>
      <url>/2022/03/11/python%20%E4%BD%BF%E7%94%A8pathlib%E8%A7%A3%E5%86%B3%E5%90%8C%E5%90%8D%E4%B8%8D%E5%90%8C%E5%90%8E%E7%BC%80(%E6%89%A9%E5%B1%95%E5%90%8D)%E7%9A%84%E6%96%87%E4%BB%B6%E7%9A%84%E8%BD%AC%E7%A7%BB-pythontransferfileswiththesamename/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="comment"># 需求：将old_dir里面的json文件与pic_dir里的同名不同后缀进行复制到另一个文件夹里</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件路径</span></span><br><span class="line">old_dir = Path(<span class="string">&#x27;待复制的文件先放到一个文件夹里&#x27;</span>)  <span class="comment"># 如存放&#123;‘picture1.json’, ‘picture2.json’,...&#125;的文件夹</span></span><br><span class="line">pic_dir = Path(<span class="string">&#x27;同名不同后缀的文件夹&#x27;</span>)  <span class="comment"># 如存放&#123;‘picture1.jpg’, ‘picture2.jpg’,...&#125;的文件夹</span></span><br><span class="line">save_path = Path(<span class="string">&#x27;将同名不同后缀的文件放到新的文件夹里&#x27;</span>)  <span class="comment"># 最终的&#123;‘picture1.jpg’, ‘picture2.jpg’,...&#125;文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只剩下文件名 如&#123;‘picture1’, ‘picture2’,...&#125;   [&#x27;.jpg&#x27;]可放多个后缀[&#x27;.jpg&#x27;, &#x27;.gz&#x27;]</span></span><br><span class="line">json_names = &#123;f.stem <span class="keyword">for</span> f <span class="keyword">in</span> old_dir.iterdir() <span class="keyword">if</span> f.suffix == <span class="string">&#x27;.json&#x27;</span>&#125;</span><br><span class="line">nii_names = &#123;Path(f).name <span class="keyword">for</span> f <span class="keyword">in</span> pic_dir.iterdir() <span class="keyword">if</span> f.suffixes == [<span class="string">&#x27;.jpg&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file_name <span class="keyword">in</span> json_names &amp; nii_names:  <span class="comment"># 同名文件</span></span><br><span class="line">    <span class="comment"># json_path = old_dir / (file_name + &#x27;.json&#x27;)  # 重新拼接成picture1.json格式</span></span><br><span class="line">    <span class="comment"># nii_path = pic_dir / (file_name + &#x27;.jpg&#x27;)  # (file_name + &#x27;.jpg.gz&#x27;)</span></span><br><span class="line">    <span class="comment"># with open(json_path) as json_file, open(nii_path) as nii_file:</span></span><br><span class="line">    <span class="comment">#  ... 对同名文件进行操作</span></span><br><span class="line">    <span class="comment"># 另一种思路</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> save_path.exists():  <span class="comment"># 文件夹不存在，则新建文件夹</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;create a new Dir!&#x27;</span>)</span><br><span class="line">        Path.mkdir(save_path)</span><br><span class="line">    move_file = pic_dir / Path(file_name + <span class="string">&#x27;.jpg&#x27;</span>)  <span class="comment"># 重新拼接成picture1.jpg格式</span></span><br><span class="line">    <span class="built_in">print</span>(move_file)</span><br><span class="line">    shutil.copy(move_file, save_path)  <span class="comment"># 将源文件夹的文件复制到save_path中</span></span><br><span class="line">    <span class="comment"># https://segmentfault.com/a/1190000020239664</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果遇到PermissionError: [Errno 13]之类的问题</span></span><br><span class="line"><span class="comment"># 可能是 文件找不到，或者被占用，或者无权限访问，或者打开的不是文件，而是一个目录。</span></span><br><span class="line"><span class="comment"># 参考博客</span></span><br><span class="line"><span class="comment"># https://www.cnblogs.com/lincappu/p/13496306.html</span></span><br><span class="line"><span class="comment"># https://zhuanlan.zhihu.com/p/70127659</span></span><br><span class="line"><span class="comment"># https://www.pythonheidong.com/blog/article/469303/424bc6bd1880effd30ba/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程伦理（2021春）第一章课后习题答案</title>
      <link href="/2022/03/10/%E5%B7%A5%E7%A8%8B%E4%BC%A6%E7%90%86%EF%BC%882021%E6%98%A5%EF%BC%89%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88-gong-cheng-lun-li-2021-chun--di-yi-zhang-ke-hou-xi-ti-da-an/"/>
      <url>/2022/03/10/%E5%B7%A5%E7%A8%8B%E4%BC%A6%E7%90%86%EF%BC%882021%E6%98%A5%EF%BC%89%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88-gong-cheng-lun-li-2021-chun--di-yi-zhang-ke-hou-xi-ti-da-an/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_36468195/article/details/114823214">工程伦理答案</a></p>]]></content>
      
      
      <categories>
          
          <category> 答案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自然辩证法（学堂在线）答案/题库</title>
      <link href="/2022/03/10/%E8%87%AA%E7%84%B6%E8%BE%A9%E8%AF%81%E6%B3%95%EF%BC%88%E5%AD%A6%E5%A0%82%E5%9C%A8%E7%BA%BF%EF%BC%89%E7%AD%94%E6%A1%88%E9%A2%98%E5%BA%93-dialecticsofnature-xue-tang-zai-xian--answer--dataset/"/>
      <url>/2022/03/10/%E8%87%AA%E7%84%B6%E8%BE%A9%E8%AF%81%E6%B3%95%EF%BC%88%E5%AD%A6%E5%A0%82%E5%9C%A8%E7%BA%BF%EF%BC%89%E7%AD%94%E6%A1%88%E9%A2%98%E5%BA%93-dialecticsofnature-xue-tang-zai-xian--answer--dataset/</url>
      
        <content type="html"><![CDATA[<p>答案来自：<a href="https://www.xuetangx.com/learn/NWPU01011000732/NWPU01011000732/10318338/exercise/17318550">学堂在线</a></p><h2 id="第一章">第一章</h2><p><strong>C D D D B</strong><br>《自然辩证法》一书是：C<br>A ①马克思、恩格斯共同完成的著作；<br>B ②恩格斯经过十年努力完成的著作；<br><font color=Red>C ③恩格斯未完成的遗稿；</font><br>D ④马克思撰写；恩格斯整理完成的著作。</p><p>辩证唯物主义自然观讲的是：D<br>A ①人们认识自然的辩证法；<br>B ②人们变革自然的辩证法；<br>C ③人们研究自然的辩证法；<br><font color=Red>D ④自然界本身的辩证法。</font></p><p>自然界物质运动服从某些共同规律表明：D<br>A ①自然界具体物质运动的守恒性；<br>B ②自然界物质运动不灭性；<br>C ③自然界物质运动的绝对性；<br><font color=Red>D ④自然界物质运动统一性。</font></p><p>自然辩证法从当代自然科学的成果来阐述自然界本身的辩证法在人的认识中的反映，这种研究体现了：D<br>A ①自然观与社会历史观的统一；<br>B ②主观辩证法与客观辩证法的统一；<br>C ③世界观与方法论的统一；<br><font color=Red>D ④逻辑与历史的统一。</font></p><p>自然辩证法的学科性质表明它与……处于同一层次B<br>A ①辩证唯物主义；<br><font color=Red>B ②历史唯物主义；</font><br>C ③自然科学；<br>D ④科学社会主义。</p><h2 id="第二章">第二章</h2><p><strong>D A B B ABDFG</strong><br>古代自然观的基本特征：D<br>A ①猜测性、辩证性、逻辑性；<br>B ②直观性、系统性、分析性；<br>C ③思辩性、联系性、综合性；<br><font color=Red>D ④直观性、思辩性、猜测性。</font></p><p>近代自然科学独立并建立体系并获得重大成就，最为重要的原因是：  A<br><font color=Red>A ①科学实验的兴起</font><br>B ②理性与实验相结合<br>C ③人类思想获得解放<br>D ④资本主义生产方式的兴起</p><p>被恩格斯誉为向宗教发出“挑战书”、自然科学独立的“宣言书”的不朽著作是：  B<br>A ①《人体构造论》<br><font color=Red>B ②《天体运行论》</font><br>C ③《两大世界体系的对话》<br>D ④《心血运动论》</p><p>人类的新进化是指：  B<br>A ①纯生物属性的进化；<br><font color=Red>B ②人的社会属性改变推动人的生物属性改变的进化；</font><br>C ③纯社会属性的进化；<br>D ④人类语言符号的进化。</p><p>古代自然观的基本特征：ABDFG<br><font color=Red>A ①康德的“星云假说”</font><br><font color=Red>B ②赖尔《地质学原理》提出的地质渐变理论</font><br>C ③电子的发现及普朗克“能量子”假说<br><font color=Red>D ④能量守恒及转化定律，以及法拉第－麦克斯维的电磁场理论</font><br><font color=Red>F ⑥细胞学说和进化论</font><br><font color=Red>G ⑦道尔顿－阿夫伽德罗的原子－分子论和门捷耶夫的“元素周期律”</font></p><h2 id="第三章">第三章</h2><p><strong>ABCE C A D C</strong><br>科研选题的基本原则是ABCE<br><font color=Red>A ①创新性原则</font><br><font color=Red>B ②科学性原则</font><br><font color=Red>C ③可行性原则</font><br>D ④主体际性<br><font color=Red>E ⑤社会需求原则</font></p><p>公理化方法从本质上说它属于一种：C<br>A ①类比推理；<br>B ②归纳推理；<br><font color=Red>C ③演绎推理；</font><br>D ④直觉推理。</p><p>现代科学哲学研究表明，理论的评价并不是单一的理性评价，其原因在于：A<br><font color=Red>A ①科学理论必须受到实践的检验；</font><br>B ②科学理论是人类思维的创造；<br>C ③科学理论的评价主体是科学权威；<br>D ④科学理论不是理性的事业。</p><p>下列不属于科学假说的主要特点是D<br>A ① 科学性与猜测性的统一<br>B ② 抽象性与形象性的统一<br>C ③ 多样性与易变性的统一<br><font color=Red>D ④ 解释性与预见性的统一</font></p><p>灵感是非逻辑思维的一种重要形式，从形式机制上看，你认为下列解释 哪一个最能反映灵感思维的本质：C<br>A ①辩证唯物主义；<br>B ②历史唯物主义；<br><font color=Red>C ③自然科学；</font><br>D ④科学社会主义。</p><h2 id="第四章">第四章</h2><p><strong>ABC A D B ABCD</strong><br>在21世纪，科学技术工程运行的社会特点是：ABC<br><font color=Red>A ①科学技术工程的职业化</font><br><font color=Red>B ②科学技术工程运行的不平衡性</font><br><font color=Red>C ③科学、技术、工程与社会的一体化</font><br>D ④马克思撰写；恩格斯整理完成的著作。</p><p>科学共同体是具有特定行为规范的社会群体，下列哪一个行为属于科学 共同体的越轨行为：A<br><font color=Red>A ①保密；</font><br>B ②公有性；<br>C ③普遍主义；<br>D ④怀疑；</p><p>知识经济属性表明，科学知识在认识论上意义上是一种：D<br>A ①直接生产力；<br>B ②进化系统；<br>C ③网络知识经济；<br><font color=Red>D ④间接生产力；</font></p><p>科学、技术和工程的外在极限主要是指它们的发展受到：B<br>A ①人类的生理因素的制约和影响；<br><font color=Red>B ②社会环境的制约和影响；</font><br>C ③人类认识功能的制约和影响；<br>D ④科学技术工程形式和内容的制约和影响；</p><p>自然辩证法的学科性质表明它与……处于同一层次ABCD<br><font color=Red>A ①工程伦理素质</font><br><font color=Red>B ②环境保护意识</font><br><font color=Red>C ③成本意识</font><br><font color=Red>D ④品质意识</font></p>]]></content>
      
      
      <categories>
          
          <category> 答案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始 配置吴恩达深度学习课后作业/编程/jupyter环境</title>
      <link href="/2022/02/22/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%20%E9%85%8D%E7%BD%AE%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E7%BC%96%E7%A8%8Bjupyter%E7%8E%AF%E5%A2%83-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AE%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E7%8E%AF%E5%A2%83/"/>
      <url>/2022/02/22/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%20%E9%85%8D%E7%BD%AE%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E7%BC%96%E7%A8%8Bjupyter%E7%8E%AF%E5%A2%83-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AE%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>​<br>安装anaconda后 <a href="https://www.anaconda.com/products/individual">Anaconda | Individual Edition ​</a></p><p>将文件路径放入环境变量中</p><p><img src="https://img-blog.csdnimg.cn/20210321231028426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MjE0Njcx,size_16,color_FFFFFF,t_70" alt=""><br>​​</p><h2 id="创建吴恩达课后作业的python环境">创建吴恩达课后作业的python环境</h2><h3 id="conda创建虚拟环境">conda创建虚拟环境</h3><p>conda创建虚拟环境：<a href="https://blog.csdn.net/H_O_W_E/article/details/77370456">Anaconda创建环境、删除环境、激活环境、退出环境</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n dl_wu python=3.6</span><br></pre></td></tr></table></figure><blockquote><p>如果遇到CondaHTTPError: HTTP 000 CONNECTION FAILED for url <a href="https://repo.anaconda.com/pkgs/main/win-64/current_repodata.json">https://repo.anaconda.com/pkgs/main/win-64/current_repodata.json</a><br>Elapsed: -这个问题。</p></blockquote><p>解决方法：</p><ol><li>conda config --add channels r</li><li>将文件内容改成<br>channels:<br>  - <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</a><br>ssl_verify: true<br>show_channel_urls: true<br><img src="https://img-blog.csdnimg.cn/7737e8ecd6b94fcba1a6c0bdf29700e2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWl90aW1lcg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>参考网址：<br><a href="https://www.cnblogs.com/Yefudaling/p/12422210.html">CondaHTTPError: HTTP 000 CONNECTION FAILED for url &lt;https://repo.anaconda.com/pkgs/main/win-64/current_repodata.json Elapsed: &gt;-错误解决方法</a><br><a href="https://blog.csdn.net/weixin_44510468/article/details/107103783">Anaconda 解决 “CondaHTTPError: HTTP 000 CONNECTION FAILED for url“ 问题 | 解决spyder无法更新到最新版本</a></li></ol><h3 id="安装tensorflow、keras">安装tensorflow、keras</h3><p>python和tensorflow对应的版本：<a href="https://blog.csdn.net/baishuiniyaonulia/article/details/118977952">TensorFlow的历史版本与对应Python版本</a><br>keras和tensorflow对应的版本：<a href="https://blog.csdn.net/weixin_43360896/article/details/114333831">Tensorflow | TF与Keras版本对应</a></p><p>这里我装的是<strong>tensorflow1.14和python3.6</strong></p><p>（不小心删掉pip的话 我是更新失败了就没了：<a href="https://blog.csdn.net/myhes/article/details/106582262">python pip报错 Cannot open Scripts\pip-script.py</a><br>更新用这个语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --upgrade pip</span><br></pre></td></tr></table></figure><p>）</p><p>另外装tensorflow的时候遇到这个问题<br><img src="https://img-blog.csdnimg.cn/8d2c6dd34d5f491fa737ad454bd44aa7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWl90aW1lcg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>解决方法：pip config set install.trusted-host <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a><br>（清华源感觉不好用 可以试试豆瓣源）<br>（小技巧：win键+v 调出粘贴板，旁边三个小点点可以选择固定）<br>参考链接：<a href="https://blog.csdn.net/qq_31720305/article/details/106386078">公司内网 pip 永久设置 指定源和trusted-host</a></p><h3 id="最后">最后</h3><p>其他包 缺啥安啥就行<br>豆瓣源：pip install -i <a href="https://pypi.douban.com/simple/">https://pypi.douban.com/simple/</a> 包名</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PCA人脸识别+GUI+python</title>
      <link href="/2022/02/22/PCA%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB+GUI+python-pca%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%ABguipython/"/>
      <url>/2022/02/22/PCA%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB+GUI+python-pca%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%ABguipython/</url>
      
        <content type="html"><![CDATA[<p>​<br>参考：<a href="https://www.chimaoshu.top/%E5%9F%BA%E4%BA%8EPCA%E7%9A%84%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E7%89%B9%E5%BE%81%E8%84%B8%E6%B3%95/">基于PCA的人脸识别方法——特征脸法</a></p><p>参考：<a href="https://zhuanlan.zhihu.com/p/26652435">人脸识别之主成分分析（PCA）</a></p><p><strong>简易</strong> 系统展示<br><img src="/upload/2022/02/Snipaste_2022-02-22_16-19-23-9bb0ff00b0b647bd9f78e7f0cc5f97e6.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtCore, QtWidgets, QtGui</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QMainWindow, QFileDialog</span><br><span class="line"></span><br><span class="line">root_dir = <span class="string">&#x27;FaceDB_orl&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createDataBase</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--------正在获取数据--------&#x27;</span>)</span><br><span class="line">    path1 = []</span><br><span class="line">    X = []</span><br><span class="line">    <span class="keyword">for</span> dirpath, dirnames, filenames <span class="keyword">in</span> os.walk(path):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> filenames:</span><br><span class="line">            temp_path = os.path.join(dirpath, file)</span><br><span class="line">            path1.append(temp_path)</span><br><span class="line">    <span class="keyword">for</span> img_path <span class="keyword">in</span> path1:</span><br><span class="line">        img = cv.imread(img_path, cv.IMREAD_GRAYSCALE)</span><br><span class="line">        <span class="comment"># img = cv.resize(img, crop_size)</span></span><br><span class="line">        temp = img.reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        X.append(temp)</span><br><span class="line">    X = np.array(X)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(X.shape[0])  # m个数据</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--------获取数据结束--------&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> X.reshape(X.shape[<span class="number">0</span>], X.shape[<span class="number">1</span>]).T  <span class="comment"># (row*col, 400)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eigenface</span>(<span class="params">X, k1=<span class="number">0</span>, k2=<span class="number">0</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--------正在特征提取--------&#x27;</span>)</span><br><span class="line">    m = X.shape[<span class="number">1</span>]  <span class="comment"># 400</span></span><br><span class="line">    <span class="comment"># 计算平均脸及中心化</span></span><br><span class="line">    X_mean = np.mean(X, <span class="number">1</span>)  <span class="comment"># (r*l, 1)</span></span><br><span class="line">    X_mean = np.reshape(X_mean, (-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    X = X - X_mean  <span class="comment"># (r*l, 400)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算协方差矩阵的特征值、特征向量</span></span><br><span class="line">    L_mat = np.dot(X.T, X) / (m - <span class="number">1</span>)  <span class="comment"># (400, 400)</span></span><br><span class="line">    [W, V] = np.linalg.eig(L_mat)  <span class="comment"># 求取特征向量eiv以及特征值eic</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取出特征值大的特征向量 作为特征脸</span></span><br><span class="line">    L_eig_vec = []</span><br><span class="line">    <span class="keyword">if</span> k1 != <span class="number">0</span>:  <span class="comment"># 根据特征值的值来选取向量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(V)):</span><br><span class="line">            <span class="keyword">if</span> W[i] &gt; k1:</span><br><span class="line">                L_eig_vec.append(V[:, i])</span><br><span class="line">    <span class="keyword">if</span> k2 != <span class="number">0</span>:  <span class="comment"># 选取从大到小的k2个向量</span></span><br><span class="line">        index = np.argsort(W)[::-<span class="number">1</span>]</span><br><span class="line">        L_eig_vec = V[index[:k2], :]  <span class="comment"># (k2, 400)</span></span><br><span class="line">    L_eig_vec = np.array(L_eig_vec)</span><br><span class="line">    <span class="comment"># print(L_eig_vec.shape)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 得到协方差矩阵的特征向量组成的投影子空间(脸空间)</span></span><br><span class="line">    Ei_Face = np.dot(X, L_eig_vec.T)  <span class="comment"># (r*l, 399)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--------特征提取结束--------&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> X_mean, X, Ei_Face</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recognition</span>(<span class="params">TestImage, X_mean, X, Ei_Face</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;----------正在识别----------&#x27;</span>)</span><br><span class="line">    <span class="comment"># 将训练数据投影到脸空间内</span></span><br><span class="line">    EI_Num = Ei_Face.shape[<span class="number">1</span>]  <span class="comment"># 合格个数 m</span></span><br><span class="line">    ProjectImage = np.dot(Ei_Face.T, X[:, :EI_Num])  <span class="comment"># (m, m) 每一列是一个特征脸</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取输入图片 灰度读取</span></span><br><span class="line">    input_image = cv.imread(TestImage, cv.IMREAD_GRAYSCALE)</span><br><span class="line">    image = input_image.reshape(-<span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># (row*col, 1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输入图片 中心化 同PCA的第一步</span></span><br><span class="line">    difference = image - X_mean</span><br><span class="line">    <span class="comment"># print(difference)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输入图片投影到脸空间中 同PCA的最后一步</span></span><br><span class="line">    ProjectedTestImage = np.dot(difference.T, Ei_Face).T  <span class="comment"># (399, 1) 变成列向量</span></span><br><span class="line">    <span class="comment"># print(ProjectedTestImage.shape)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算欧式距离 将每行数据(axis=0) - 输入图片 计算欧式距离</span></span><br><span class="line">    Euclidean_dist = np.linalg.norm(ProjectedTestImage - ProjectImage, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 识别图片 距离最相近</span></span><br><span class="line">    Recognized_index = np.argmin(Euclidean_dist, axis=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># print(Euclidean_dist[Recognized_index])</span></span><br><span class="line">    OutputName = Recognized_index + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;----------识别结束----------&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> OutputName</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PcaUI</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    img_path = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    k1 = <span class="number">1</span></span><br><span class="line">    k2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setUI</span>(<span class="params">self, Form</span>):</span><br><span class="line">        Form.setObjectName(<span class="string">&quot;Form&quot;</span>)</span><br><span class="line">        Form.resize(<span class="number">1000</span>, <span class="number">600</span>)</span><br><span class="line">        <span class="comment"># 选择特征获取方式：按值分类 [  ]  按序分类  [   ]</span></span><br><span class="line">        self.label1_1 = QtWidgets.QLabel(Form)</span><br><span class="line">        self.label1_1.setGeometry(QtCore.QRect(<span class="number">250</span>, <span class="number">50</span>, <span class="number">150</span>, <span class="number">40</span>))</span><br><span class="line">        self.label1_2 = QtWidgets.QLabel(Form)</span><br><span class="line">        self.label1_2.setGeometry(QtCore.QRect(<span class="number">390</span>, <span class="number">50</span>, <span class="number">80</span>, <span class="number">40</span>))</span><br><span class="line">        self.label1_3 = QtWidgets.QLabel(Form)</span><br><span class="line">        self.label1_3.setGeometry(QtCore.QRect(<span class="number">640</span>, <span class="number">50</span>, <span class="number">80</span>, <span class="number">40</span>))</span><br><span class="line">        self.textEdit1_1 = QtWidgets.QTextEdit(Form)</span><br><span class="line">        self.textEdit1_1.setGeometry(QtCore.QRect(<span class="number">465</span>, <span class="number">58</span>, <span class="number">150</span>, <span class="number">28</span>))</span><br><span class="line">        self.textEdit1_2 = QtWidgets.QTextEdit(Form)</span><br><span class="line">        self.textEdit1_2.setGeometry(QtCore.QRect(<span class="number">715</span>, <span class="number">58</span>, <span class="number">150</span>, <span class="number">28</span>))</span><br><span class="line">        <span class="comment"># 选择测试图片： [   ]    浏览文件</span></span><br><span class="line">        self.label2 = QtWidgets.QLabel(Form)</span><br><span class="line">        self.label2.setGeometry(QtCore.QRect(<span class="number">250</span>, <span class="number">150</span>, <span class="number">150</span>, <span class="number">40</span>))</span><br><span class="line">        self.textEdit2 = QtWidgets.QTextEdit(Form)</span><br><span class="line">        self.textEdit2.setGeometry(QtCore.QRect(<span class="number">390</span>, <span class="number">158</span>, <span class="number">280</span>, <span class="number">28</span>))</span><br><span class="line">        self.pushButton2 = QtWidgets.QPushButton(Form)</span><br><span class="line">        self.pushButton2.setGeometry(QtCore.QRect(<span class="number">773</span>, <span class="number">154</span>, <span class="number">71</span>, <span class="number">31</span>))</span><br><span class="line">        <span class="comment"># 测试图片   预测图片   开始识别</span></span><br><span class="line">        self.label3_3 = QtWidgets.QLabel(Form)</span><br><span class="line">        self.label3_3.setGeometry(QtCore.QRect(<span class="number">250</span>, <span class="number">230</span>, <span class="number">80</span>, <span class="number">40</span>))</span><br><span class="line">        self.label3_1 = QtWidgets.QLabel(Form)</span><br><span class="line">        self.label3_1.setGeometry(QtCore.QRect(<span class="number">250</span>, <span class="number">260</span>, <span class="number">92</span>, <span class="number">112</span>))</span><br><span class="line">        self.label3_1.setStyleSheet(<span class="string">&quot;background-color: cyan;&quot;</span>)</span><br><span class="line">        self.label3_1.setAlignment(QtCore.Qt.AlignCenter)</span><br><span class="line">        self.label3_4 = QtWidgets.QLabel(Form)</span><br><span class="line">        self.label3_4.setGeometry(QtCore.QRect(<span class="number">460</span>, <span class="number">230</span>, <span class="number">80</span>, <span class="number">40</span>))</span><br><span class="line">        self.label3_2 = QtWidgets.QLabel(Form)</span><br><span class="line">        self.label3_2.setGeometry(QtCore.QRect(<span class="number">460</span>, <span class="number">260</span>, <span class="number">92</span>, <span class="number">112</span>))</span><br><span class="line">        self.label3_2.setStyleSheet(<span class="string">&quot;background-color: cyan;&quot;</span>)</span><br><span class="line">        self.label3_2.setAlignment(QtCore.Qt.AlignCenter)</span><br><span class="line">        self.pushButton3 = QtWidgets.QPushButton(Form)</span><br><span class="line">        self.pushButton3.setGeometry(QtCore.QRect(<span class="number">773</span>, <span class="number">260</span>, <span class="number">71</span>, <span class="number">31</span>))</span><br><span class="line"></span><br><span class="line">        self.pushButton2.clicked.connect(self.openfile)</span><br><span class="line">        self.pushButton3.clicked.connect(self.runPCA)</span><br><span class="line"></span><br><span class="line">        self.reTranslateUI(Form)</span><br><span class="line">        QtCore.QMetaObject.connectSlotsByName(Form)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">openfile</span>(<span class="params">self</span>):</span><br><span class="line">        fname = QFileDialog.getOpenFileName(<span class="literal">None</span>, <span class="string">&quot;打开文件&quot;</span>, <span class="string">&quot;./&quot;</span>, <span class="string">&quot;*.png;;All Files(*)&quot;</span>)</span><br><span class="line">        self.img_path = fname[<span class="number">0</span>]</span><br><span class="line">        s = fname[<span class="number">0</span>].find(<span class="string">&#x27;pca&#x27;</span>)</span><br><span class="line">        self.textEdit2.setText(fname[<span class="number">0</span>][s:])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">runPCA</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.textEdit1_2.toPlainText() != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            self.k1 = <span class="built_in">int</span>(self.textEdit1_1.toPlainText())</span><br><span class="line">        <span class="keyword">if</span> self.textEdit1_2.toPlainText() != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            self.k2 = <span class="built_in">int</span>(self.textEdit1_2.toPlainText())</span><br><span class="line">        png = QtGui.QPixmap(self.img_path).scaled(self.label3_1.width(), self.label3_1.height())</span><br><span class="line">        self.label3_1.setPixmap(png)</span><br><span class="line">        X = createDataBase(root_dir)</span><br><span class="line">        X_mean, X_cen, Ei_Face = eigenface(X, <span class="number">300</span>)</span><br><span class="line">        image_No = recognition(self.img_path, X_mean, X_cen, Ei_Face)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;识别的图片是：&#x27;</span> + <span class="built_in">str</span>(image_No) + <span class="string">&#x27;.png&#x27;</span>)</span><br><span class="line">        img = X[:, image_No - <span class="number">1</span>].reshape(<span class="number">112</span>, <span class="number">92</span>)</span><br><span class="line"></span><br><span class="line">        cv.imwrite(<span class="string">&#x27;./result.png&#x27;</span>, img, [<span class="built_in">int</span>(cv.IMWRITE_JPEG_QUALITY), <span class="number">95</span>])</span><br><span class="line">        png = QtGui.QPixmap(<span class="string">&#x27;./result.png&#x27;</span>).scaled(self.label3_2.width(), self.label3_2.height())</span><br><span class="line">        self.label3_2.setPixmap(png)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reTranslateUI</span>(<span class="params">self, Form</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        选择特征获取方式：按值分类 [  ]  按序分类  [   ]</span></span><br><span class="line"><span class="string">        选择测试图片： [   ]    浏览文件</span></span><br><span class="line"><span class="string">        测试图片   预测图片   开始识别</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        _translate = QtCore.QCoreApplication.translate</span><br><span class="line">        Form.setWindowTitle(_translate(<span class="string">&quot;Form&quot;</span>, <span class="string">&quot;人脸识别--PCA&quot;</span>))</span><br><span class="line">        self.label1_1.setText(_translate(<span class="string">&quot;Form&quot;</span>, <span class="string">&quot;选择特征获取方式：&quot;</span>))</span><br><span class="line">        self.label1_2.setText(_translate(<span class="string">&quot;Form&quot;</span>, <span class="string">&quot;按值分类&quot;</span>))</span><br><span class="line">        self.label1_3.setText(_translate(<span class="string">&quot;Form&quot;</span>, <span class="string">&quot;按序分类&quot;</span>))</span><br><span class="line">        self.textEdit1_1.setPlaceholderText(<span class="string">&#x27;k1(默认为1)&#x27;</span>)</span><br><span class="line">        self.textEdit1_2.setPlaceholderText(<span class="string">&#x27;k2(≤400)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.label2.setText(_translate(<span class="string">&quot;Form&quot;</span>, <span class="string">&quot;选择测试图片：&quot;</span>))</span><br><span class="line">        self.pushButton2.setText(_translate(<span class="string">&quot;Form&quot;</span>, <span class="string">&quot;浏览文件&quot;</span>))</span><br><span class="line"></span><br><span class="line">        self.label3_3.setText(_translate(<span class="string">&quot;Form&quot;</span>, <span class="string">&quot;测试图片&quot;</span>))</span><br><span class="line">        self.label3_1.setText(_translate(<span class="string">&quot;Form&quot;</span>, <span class="string">&quot;测试图片&quot;</span>))</span><br><span class="line">        self.label3_4.setText(_translate(<span class="string">&quot;Form&quot;</span>, <span class="string">&quot;预测图片&quot;</span>))</span><br><span class="line">        self.label3_2.setText(_translate(<span class="string">&quot;Form&quot;</span>, <span class="string">&quot;预测图片&quot;</span>))</span><br><span class="line">        self.pushButton3.setText(_translate(<span class="string">&quot;Form&quot;</span>, <span class="string">&quot;开始识别&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    MainWindow = QMainWindow()</span><br><span class="line">    ui = PcaUI()</span><br><span class="line">    ui.setUI(MainWindow)</span><br><span class="line">    MainWindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>🐱‍🏍学有余力的话 <strong>建议修改界面或添加一些新的功能哦~</strong><br>​</p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> PCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安装教程集合</title>
      <link href="/2022/02/22/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E9%9B%86%E5%90%88-software-installation-set/"/>
      <url>/2022/02/22/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E9%9B%86%E5%90%88-software-installation-set/</url>
      
        <content type="html"><![CDATA[<p>Maven：<a href="https://www.cnblogs.com/Milburn/p/13655369.html">Maven下载及安装 - Milburn - 博客园</a></p><p>MySQL：<a href="https://www.cnblogs.com/winton-nfs/p/11524007.html">MySQL的安装与配置——详细教程 - Winton-H - 博客园</a></p><ol><li>mysqld --install</li><li>mysqld --initialize --console</li><li>net start MySQL</li><li>mysql -u root -p</li><li>alter user ‘root’@‘localhost’ identified by ‘root(此处为你想要的密码)’     ；  exit</li><li>mysql -u root -p(root你的密码)</li><li>%mysql%\bin  （系统环境变量配置那里）</li></ol><p>rational rose：<a href="https://blog.csdn.net/Farewell_w/article/details/104342951">Rational Rose 2007安装及License Key Error问题的解决</a></p><p>​matlab2020b: <a href="https://www.datapro.cool/2164.html">MATLAB 2020b 最新版激活安装（Win版）</a> 解压密码：www.datapro.cool 或者 <a href="http://www.xuebear.com">www.xuebear.com</a> 无空格</p>]]></content>
      
      
      <categories>
          
          <category> 软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
            <tag> Maven </tag>
            
            <tag> MySQL </tag>
            
            <tag> Rational Rose </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA 2019.3.3 永久破解</title>
      <link href="/2022/02/19/IntelliJ%20IDEA%20201933%20%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3-intellijidea201933cracked/"/>
      <url>/2022/02/19/IntelliJ%20IDEA%20201933%20%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3-intellijidea201933cracked/</url>
      
        <content type="html"><![CDATA[<p>​<br><strong>感谢原文博主！</strong><br>程序安装包下载：<br>链接：<a href="https://pan.baidu.com/s/1RigVWufNh-TF84zCYjxhAw">https://pan.baidu.com/s/1RigVWufNh-TF84zCYjxhAw</a><br>提取码：i3om</p><p>破解补丁：<br>链接：<a href="https://pan.baidu.com/s/1ThXITtJN29BwF80Hv0-fkg">https://pan.baidu.com/s/1ThXITtJN29BwF80Hv0-fkg</a><br>提取码：yvey</p><p><strong>破解</strong><br>       在破解之前，需要下载的文件有两个ideaIU-2019.3.3.exe、jetbrains-agent-latest.zip，前者是程序安装包，后者是破解补丁包，下载补丁包后解压里面的jetbrains-agent.jar和important.txt到容易找到的地方且在同级目录下(推荐放在IDEA的安装目录下)。具体操作如下图所示：</p><ul><li>打开IDEA</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/fa8218b640b7d2fce93995b15e3116a8.png" alt=""></p><ul><li><p>重新启动IDEA：</p></li><li><p>打开配置文件<br><img src="https://img-blog.csdnimg.cn/img_convert/a246a83307be151901030753fb9a7721.png" alt=""></p></li></ul><p>在最后一行加入’<strong>-javaagent:</strong>'且后面再跟上你的破解补丁的位置，两者都要在同一行上；这里的路径千万别输错且不能有中文，否则以后会打不开IDEA，最好直接复制再加上文件名；改完后记得保存。<br><img src="https://img-blog.csdnimg.cn/img_convert/02919e8bb8d83e732b81059546c21280.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/img_convert/d7f9224310d57813b001cf5a9c501c52.png" alt=""></p><ul><li>自动破解</li></ul><p>重启完成后正常情况下就已经自动破解成功了，可以去下面的地方去看下结果。<br><img src="https://img-blog.csdnimg.cn/img_convert/ebb4da6fede5a19d8b1877e3a7ef0de5.png" alt=""></p><ul><li><p>手动破解：</p></li><li><ul><li>进入idea激活界面<br><img src="https://img-blog.csdnimg.cn/img_convert/c0c31996e2ddb77352c5788262e74d85.png" alt=""></li></ul></li><li><ul><li>License server方式激活<br>要使用License server激活就点击<code>License server</code>,下面的<code>Server address</code>中输入<code>http://fls.jetbrains-agent.com</code>，再点<code>Activate</code>，如出现下图的情况则激活成功。<br><img src="https://img-blog.csdnimg.cn/img_convert/0e22b612852061b1f27c5de88f1d4b75.png" alt=""><br><img src="https://img-blog.csdnimg.cn/img_convert/7e9bbdb6712440aafca32956a68da426.png" alt=""></li></ul></li><li><ul><li><strong>Activation code</strong></li></ul></li></ul><p>要使用Activation code激活就点击<code>Activation code</code>,并在下面的输入框中粘贴下面的激活码</p><blockquote></blockquote><p>3AGXEJXFK9-eyJsaWNlbnNlSWQiOiIzQUdYRUpYRks5IiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9XSwiaGFzaCI6IjEyNzk2ODc3LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-WGTHs6XpDhr+uumvbwQPOdlxWnQwgnGaL4eRnlpGKApEEkJyYvNEuPWBSrQkPmVpim/8Sab6HV04Dw3IzkJT0yTc29sPEXBf69+7y6Jv718FaJu4MWfsAk/ZGtNIUOczUQ0iGKKnSSsfQ/3UoMv0q/yJcfvj+me5Zd/gfaisCCMUaGjB/lWIPpEPzblDtVJbRexB1MALrLCEoDv3ujcPAZ7xWb54DiZwjYhQvQ+CvpNNF2jeTku7lbm5v+BoDsdeRq7YBt9ANLUKPr2DahcaZ4gctpHZXhG96IyKx232jYq9jQrFDbQMtVr3E+GsCekMEWSD//dLT+HuZdc1sAIYrw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==</p><p>再点Activate，如果出现如下图所示，则激活成功<br><img src="https://img-blog.csdnimg.cn/img_convert/6f9b4bb200bc28b9f62265623de64172.png" alt=""></p><p>我个人是在hosts文件里加上了<br>0.0.0.0 <a href="http://account.jetbrains.com">account.jetbrains.com</a><br>0.0.0.0 <a href="http://www.jetbrains.com">www.jetbrains.com</a></p><p>然后用最后一个方法成功了</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python问题集锦1</title>
      <link href="/2022/02/16/Python%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A61-python-questions-1/"/>
      <url>/2022/02/16/Python%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A61-python-questions-1/</url>
      
        <content type="html"><![CDATA[<h2 id="ImportError-No-module-named-tensorflow">ImportError: No module named tensorflow</h2><p>如果你是在jupyter notebook中出现这个错误。先看你是否安装了tensorflow 其次看你是否安装了jupyter notebook。<br>我用conda管理环境的时候 运行的环境里没有jupyter notebook 他估计自动调用了全局的notebook ，但是全局没有tensorflow，然后就报错了。</p>]]></content>
      
      
      <categories>
          
          <category> 问题集锦 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
7bd9f78e7f0cc5f97e6.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtCore, QtWidgets, QtGui</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QMainWindow, QFileDialog</span><br><span class="line"></span><br><span class="line">root_dir = <span class="string">&#x27;FaceDB_orl&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createDataBase</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--------正在获取数据--------&#x27;</span>)</span><br><span class="line">    path1 = []</span><br><span class="line">    X = []</span><br><span class="line">    <span class="keyword">for</span> dirpath, dirnames, filenames <span class="keyword">in</span> os.walk(path):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> filenames:</span><br><span class="line">            temp_path = os.path.join(dirpath, file)</span><br><span class="line">            path1.append(temp_path)</span><br><span class="line">    <span class="keyword">for</span> img_path <span class="keyword">in</span> path1:</span><br><span class="line">        img = cv.imread(img_path, cv.IMREAD_GRAYSCALE)</span><br><span class="line">        <span class="comment"># img = cv.resize(img, crop_size)</span></span><br><span class="line">        temp = img.reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        X.append(temp)</span><br><span class="line">    X = np.array(X)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(X.shape[0])  # m个数据</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--------获取数据结束--------&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> X.reshape(X.shape[<span class="number">0</span>], X.shape[<span class="number">1</span>]).T  <span class="comment"># (row*col, 400)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eigenface</span>(<span class="params">X, k1=<span class="number">0</span>, k2=<span class="number">0</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--------正在特征提取--------&#x27;</span>)</span><br><span class="line">    m = X.shape[<span class="number">1</span>]  <span class="comment"># 400</span></span><br><span class="line">    <span class="comment"># 计算平均脸及中心化</span></span><br><span class="line">    X_mean = np.mean(X, <span class="number">1</span>)  <span class="comment"># (r*l, 1)</span></span><br><span class="line">    X_mean = np.reshape(X_mean, (-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    X = X - X_mean  <span class="comment"># (r*l, 400)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算协方差矩阵的特征值、特征向量</span></span><br><span class="line">    L_mat = np.dot(X.T, X) / (m - <span class="number">1</span>)  <span class="comment"># (400, 400)</span></span><br><span class="line">    [W, V] = np.linalg.eig(L_mat)  <span class="comment"># 求取特征向量eiv以及特征值eic</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取出特征值大的特征向量 作为特征脸</span></span><br><span class="line">    L_eig_vec = []</span><br><span class="line">    <span class="keyword">if</span> k1 != <span class="number">0</span>:  <span class="comment"># 根据特征值的值来选取向量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(V)):</span><br><span class="line">            <span class="keyword">if</span> W[i] &gt; k1:</span><br><span class="line">                L_eig_vec.append(V[:, i])</span><br><span class="line">    <span class="keyword">if</span> k2 != <span class="number">0</span>:  <span class="comment"># 选取从大到小的k2个向量</span></span><br><span class="line">        index = np.argsort(W)[::-<span class="number">1</span>]</span><br><span class="line">        L_eig_vec = V[index[:k2], :]  <span class="comment"># (k2, 400)</span></span><br><span class="line">    L_eig_vec = np.array(L_eig_vec)</span><br><span class="line">    <span class="comment"># print(L_eig_vec.shape)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 得到协方差矩阵的特征向量组成的投影子空间(脸空间)</span></span><br><span class="line">    Ei_Face = np.dot(X, L_eig_vec.T)  <span class="comment"># (r*l, 399)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--------特征提取结束--------&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> X_mean, X, Ei_Face</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recognition</span>(<span class="params">TestImage, X_mean, X, Ei_Face</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;----------正在识别----------&#x27;</span>)</span><br><span class="line">    <span class="comment"># 将训练数据投影到脸空间内</span></span><br><span class="line">    EI_Num = Ei_Face.shape[<span class="number">1</span>]  <span class="comment"># 合格个数 m</span></span><br><span class="line">    ProjectImage = np.dot(Ei_Face.T, X[:, :EI_Num])  <span class="comment"># (m, m) 每一列是一个特征脸</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取输入图片 灰度读取</span></span><br><span class="line">    input_image = cv.imread(TestImage, cv.IMREAD_GRAYSCALE)</span><br><span class="line">    image = input_image.reshape(-<span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># (row*col, 1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输入图片 中心化 同PCA的第一步</span></span><br><span class="line">    difference = image - X_mean</span><br><span class="line">    <span class="comment"># print(difference)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输入图片投影到脸空间中 同PCA的最后一步</span></span><br><span class="line">    ProjectedTestImage = np.dot(difference.T, Ei_Face).T  <span class="comment"># (399, 1) 变成列向量</span></span><br><span class="line">    <span class="comment"># print(ProjectedTestImage.shape)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算欧式距离 将每行数据(axis=0) - 输入图片 计算欧式距离</span></span><br><span class="line">    Euclidean_dist = np.linalg.norm(ProjectedTestImage - ProjectImage, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 识别图片 距离最相近</span></span><br><span class="line">    Recognized_index = np.argmin(Euclidean_dist, axis=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># print(Euclidean_dist[Recognized_index])</span></span><br><span class="line">    OutputName = Recognized_index + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;----------识别结束----------&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> OutputName</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PcaUI</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    img_path = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    k1 = <span class="number">1</span></span><br><span class="line">    k2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setUI</span>(<span class="params">self, Form</span>):</span><br><span class="line">        Form.setObjectName(<span class="string">&quot;Form&quot;</span>)</span><br><span class="line">        Form.resize(<span class="number">1000</span>, <span class="number">600</span>)</span><br><span class="line">        <span class="comment"># 选择特征获取方式：按值分类 [  ]  按序分类  [   ]</span></span><br><span class="line">        self.label1_1 = QtWidgets.QLabel(Form)</span><br><span class="line">        self.label1_1.setGeometry(QtCore.QRect(<span class="number">250</span>, <span class="number">50</span>, <span class="number">150</span>, <span class="number">40</span>))</span><br><span class="line">        self.label1_2 = QtWidgets.QLabel(Form)</span><br><span class="line">        self.label1_2.setGeometry(QtCore.QRect(<span class="number">390</span>, <span class="number">50</span>, <span class="number">80</span>, <span class="number">40</span>))</span><br><span class="line">        self.label1_3 = QtWidgets.QLabel(Form)</span><br><span class="line">        self.label1_3.setGeometry(QtCore.QRect(<span class="number">640</span>, <span class="number">50</span>, <span class="number">80</span>, <span class="number">40</span>))</span><br><span class="line">        self.textEdit1_1 = QtWidgets.QTextEdit(Form)</span><br><span class="line">        self.textEdit1_1.setGeometry(QtCore.QRect(<span class="number">465</span>, <span class="number">58</span>, <span class="number">150</span>, <span class="number">28</span>))</span><br><span class="line">        self.textEdit1_2 = QtWidgets.QTextEdit(Form)</span><br><span class="line">        self.textEdit1_2.setGeometry(QtCore.QRect(<span class="number">715</span>, <span class="number">58</span>, <span class="number">150</span>, <span class="number">28</span>))</span><br><span class="line">        <span class="comment"># 选择测试图片： [   ]    浏览文件</span></span><br><span class="line">        self.label2 = QtWidgets.QLabel(Form)</span><br><span class="line">        self.label2.setGeometry(QtCore.QRect(<span class="number">250</span>, <span class="number">150</span>, <span class="number">150</span>, <span class="number">40</span>))</span><br><span class="line">        self.textEdit2 = QtWidgets.QTextEdit(Form)</span><br><span class="line">        self.textEdit2.setGeometry(QtCore.QRect(<span class="number">390</span>, <span class="number">158</span>, <span class="number">280</span>, <span class="number">28</span>))</span><br><span class="line">        self.pushButton2 = QtWidgets.QPushButton(Form)</span><br><span class="line">        self.pushButton2.setGeometry(QtCore.QRect(<span class="number">773</span>, <span class="number">154</span>, <span class="number">71</span>, <span class="number">31</span>))</span><br><span class="line">        <span class="comment"># 测试图片   预测图片   开始识别</span></span><br><span class="line">        self.label3_3 = QtWidgets.QLabel(Form)</span><br><span class="line">        self.label3_3.setGeometry(QtCore.QRect(<span class="number">250</span>, <span class="number">230</span>, <span class="number">80</span>, <span class="number">40</span>))</span><br><span class="line">        self.label3_1 = QtWidgets.QLabel(Form)</span><br><span class="line">        self.label3_1.setGeometry(QtCore.QRect(<span class="number">250</span>, <span class="number">260</span>, <span class="number">92</span>, <span class="number">112</span>))</span><br><span class="line">        self.label3_1.setStyleSheet(<span class="string">&quot;background-color: cyan;&quot;</span>)</span><br><span class="line">        self.label3_1.setAlignment(QtCore.Qt.AlignCenter)</span><br><span class="line">        self.label3_4 = QtWidgets.QLabel(Form)</span><br><span class="line">        self.label3_4.setGeometry(QtCore.QRect(<span class="number">460</span>, <span class="number">230</span>, <span class="number">80</span>, <span class="number">40</span>))</span><br><span class="line">        self.label3_2 = QtWidgets.QLabel(Form)</span><br><span class="line">        self.label3_2.setGeometry(QtCore.QRect(<span class="number">460</span>, <span class="number">260</span>, <span class="number">92</span>, <span class="number">112</span>))</span><br><span class="line">        self.label3_2.setStyleSheet(<span class="string">&quot;background-color: cyan;&quot;</span>)</span><br><span class="line">        self.label3_2.setAlignment(QtCore.Qt.AlignCenter)</span><br><span class="line">        self.pushButton3 = QtWidgets.QPushButton(Form)</span><br><span class="line">        self.pushButton3.setGeometry(QtCore.QRect(<span class="number">773</span>, <span class="number">260</span>, <span class="number">71</span>, <span class="number">31</span>))</span><br><span class="line"></span><br><span class="line">        self.pushButton2.clicked.connect(self.openfile)</span><br><span class="line">        self.pushButton3.clicked.connect(self.runPCA)</span><br><span class="line"></span><br><span class="line">        self.reTranslateUI(Form)</span><br><span class="line">        QtCore.QMetaObject.connectSlotsByName(Form)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">openfile</span>(<span class="params">self</span>):</span><br><span class="line">        fname = QFileDialog.getOpenFileName(<span class="literal">None</span>, <span class="string">&quot;打开文件&quot;</span>, <span class="string">&quot;./&quot;</span>, <span class="string">&quot;*.png;;All Files(*)&quot;</span>)</span><br><span class="line">        self.img_path = fname[<span class="number">0</span>]</span><br><span class="line">        s = fname[<span class="number">0</span>].find(<span class="string">&#x27;pca&#x27;</span>)</span><br><span class="line">        self.textEdit2.setText(fname[<span class="number">0</span>][s:])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">runPCA</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.textEdit1_2.toPlainText() != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            self.k1 = <span class="built_in">int</span>(self.textEdit1_1.toPlainText())</span><br><span class="line">        <span class="keyword">if</span> self.textEdit1_2.toPlainText() != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            self.k2 = <span class="built_in">int</span>(self.textEdit1_2.toPlainText())</span><br><span class="line">        png = QtGui.QPixmap(self.img_path).scaled(self.label3_1.width(), self.label3_1.height())</span><br><span class="line">        self.label3_1.setPixmap(png)</span><br><span class="line">        X = createDataBase(root_dir)</span><br><span class="line">        X_mean, X_cen, Ei_Face = eigenface(X, <span class="number">300</span>)</span><br><span class="line">        image_No = recognition(self.img_path, X_mean, X_cen, Ei_Face)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;识别的图片是：&#x27;</span> + <span class="built_in">str</span>(image_No) + <span class="string">&#x27;.png&#x27;</span>)</span><br><span class="line">        img = X[:, image_No - <span class="number">1</span>].reshape(<span class="number">112</span>, <span class="number">92</span>)</span><br><span class="line"></span><br><span class="line">        cv.imwrite(<span class="string">&#x27;./result.png&#x27;</span>, img, [<span class="built_in">int</span>(cv.IMWRITE_JPEG_QUALITY), <span class="number">95</span>])</span><br><span class="line">        png = QtGui.QPixmap(<span class="string">&#x27;./result.png&#x27;</span>).scaled(self.label3_2.width(), self.label3_2.height())</span><br><span class="line">        self.label3_2.setPixmap(png)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reTranslateUI</span>(<span class="params">self, Form</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        选择特征获取方式：按值分类 [  ]  按序分类  [   ]</span></span><br><span class="line"><span class="string">        选择测试图片： [   ]    浏览文件</span></span><br><span class="line"><span class="string">        测试图片   预测图片   开始识别</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        _translate = QtCore.QCoreApplication.translate</span><br><span class="line">        Form.setWindowTitle(_translate(<span class="string">&quot;Form&quot;</span>, <span class="string">&quot;人脸识别--PCA&quot;</span>))</span><br><span class="line">        self.label1_1.setText(_translate(<span class="string">&quot;Form&quot;</span>, <span class="string">&quot;选择特征获取方式：&quot;</span>))</span><br><span class="line">        self.label1_2.setText(_translate(<span class="string">&quot;Form&quot;</span>, <span class="string">&quot;按值分类&quot;</span>))</span><br><span class="line">        self.label1_3.setText(_translate(<span class="string">&quot;Form&quot;</span>, <span class="string">&quot;按序分类&quot;</span>))</span><br><span class="line">        self.textEdit1_1.setPlaceholderText(<span class="string">&#x27;k1(默认为1)&#x27;</span>)</span><br><span class="line">        self.textEdit1_2.setPlaceholderText(<span class="string">&#x27;k2(≤400)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.label2.setText(_translate(<span class="string">&quot;Form&quot;</span>, <span class="string">&quot;选择测试图片：&quot;</span>))</span><br><span class="line">        self.pushButton2.setText(_translate(<span class="string">&quot;Form&quot;</span>, <span class="string">&quot;浏览文件&quot;</span>))</span><br><span class="line"></span><br><span class="line">        self.label3_3.setText(_translate(<span class="string">&quot;Form&quot;</span>, <span class="string">&quot;测试图片&quot;</span>))</span><br><span class="line">        self.label3_1.setText(_translate(<span class="string">&quot;Form&quot;</span>, <span class="string">&quot;测试图片&quot;</span>))</span><br><span class="line">        self.label3_4.setText(_translate(<span class="string">&quot;Form&quot;</span>, <span class="string">&quot;预测图片&quot;</span>))</span><br><span class="line">        self.label3_2.setText(_translate(<span class="string">&quot;Form&quot;</span>, <span class="string">&quot;预测图片&quot;</span>))</span><br><span class="line">        self.pushButton3.setText(_translate(<span class="string">&quot;Form&quot;</span>, <span class="string">&quot;开始识别&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    MainWindow = QMainWindow()</span><br><span class="line">    ui = PcaUI()</span><br><span class="line">    ui.setUI(MainWindow)</span><br><span class="line">    MainWindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>🐱‍🏍学有余力的话 <strong>建议修改界面或添加一些新的功能哦~</strong><br>​</p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> PCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安装教程集合</title>
      <link href="/2022/02/22/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E9%9B%86%E5%90%88-software-installation-set/"/>
      <url>/2022/02/22/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E9%9B%86%E5%90%88-software-installation-set/</url>
      
        <content type="html"><![CDATA[<p>Maven：<a href="https://www.cnblogs.com/Milburn/p/13655369.html">Maven下载及安装 - Milburn - 博客园</a></p><p>MySQL：<a href="https://www.cnblogs.com/winton-nfs/p/11524007.html">MySQL的安装与配置——详细教程 - Winton-H - 博客园</a></p><ol><li>mysqld –install</li><li>mysqld –initialize –console</li><li>net start MySQL</li><li>mysql -u root -p</li><li>alter user ‘root‘@’localhost’ identified by ‘root(此处为你想要的密码)’     ；  exit</li><li>mysql -u root -p(root你的密码)</li><li>%mysql%\bin  （系统环境变量配置那里）</li></ol><p>rational rose：<a href="https://blog.csdn.net/Farewell_w/article/details/104342951">Rational Rose 2007安装及License Key Error问题的解决</a></p><p>​matlab2020b: <a href="https://www.datapro.cool/2164.html">MATLAB 2020b 最新版激活安装（Win版）</a> 解压密码：<a href="http://www.datapro.cool/">www.datapro.cool</a> 或者 <a href="http://www.xuebear.com/">www.xuebear.com</a> 无空格</p>]]></content>
      
      
      <categories>
          
          <category> 软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
            <tag> Maven </tag>
            
            <tag> MySQL </tag>
            
            <tag> Rational Rose </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA 2019.3.3 永久破解</title>
      <link href="/2022/02/19/IntelliJ%20IDEA%20201933%20%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3-intellijidea201933cracked/"/>
      <url>/2022/02/19/IntelliJ%20IDEA%20201933%20%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3-intellijidea201933cracked/</url>
      
        <content type="html"><![CDATA[<p>​<br><strong>感谢原文博主！</strong><br>程序安装包下载：<br>链接：<a href="https://pan.baidu.com/s/1RigVWufNh-TF84zCYjxhAw">https://pan.baidu.com/s/1RigVWufNh-TF84zCYjxhAw</a><br>提取码：i3om</p><p>破解补丁：<br>链接：<a href="https://pan.baidu.com/s/1ThXITtJN29BwF80Hv0-fkg">https://pan.baidu.com/s/1ThXITtJN29BwF80Hv0-fkg</a><br>提取码：yvey</p><p><strong>破解</strong><br>       在破解之前，需要下载的文件有两个ideaIU-2019.3.3.exe、jetbrains-agent-latest.zip，前者是程序安装包，后者是破解补丁包，下载补丁包后解压里面的jetbrains-agent.jar和important.txt到容易找到的地方且在同级目录下(推荐放在IDEA的安装目录下)。具体操作如下图所示：</p><ul><li>打开IDEA</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/fa8218b640b7d2fce93995b15e3116a8.png"></p><ul><li><p>重新启动IDEA：</p></li><li><p>打开配置文件<br><img src="https://img-blog.csdnimg.cn/img_convert/a246a83307be151901030753fb9a7721.png"></p></li></ul><p>在最后一行加入’<strong>-javaagent:</strong>‘且后面再跟上你的破解补丁的位置，两者都要在同一行上；这里的路径千万别输错且不能有中文，否则以后会打不开IDEA，最好直接复制再加上文件名；改完后记得保存。<br><img src="https://img-blog.csdnimg.cn/img_convert/02919e8bb8d83e732b81059546c21280.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/d7f9224310d57813b001cf5a9c501c52.png"> </p><ul><li>自动破解</li></ul><p>重启完成后正常情况下就已经自动破解成功了，可以去下面的地方去看下结果。<br><img src="https://img-blog.csdnimg.cn/img_convert/ebb4da6fede5a19d8b1877e3a7ef0de5.png"></p><ul><li><p>手动破解：</p></li><li><ul><li>进入idea激活界面<br><img src="https://img-blog.csdnimg.cn/img_convert/c0c31996e2ddb77352c5788262e74d85.png"></li></ul></li><li><ul><li>License server方式激活<br>要使用License server激活就点击<code>License server</code>,下面的<code>Server address</code>中输入<code>http://fls.jetbrains-agent.com</code>，再点<code>Activate</code>，如出现下图的情况则激活成功。<br><img src="https://img-blog.csdnimg.cn/img_convert/0e22b612852061b1f27c5de88f1d4b75.png"><br><img src="https://img-blog.csdnimg.cn/img_convert/7e9bbdb6712440aafca32956a68da426.png"></li></ul></li><li><ul><li><strong>Activation code</strong></li></ul></li></ul><p>要使用Activation code激活就点击<code>Activation code</code>,并在下面的输入框中粘贴下面的激活码</p><blockquote></blockquote><p>3AGXEJXFK9-eyJsaWNlbnNlSWQiOiIzQUdYRUpYRks5IiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9XSwiaGFzaCI6IjEyNzk2ODc3LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0&#x3D;-WGTHs6XpDhr+uumvbwQPOdlxWnQwgnGaL4eRnlpGKApEEkJyYvNEuPWBSrQkPmVpim&#x2F;8Sab6HV04Dw3IzkJT0yTc29sPEXBf69+7y6Jv718FaJu4MWfsAk&#x2F;ZGtNIUOczUQ0iGKKnSSsfQ&#x2F;3UoMv0q&#x2F;yJcfvj+me5Zd&#x2F;gfaisCCMUaGjB&#x2F;lWIPpEPzblDtVJbRexB1MALrLCEoDv3ujcPAZ7xWb54DiZwjYhQvQ+CvpNNF2jeTku7lbm5v+BoDsdeRq7YBt9ANLUKPr2DahcaZ4gctpHZXhG96IyKx232jYq9jQrFDbQMtVr3E+GsCekMEWSD&#x2F;&#x2F;dLT+HuZdc1sAIYrw&#x3D;&#x3D;-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG&#x2F;PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg&#x2F;nYV31HLF7fJUAplI&#x2F;1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl&#x2F;GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4&#x2F;G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd&#x2F;GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt&#x2F;wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59&#x2F;THOT7NJQhr6AyLkhhJCdkzE2cob&#x2F;KouVp4ivV7Q3Fc6HX7eepHAAF&#x2F;DpxwgOrg9smX6coXLgfp0b1RU2u&#x2F;tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB&#x2F;40BjpMUrDRCeKuiBahC0DCoU&#x2F;4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV&#x2F;g&#x3D;&#x3D;</p><p>再点Activate，如果出现如下图所示，则激活成功<br><img src="https://img-blog.csdnimg.cn/img_convert/6f9b4bb200bc28b9f62265623de64172.png"></p><p>我个人是在hosts文件里加上了<br>0.0.0.0 account.jetbrains.com<br>0.0.0.0 <a href="http://www.jetbrains.com/">www.jetbrains.com</a></p><p>然后用最后一个方法成功了</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python问题集锦1</title>
      <link href="/2022/02/16/Python%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A61-python-questions-1/"/>
      <url>/2022/02/16/Python%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A61-python-questions-1/</url>
      
        <content type="html"><![CDATA[<h2 id="ImportError-No-module-named-tensorflow"><a href="#ImportError-No-module-named-tensorflow" class="headerlink" title="ImportError: No module named tensorflow"></a>ImportError: No module named tensorflow</h2><p>如果你是在jupyter notebook中出现这个错误。先看你是否安装了tensorflow 其次看你是否安装了jupyter notebook。<br>我用conda管理环境的时候 运行的环境里没有jupyter notebook 他估计自动调用了全局的notebook ，但是全局没有tensorflow，然后就报错了。</p>]]></content>
      
      
      <categories>
          
          <category> 问题集锦 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
